function [res, varargout] = AllVPcs(V, varargin)%AllVPcs(V, ...)  takes an MxN matrix (electrode by voltage) of continuous%voltages, extracts segments triggered off one row, and plots PCS.%  V can also be a filename of a FullV file.  Will only load if new. %%AllVPcs(V,'tchan',c,..    uses Channel c to find trigger points.%AllVPcs(V,'tchan',c,'reclassify')  uses saved clustering and exaclty%recaptiulates. This inlcudes using the previous Eigenvectors.  %AllVPcs(V,'tchan',c,'reapply')  uses saved clustering parameters, but%appies them to new data (e.g. changes in trigger, new probe).%AllVPcs(V,'tchan',c,'reapply', Clusters{p}) uses cluster given %AllVPcs(...'reapply', Clusters{p},'forceevec') Calculates PCA scores using%       the saved eigenvectors, not the eigenvectors calculated with%       current data%AllVPcs(V,'tchan',c,'usecluster') Doesn't recalculate space. Just usesAuto%                    times and classifications from ClusterTimes%AllVPcs(V,'tchan',c,'usecluster', force) uses a list of time indices%        in 'force' as the event list. If force is a strcutre, then%        force.tid gives time indices%        force.clst gives classification%%AllVPcs(name, 'tchan', c, 'refcut')    Applies the cluster defined in RefClusters.mat, if no cluster is yet defined%AllVPcs(name, 'tchan', c, 'refclusterforce') forces application of cluster defined in RefClusters.mat;%                         ...,'matchcounts') adjusts trigger levelto produce same event rate as in the refcluster, not%                            just using the same voltage. %%AllVPcs(V, 'tchan',c,'trigdt') or AllV.AllVPcs(V, 'tchan',c,'dtthr')  trigggers off dVdt%AllVPcs(V, 'tchan',c,'dtthr2') Triggers off second temporal derivative%%AllVPcs(V, 'tchan',c,'dtthr3') Triggers off energy.  N.B. This may be dagnerous, because %  of an attempt to align spikes. The trigger point is moved to the nearest max (th+) or min (th-)%  in the voltage record.  Subsequent attempts to reconstruct the tirgger value will calculatea  differernt energy.% Now that trigger values are saved in ClusterDetails this should be OK%   ....'dtthr3','thboth') disables the voltage alignment so that the tirgger values are correct%  but this can produce artifactual clustering...%%%AllVPcs(V, 'tchan',c, 'triggertemplate', Clusters{p}) convolves trgger%    channel with template in cluster, triggers on peaks%%%AllVPcs(V, 'tchan',c,'pcchan',P)  uses the channels defined in vector P%  to build PCA scores, and summed template scores. Make the second element%  of P your trigger channel - plots by probe are P(2) vs P(1) and P(2) vs%  P(end)%%AllVPcs(V, 'tchan',c,'smooth', sigma)  Smooths the trigger channel with a%Gaussain before triggering. NB this smoothing is NOT applied to the data%then used after triggering. %%By default, AllV.AllVPcs only includes events that happened in a trial%        (+pre/postperiod). To include more events:%...,'usealltrials') includes trials terminated by badfix etc%...,'allspikes')  includes all spikes, ignoring teh expt%       (But be sure teh FullV has everything , ProcessGridFullV(...,'nochopfile'%AllVPcs(V, 'tchan',c,%to build the V file, use MakeProbeIndex to build a list of files% then u%            FullV =% %% PlotSpikeC(files,5,'probes',probelist,'sumv','submean','makev');% to make FullV, the strucutre then used by AllV.AllVPcs%BuildAllFullV calls this for all expts% to fix try% calculateing energy/spkvar for all probes is silly. Wastes memory and% time.%%  Isues to explore. M170 Expt1 Bestspace mahal is 5 but and bmc is 00.32.%  But bmc for PC 1,2 is 0.33.  Is this really the best space? check out%  mahal distances for 1 and 2 D here. THE PC plot is a funny one witha%  ring, and the cluster is stronges on other probes, so may not be soo%  important.  objver = ObjectVersion(AllV);verstr = '$Revision: 1.1 $';version = sscanf(verstr(12:end),'%f');th(1) = 0;setnspk = 0;DATA.addmean = 0; %New default Jan 2012. Add mean back just in avg.ispk = 0;DATA.logfid = -1;%Save memory if load FullV as int and leave them  as ints.  If this causes%trouble, setting convertarg to 'convert' forces conversion to doulbe at%load timeconvertarg = {'noconvert'};nprobepc = 1; % number of probes to include in in pc calculationDATA.clplot = 0; %1 for density plotplottype = 1; %plots made on first pass Could probably be 0 now...plotv = 0;  %plot spikes superimposed on full voltage trace.clusterprops = [];spts = [];gettrigtimes = 0;smoothsd = 0; %smoothing just for trigger criterionsmoothv = 0; %smoothing of all traces for subsequent processingsubtractadj = 0; %subtract off addjacent channeldtryall = [1 0 0 0]; %default set of CSD/dvdt combinations to usedvdts = [0 1 0 0];csds = [0 0 1 2];rejectbydiff = 0;calcdistancematrix = 0;savedistancematrix = 0;DATA.idstr = '';DATA.dvdt = 0;DATA.plotdvdt = 0;DATA.tag.Expt = 'ExptFig';DATA.plot.dprimemin = 0;DATA.plot.xcorrtype = 'xcorr';DATA.plot.labelwithid = 0;DATA.meanvdata = []; %will need to set this so that mean isn't reloaded all the time for UtahFilesDATA.autocutmode = 'mahal';DATA.autorefine = 0;DATA.csd = 0;DATA.dvdy = 0;DATA.ncomponents =2;DATA.name = [];  %directory for current cellDATA.fullvname = []; %full V filename, current exptDATA.plotspk.probes = [];DATA.plotspk.bytrial = 1;DATA.plotspk.allprobes = 0;DATA.plotspk.showmean = 0;DATA.plotspk.showfullv = 0;DATA.plotspk.nfullvprobes = 1;DATA.plotspk.includeprepost = 0;DATA.plotspk.oneprobe = 0;DATA.savetrigger = 0;DATA.cutmode = 'manual';DATA.plottype = 1;DATA.hanldes = [];DATA.ptsz = [1 1];DATA.comparecell = [];DATA.usealltrials = 0;%1 PCS  2-ADCvals  3-template%10-ICSDATA.tmpnorm = 1;DATA.plot.xcorr = 0;DATA.plot.expt = 0;DATA.plot.expttype = 'means';DATA.plot.exptfit = 0;DATA.plot.scaledensity = 0; %autoscale to cluster peakDATA.plot.meantype = 'image+lines';DATA.plot.comparemean = 0;DATA.plot.densityscale = 1.0; %manual scale factroDATA.hidecluster = 0;DATA.vsmps = [20 6 15 11 30 20];DATA.currentcluster = 1;DATA.autofit.maxthriter = 0; %max number of iterations lowering thresholdDATA.usebmi = 0; %now do evertyhing on GM fit. Calculating old indices wastes a lot of timeDATA.lastcut = [];DATA.SpaceTypes = {'Pcs' 'VarE'  'RawV' 'Template'};DATA.elmousept.down = 0;DATA.elmousept.shape = -1;DATA.elmousept.cluster = 0;DATA.elmousept.handles = [];DATA.templatecluster = 1;DATA.vsep = 4;DATA.user = GetUserName();DATA.readlayout = 0;DATA.loadedClusterDetails = 0;prefsdir = '/b/group/matlab/preferences/AllVPcs';DATA.gui.prefsidr = prefsdir;DATA.layoutfile = [];DATA.configfile = [];DATA.plot.isi = 0;DATA.plot.xyseq = 0;DATA.plot.vare = 0; %Show Var/Energy  plotDATA.plot.covar = 0; %plot covariance matrixDATA.plot.xcorrprobes = 0;DATA.subtractmeanV = 0;DATA.isicheck = [20 3];DATA.exptno = 0;DATA.version = 1.12;DATA.progname = ['AllVPcs ' num2str(DATA.version) ' rev' num2str(version)];DATA.trigdt = 0;DATA.maintitle=-1;DATA.clustericon = -1;DATA.clustersubdir = [];DATA.quickcutmode.fit1cut = 0;DATA.quickcutmode.fit2gauss = 1;DATA.quickcutmode.fitallcut = 0;DATA.quickcutmode.quickest = 0;DATA.quickcutmode.plotspikes = 1;DATA.quickcutmode.dropi = 0;DATA.quickcutmode.mean = 0;DATA.quickcutmode.triggerhist = 1;DATA.quickcutmode.dips = 0;DATA.auto.savexy = 1;DATA.auto.backupcluster = 1;DATA.fullvswitchmode.summary = 0;DATA.fullvswitchmode.refcut = 0;DATA.fullvswitchmode.applylast = 0;DATA.iteratefit = 0;DATA.interactive = 0;DATA.expttype = 'Default';DATA.auto.advanceprobe = 0;DATA.auto.advanceexpt = 0;DATA.auto.saveref = 0;DATA.auto.checkxcorr = 0; %check xcorr for cl1/2 if bothDATA.auto.uselastcluster = 0;DATA.auto.replotcluster = 0;DATA.auto.checkcluster = 1;DATA.auto.showxysaved =0;DATA.auto.quickcut=0;DATA.auto.trigstats = 0;DATA.auto.LargeDots = 0;DATA.quicksave.QuickSpikes = 0;DATA.quicksave.QuickDetails = 1;DATA.checkclusters = 1;DATA.check.dropi = [0 2.5];DATA.probelabel = [];DATA.setspkrate = 0;DATA.refinemode = 'cautious';DATA.LastClusters = {};DATA.Comments = [];DATA.ncelltotry = [5 3];DATA.verbose  =0;DATA.errs = {};DATA.errstates = {};DATA.saveallspikes = 1;DATA.ArrayConfig = [];DATA.xyplot.density = 0;DATA.xyplot.xy{1} = 'rTchan';DATA.xyplot.xy{2} = 'absdiff';DATA.xyplot.space = [3 3];DATA.xyplot.id = [1 13];DATA.errpopup = 0;DATA.optimizemode = 'fitdprime';DATA.strictscaling = 0;DATA.triggerset = 0;DATA.refcut.currentset = 0;Expts = {};forcetrigger = 0;forceevec = 0;forceeventlist = [];fixellipse = 0;matcheventcounts = 0;fixerrs = 0;plotsummary = 0;DATA.StdTemplate(1,:) = [ 0 0 0 0 -0.1054   -0.1231   -0.1500   -0.2199   -0.4136   -0.7840 ...      -1.2472   -1.6826   -1.8786   -1.6787   -1.2104   -0.6746   -0.2085    0.1502 ...          0.4361    0.6637    0.8064    0.8326    0.7798    0.7036    0.6378    0.5895 ...             0.5435    0.5011    0.4573    0.4182    0.3855    0.3550    0.3323...             0.3 0.27 0.24 0.21 0.19 0.17 0.15 ]; DATA.StdTemplate(2,:) = [0 0 0 0 -0.036 0.058 0.351 0.804 1.108 0.712 -0.372 -1.346 -1.804 -1.445 0.000 0.700 1.000 0.800 0.650 0.540 0.450 0.400 0.350 0.300 0.250 0.218 0.173 0.139 0.108 0.081 0.064 0.049 0.042 0.035 0.031 0.026 0.022 0.022 0.018 0.014 ];DATA.StdTemplate(3,:) = expand(DATA.StdTemplate(1,:),2,13);DATA.StdTemplate(4,:) = expand(DATA.StdTemplate(1,:),0.5,13);DATA.ntemplates = size(DATA.StdTemplate,1);DATA.AltTemplates{1}{1} = [0 -1; 5 0.4; 10 0.2;];DATA.AltTemplates{1}{2} = [0 -1; 5 0.4; -5 0.4];DATA.AltTemplates{1}{3} = [0 -1; 2 -0.1; 10 0.3; 15 0.2; 20 0.1;];DATA.AltTemplates{2}{1} = expand(DATA.StdTemplate(1,:),0.8,9);DATA.AltTemplates{2}{1} = expand(DATA.StdTemplate(1,:),2,9);DATA.usestdtemplates = 0;DATA.TemplateUsed = [];DATA.Template = [];DATA.RefClusters = {};thsign = 0;calcpconly = 0;calcclscores = 0;muscale = 1;newdata = 0;addch = 0;minenergy = 0;minvar = 0;oldscores = 0;oldcluster = 0;unsafetosave = 0;newdata = 0;DATA.nolog = 0;saveautocut = 0;readclusterfromlog = 0;parallel = 0;DATA.trigtimes = {};DATA.artifacttimes = [];DATA.savespikes = 0;DATA.watcharg = {};DATA.watchplots = 1;DATA.profligate = 0;DATA.keepsmooth = 0;DATA.gui.fontsize(1) = 14;DATA.gui.spikeVoverlap = 0.02;DATA.options.UseLastConfig = 0;DATA.options.UseLastLayout = 0;DATa.guistate = []; %only temporay internal statesDATA.usegmcid = 0;DATA.restricttimerange = [];DATA.excludetrialids = [];DATA.colors{1} = [0.5 0.5 0.5];DATA.colors {2} = [1 0 0];DATA.colors {3} = [0 1 0];DATA.colors {4} = [0 0 1];DATA.colors {5} = [1 0 1];DATA.colors {6} = [1 1 0];DATA.colors {7} = [0 1 1];DATA.colors {8} = [0 1 0];DATA.colors {9} = [0 1 0];DATA.preperiod = 0.05;DATA.postperiod = 0.1;DATA.usetrials = 1;DATA.tag.vhist = 'Vhist';DATA.tag.spikes = 'Spikes';DATA.tag.allspikes = 'AllSpikes';DATA.tag.allxy = 'AllXY';DATA.tag.hist = 'Hist';DATA.tag.probeselect = 'ProbeSelect';DATA.tag.top = 'PCs';DATA.tag.tmplscore = 'TemplateScores';DATA.tag.vare = 'VarE';DATA.tag.meanspike = 'MeanSpike';DATA.tag.covar = 'Covar';DATA.tag.dips = 'Dips';DATA.tag.xcorr = 'Xcorrs';DATA.tag.xcorrpop = 'XcorrPop';DATA.tag.oldxy = 'previousXY';DATA.tag.comparexy = 'CompareXY';DATA.tag.preferences = 'Preferences';DATA.probeswitchmode = 'reapply';DATA.probe = 0; % if no fields, tests cause errorsDATA.tag.allxy = 'AllXY';DATA.tag.celllist = 'AllCellList';DATA.tag.fullv = 'FullV';DATA.tag.comments = 'AllVcomment';DATA.profiling = 0;DATA.hostname = gethostname;DATA.defaultconfig = [prefsdir '/' DATA.hostname '.' GetUserName '.config'];DATA.defaultlayout = [prefsdir '/' DATA.hostname '.' GetUserName '.layout.mat'];DATA.allints = [];DATA.plotrv = 0;useguidata = 0;useoldlst = 0;userefcluster = 0;checklast = 1;reclassifyall = 0;refineall = 0;saveclusters = 0;savearg = 0;spkrate = 50;autocutone = 0;forcecluster = 0;forceclusterexpt = 0;maxspksallowed = 600000;maxspikeset = NaN;maxrate = NaN;recluster = 0;refinecluster = 0;vt = [];plotdprimemax = 0;  %old way to find boundaries. Really no good.bmcrit = 0.21;verbose = 1;DATA.cstarttime = now;oldxyloaded = 0;loadfromspikes = 0;keeptrigger = 1;spoolspikes = 0;forcedrive = 'C:/bgc/data';forcedrive = [];forcename = [];fullVname = [];errs = {};nerr = 0;DATA.showerrs = 0;DATA.showdipvals = 0;X = [];tt = [];tt = AllV.TimeMark(tt,'Start',DATA.profiling);if length(varargin) & strcmp(varargin{end},'autocutall')    autocutall = 1;    autocutarg = length(varargin);else    autocutall = 0;endworker = mygetCurrentTask();needfullv = 0;callstring = [];j = 1;while j <= length(varargin)  %some varags must be parsed first    if isnumeric(varargin{j});        if length(varargin{j}) > 2            callstring = [callstring ' ' num2str(varargin{j}(1)) ':' num2str(varargin{j}(end))];        else            callstring = [callstring ' ' num2str(varargin{j})];        end    elseif ischar(varargin{j})        callstring = [callstring ' ' varargin{j}];    elseif isstruct(varargin{j})        if isfield(varargin{j},'probe')            callstring = [callstring 'Clusters{' num2str(varargin{j}.probe) '}'];        end    end    if strncmp(varargin{j},'allints',6)        j = j+1;        DATA.allints = varargin{j};    elseif strncmp(varargin{j},'addtrigger',7)        DATA.triggerset = 1;    elseif strcmp(varargin{j},'drive')        j = j+1;        if length(varargin{j}) <= 2            if exist('Vall','var')                if Vall.name(2) == ':';                    Vall.name = [varargin{j} Vall.name(3:end)];                else                    Vall.name = [varargin{j} Vall.name];                end            end        else            forcedrive = varargin{j};        end    elseif strncmp(varargin{j},'Expts',5)        j = j+1;        Expts = varargin{j};    elseif strncmp(varargin{j},'Expt',4)        j = j+1;        DATA.Expt = varargin{j};    elseif strncmpi(varargin{j},'exptname',7)        j = j+1;        DATA.exptname = varargin{j};    elseif strncmpi(varargin{j},'fixellipse',7)        fixellipse =1;    elseif strncmpi(varargin{j},'Gridonline',8)        DATA.DataType = 'GridData 96';        DATA.expttype = 'gridonline';    elseif strncmpi(varargin{j},'GridData',5)        DATA.DataType = 'GridData 96';    elseif strncmpi(varargin{j},'name',4)        j = j+1;        forcename = varargin{j};    elseif strncmpi(varargin{j},'highpass',6)        convertarg = {convertarg{:} varargin{j} varargin{j+1}};        j = j+1;1;        DATA.keepsmooth = 1;    elseif strncmp(varargin{j},'needfullv',7)        needfullv = 1;    elseif strncmp(varargin{j},'noninteract',7)        DATA.interactive = -1;        DATA.checkclusters = 0;        DATA.auto.trigstats = 1;        fprintf('Worker %d Nonintereactive',worker.ID);    elseif strncmpi(varargin{j},'trigstats',6)        DATA.auto.trigstats = 1;    elseif strncmpi(varargin{j},'toplevel',6)        j = j+1;        DATA.toplevel = varargin{j};    elseif strncmp(varargin{j},'tchan',5)        j = j+1;        DATA.probe = varargin{j};        ispk = varargin{j};    elseif strncmpi(varargin{j},'toptag',6)        j = j+1;        DATA.tag.top = varargin{j};    elseif strncmp(varargin{j},'usealltrials',7)        DATA.usealltrials = 1;    elseif strncmp(varargin{j},'verbose',4)        verbose = 2;        DATA.verbose = 2;    end    j = j+1;endit = findobj('tag','PCs','type','figure');if ~isempty(it)    X = get(it,'UserData');    if isfield(X,'profiling')        DATA.profiling = X.profiling;    end    if DATA.profiling > 1        tt = AllV.TimeMark(tt,'Profile ON',1);    endendif ischar(V)    if strcmp(V,'nowarn');        warning('off','stats:gmdistribution:FailedToConverge');        warning('off','stats:gmdistribution:MaxIterations');        return;    end    if strcmp(V,'quickop'); %timesaver for working on a new routine.        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        AllV.PCCluster(DATA,[],'PCmultiple');        return;    end    if strncmp(V,'tmplspace',8) %set space for manual ND auto cut        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        DATA.tmplspace(2,1:length(varargin{1})) = varargin{1};        if length(varargin) > 1 && isnumeric(varargin{2})            DATA.ncelltotry = varargin{2}; %number os GM clusters to trya, and which ond to use tof plotting points        end        fprintf('Dimensions are:\n');        for k = 1:length(DATA.TemplateLabels)            fprintf('%d: %s\n',k,DATA.TemplateLabels{k});        end        if strncmp(V,'tmplspacefit',11)           AllV.PCCluster(DATA,[], 'NCellTemplate');        else            set(DATA.toplevel,'UserData',DATA);        end        return;    end    if strncmp(V,'plottrial',8);        id = varargin{1};        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        if strncmp(V,'plottrialtime',13)            DATA.onespiketime = id;            tid = find([DATA.Expt.Trials.Start] < id);            if isempty(tid)                tid = find([DATA.Expt.Trials.End] > id);                id = tid(1);            else                id = tid(end);            end        end        [DATA.currenttrial, DATA.spklst] = AllV.PlotTrialSpikes(DATA,id,'showall');        tic;        set(DATA.toplevel,'UserData',DATA);        return;    end    if strfind(V,'FullV')         fullvname = strrep(V,'FullV',['.p' num2str(ispk(1)) 'FullV']);        if ~exist(V,'file') && exist(fullvname);            V = fullvname;        end    end            if exist(V,'file')        fullVname = V;        toplevel = findobj('type','figure','tag',DATA.tag.top);        if isempty(toplevel)            X.fullvname = '';            b = 'NOFILE';        else            X = get(toplevel,'UserData');            b = regexprep(X.fullvname,'\.p[0-9]*FullV','FullV');        end        a = regexprep(V,'\.p[0-9]*FullV','FullV');        if strcmp(V,X.fullvname) && isappdata(toplevel,'Vall')            DATA = AllV.GetGuiState(DATA, toplevel);            Vall = getappdata(toplevel, 'Vall');            DATA.name = X.name;            DATA.interval = X.interval;            DATA.fullvname = X.fullvname;            if ~strcmp(GetName(X.Expt),GetName(X.name))                DATA.Expt = AllV.LoadExpt(DATA,Vall.exptno);            else                DATA.Expt = X.Expt;            end            newdata = 2;        elseif strcmp(a,b) && isappdata(toplevel,'Vall')            DATA = AllV.GetGuiState(DATA, toplevel);            if verbose > 1                fprintf('%s Loading %s\n',AllV.IDStr(DATA,V));            end            FullV = LoadFullV(V, convertarg{:});            if verbose > 1                fprintf('Loaded %s\n',AllV.IDStr(DATA,V));            end            FullV = AllV.SetFullVNames(DATA, FullV);            DATA.Expt = X.Expt;            DATA.name = X.name;            DATA.interval = X.interval;            DATA.fullvname = fullVname;            V = FullV;            clear FullV;        elseif 1 || ~autocutall %need this for autocutall too            DATA.fullvname = V;            tt = AllV.TimeMark(tt,sprintf('Loading %s (No GUI)',fullVname),1);            %fi figure is already up, clear existing Full first to reduce memory use            if length(toplevel) == 1                 if isappdata(toplevel,'Vall')                rmappdata(toplevel,'Vall');                end                if isappdata(toplevel,'ClusterDetails')                rmappdata(toplevel,'ClusterDetails');                end                DATA.loadedClusterDetails = 0;            end            if verbose                tic;                fprintf('Loading %s %s',fullVname,datestr(now,'HHMM:ss'));            end            FullV = LoadFullV(V, convertarg{:},'meanvdata',DATA.meanvdata);            FullV = AllV.SetFullVNames(DATA, FullV);                if verbose                fprintf(' took %.2f (%d bytes/sec)\n',toc,FullV.readrate);            end            maxl = size(FullV.V,2)-32;            chspk = 1:size(FullV.V,1);            V = FullV;            clear FullV;        else            Vall = V;        end        X = [];    elseif strfind(V,'Spikes') %load AllV from SpikeFiles        loadfromspikes = 1;    else         it = findobj('tag',V,'type','figure');        if length(it) == 1        F = AllV.SetFigure(V);        DATA = get(F,'UserData');        Vall = getappdata(F,'Vall');        vt = DATA.t;        else            res.name = V;            mycprintf('errors','Can''t Find %s\n',V);            return;        end    endendif isfield(V,'Spikes') %Using load from spikes. But typically must    %reload - e.g. if probe changes.    loadfromspikes = 1;endDATA.loadfromspikes = loadfromspikes;if loadfromspikes    nprobepc = -1; %use DATA.chspk    if isfield(V,'name')        DATA.name = V.name;    elseif ischar(V)        DATA.name = V;    end    DATA.fullvname = '';    clear V;    [V, DATA] = AllV.ReadSpikeFiles(DATA, DATA.name);    tt = AllV.TimeMark(tt, sprintf('Loaded Spikes ',mytoc(tt(1).time)),DATA.profiling);    if isempty(V.Spikes)        acknowledge(sprintf('No Spikes for Expt %d',DATA.exptno),X.toplevel);        return;    endendif isstruct(V)    newdata = 1;    Vall = V;    if isfield(Vall,'loadname')        [a,fname] = fileparts(Vall.name);        DATA.name = [fileparts(Vall.loadname)];        if size(Vall.V,1) ==1            p = AllV.GetProbeFromName(Vall.loadname);            if p > 0 && ispk(1) > 0 && p ~= ispk(1);                newname = sprintf('%s/Expt%d.p%dFullV.mat',DATA.name,Vall.exptno,ispk(1));                fprintf('Loading %s\n',newname);                Vall = LoadFullV(newname,convertarg{:});            end        end    else        DATA.name = Vall.name;    end        if isfield(V,'Spikes')    elseif ~isfield(Vall,'V') || isempty(Vall.V)        return;    elseif isinteger(Vall.V) && strcmp(convertarg{1},'convert');        fprintf('Vall Needs converting -> double\n');        Vall.V = double(Vall.V) .* Vall.intscale(1)/Vall.intscale(2);    end%new data but figure is already up,     if DATA.interactive >= 0 || ~isfield(DATA,'Expt')    DATA.Expt = [];    end    it = findobj('type','figure','tag',DATA.tag.top);    if length(it) == 1  & useguidata        DATA = get(it,'UserData');        DATA = AllV.ResetDataForNewProbe(DATA);    elseif length(it) == 1         DATA = AllV.GetGuiState(DATA, it);        DATA.toplevel = it;    end    if length(forcename)        DATA.name = forcename;    elseif length(forcedrive)        DATA.name = regexprep(DATA.name,'[A-Z]:/Spike2/data',forcedrive);        DATA.name = regexprep(DATA.name,'[A-Z]:/smr',forcedrive);    end    tt = AllV.TimeMark(tt,'Pre Expt Load',DATA.profiling);    if isfield(Vall,'exptno')        if isfield(X,'exptno') && X.exptno ~= Vall.exptno %changed Expt           XC = AllV.mygetappdata(DATA,'Clusters');            if ~isempty(XC)                AllV.mysetappdata(DATA,'LastClusters',XC);            end            clear XC;        end        DATA.exptno = Vall.exptno;        if isempty(Expts)            Expts = AllV.mygetappdata(DATA,'Expts');                        if isempty(Expts) || ~strcmp(GetName(Expts),DATA.name)                Expts = ReadExptDir(DATA.name);            elseif verbose > 1                 fprintf('%s Using Expt appdata\n',AllV.IDStr(DATA));            end        end        exptid = GetExptNumber(Expts);        eid = find(exptid == DATA.exptno);        if ~isempty(eid)            DATA.Expt = Expts{eid};        elseif length(Expts) == 1 && GetExptNumber(Expts{1}) == Vall.exptno            DATA.Expt = Expts{1};        elseif isempty(Expts) %load single expt below        else            cprintf('red','Currently Loaded Expt (%d) Struct does not match %s %d\n',exptid(1),Vall.name,Vall.exptno);        end        if DATA.interactive < 0 && isfield(DATA.Expt,'Trials') && GetExptNumber(DATA.Expt) == DATA.exptno            DATA.Expt.Header.trialdur = sum([DATA.Expt.Trials.dur]);            fprintf('%s Expt already loaded\n',AllV.IDStr(DATA));        elseif isfield(DATA.Expt,'exptno') && GetExptNumber(DATA.Expt) == Vall.exptno && ~isempty(Expts)            Expts = Expts;        elseif length(Expts) >= Vall.exptno            %DATA.Expt = Expts{Vall.exptno}; %Done above with eid        elseif isfield(Vall,'matfile')%If there are separate .smr files for each Expt, use LoadExpt. If one .smr file for all%(Utah recordings), use LoadExptA.%Im not sure hwen onefile ever exists. But in practice drops down to exit(Vall.matfile%Could be that this is an error in the order of the arguments to strrep            onefile = strrep(Vall.matfile,'.mat',['Expt' num2str(Vall.exptno) '.mat']);            if exist(onefile,'file')                DATA.Expt = AllV.LoadExptA(DATA,onefile,0);            elseif regexp(Vall.matfile,'\.[0-9]*.mat');                DATA.Expt = AllV.LoadExptA(DATA,Vall.matfile,Vall.exptno);            elseif exist(Vall.matfile) %%Need this for Utah files                DATA.Expt = AllV.LoadExptA(DATA,Vall.matfile,Vall.exptno);                            elseif isfield(Vall,'loadname') && exist(dir2name(fileparts(Vall.loadname),'file'),'file') %%Need this for Utah files                newfile = dir2name(fileparts(Vall.loadname),'file');                AllV.AddErr(DATA,'Cant Read %s, using %s instead',Vall.matfile,newfile);                DATA.Expt = AllV.LoadExptA(DATA,newfile,Vall.exptno);                            else                [DATA.Expt, DATA.matfile] = AllV.LoadExpt(DATA,Vall.exptno);            end            if isempty(DATA.Expt)                res.name = DATA.name;                res = AddError(res,'No Expt in %s\n',Vall.matfile);                return;            end            if isfield(DATA.Expt.Stimvals,'po') && DATA.Expt.Stimvals.po > DATA.postperiod                DATA.postperiod = DATA.Expt.Stimvals.po;                DATA.Expt.Header.postperiod = DATA.postperiod .*10000;            end            if isfield(DATA.Expt.Stimvals,'pr') && DATA.Expt.Stimvals.pr > DATA.preperiod                DATA.preperiod = DATA.Expt.Stimvals.pr;                DATA.Expt.Header.preperiod = DATA.preperiod .*10000;            end            DATA.matfile = Vall.matfile;        else            [DATA.Expt, DATA.matfile] = AllV.LoadExpt(DATA,Vall.exptno);        end        DATA = AllV.SetExpt(DATA);    if verbose > 1        fprintf('%s Expt loaded\n',AllV.IDStr(DATA));    end    tt = AllV.TimeMark(tt,'Expt Loaded',DATA.profiling);                if isempty(DATA.Expt)            DATA.cluster.exptreadmethod = -1;            DATA.Expt.Header = [];%            DATA.plotspk.bytrial = 0;        elseif isfield(DATA.Expt.Header,'ReadMethod')            DATA.cluster.exptreadmethod = DATA.Expt.Header.ReadMethod;        else            DATA.cluster.exptreadmethod = 0;        end        if isfield(DATA.Expt,'Header') && isfield(DATA.Expt.Header,'DataType')            DATA.DataType = DATA.Expt.Header.DataType;        else            DATA.DataType = 'Default';        end        DATA.Expt.exptno = Vall.exptno;        DATA.Trialidlist = AllV.SetTrialList(DATA);    end    if isfield(Vall,'firstblk')        DATA.Expt.blk = Vall.firstblk;        DATA.Expt.exptno = DATA.Expt.exptno+0.1;    else        DATA.Expt.blk = 0;    end    if isfield(Vall,'start')    DATA.starttime = Vall.start;    end    if isfield(Vall,'samper')    DATA.interval = Vall.samper;    DATA.samplerate = 1./DATA.interval;    else    DATA.samplerate = 40000;    DATA.interval = 1./DATA.samplerate;    end    if isfield(Vall,'blklen')        DATA.blklen = Vall.blklen;        DATA.blkstart = Vall.blkstart;    end    DATA.args = varargin;    clear V;elseif isfigure(V)    DATA = get(V,'UserData');    Vall = AllV.mygetappdata(DATA,'Vall');    vt = DATA.t;    newdata = 2;elseif ~isfield(DATA,'name')    Vall.V = V;    newdata = 1;endif DATA.profiling    fprintf('BuildVall  %.4f\n',mytoc(tt(1).time));endif ~isdir(DATA.name)    DATA.datadir = fileparts(DATA.name);else    DATA.datadir = DATA.name;endArray = GetArrayConfig(DATA.datadir);if isempty(DATA.ArrayConfig)    DATA.ArrayConfig = Array;endif isfield(DATA,'toplevel') && isfigure(DATA.toplevel)    DataClusters = AllV.mygetappdata(DATA,'Clusters');else    DataClusters = {};endif needfullvreloadfullv = 1;elsereloadfullv = 0;endif exist('Vall','var') && ~ischar(Vall) && ~isempty(Vall);    if isfield(Vall,'Spikes')        DATA.nprobes = 1;        DATA.allnprobes = length(Array.X);        DATA.spkvar(DATA.probe(1),:) = std(double(Vall.Spikes.values),[],2);        chspk = 1:DATA.allnprobes;    elseif DATA.loadfromspikes  && DATA.exptno ~= Vall.exptno || needfullv        reloadfullv = 1;    else        maxl = size(Vall.V,2)-32;        chspk = 1:size(Vall.V,1);        DATA.nprobes = size(Vall.V,1);        DATA.exptno = Vall.exptno;        DATA.samplerate = 1./Vall.samper;        DATA.allnprobes = DATA.nprobes;    end    if isfield(Vall,'NSlabel')        DATA.probelabel = deblank(Vall.NSlabel);    end    if strncmp(DATA.DataType,'GridData',6)        DATA.allnprobes = sscanf(DATA.DataType,'GridData %d');    endendif verbose > 1    fprintf('%s Start args\n',AllV.IDStr(DATA));endaddmean = [];autocutarg = 0;passonargs = {};j = 1;while j <= length(varargin)    if iscell(varargin{j}) %do nothing. May be parsed in first run above            elseif strncmp(varargin{j},'adcplot',3)        DATA.plottype = 2;      elseif strncmp(varargin{j},'addmean',7)        addmean = 1;    elseif strncmp(varargin{j},'addtrigger',7)        DATA.triggerset = 1;    elseif strncmp(varargin{j},'allspikes',5)        DATA.usetrials = 0;    elseif strncmp(varargin{j},'autocutall',10)        autocutall = 1;        autocutarg = j;    elseif strncmp(varargin{j},'quickautocutall',13)        autocutall = 2;        autocutarg = j;        DATA.autocutmode = 'quick';    elseif strncmp(varargin{j},'quickautocut',9)        autocutone = 1;        DATA.autocutmode = 'quick';    elseif strncmp(varargin{j},'automode',7)        j = j+1;        DATA.autocutmode = varargin{j};    elseif strncmp(varargin{j},'autocut',7)        autocutone = 1;    elseif strncmp(varargin{j},'checklast',8)        checklast = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'cutmode',7)        j = j+1;        DATA.autocutmode = varargin{j};    elseif strncmp(varargin{j},'distancematrix',7)        calcdistancematrix = 6;        savedistancematrix = 1;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'drive',5) %force drive letter        j = j+1;        if length(varargin{j}) == 1        if Vall.name(2) == ':';            Vall.name = [varargin{j} Vall.name(2:end)];        else            Vall.name = [varargin{j} Vall.name];        end        elseif length(varargin{j}) == 2            if Vall.name(2) == ':';                Vall.name = [varargin{j} Vall.name(3:end)];            else                Vall.name = [varargin{j} Vall.name];            end        else            forcedrive = varargin{j};        end        passonargs = {passonargs{:} varargin{j-1} varargin{j}};    elseif strncmp(varargin{j},'fontsize',6)        j = j+1;        DATA.gui.fontsize = varargin{j};    elseif strncmpi(varargin{j},'forceevec',7)        forceevec = 1;        passonargs = {passonargs{:} varargin{j}};  elseif strncmp(varargin{j},'forcetrigger',7)        j = j+1;        forcetrigger = varargin{j};    elseif strncmp(varargin{j},'fixerrs',5)        fixerrs = 1;    elseif strncmpi(varargin{j},'Gridonline',8)        DATA.DataType = 'GridData 96';        DATA.expttype = 'gridonline';    elseif strncmpi(varargin{j},'GridData',5)        DATA.DataType = 'GridData 96';;    elseif strncmp(varargin{j},'ignoretrials',10)        DATA.plotspk.bytrial = 0;    elseif strncmp(varargin{j},'config',5)        DATA.readlayout = 2;        if length(varargin) > j && ischar(varargin{j+1})            j = j+1;            if regexp(varargin{j},'^[A-Z]:') | strfind(varargin{j},'/') %real path                DATA.configfile = varargin{j};            else                DATA.configfile = [prefsdir '/' varargin{j} '.config'];            end        end        DATA = ReadConfig(DATA, DATA.configfile);    elseif strncmp(varargin{j},'layout',5)        DATA.readlayout = 2;         if strncmp(varargin{j},'layoutapply',8)             DATA.readlayout = 2;         end        if length(varargin) > j && ischar(varargin{j+1})            j = j+1;            if regexp(varargin{j},'^[A-Z]:') | strfind(varargin{j},'/') %real path                DATA.layoutfile = varargin{j};            else                DATA.layoutfile = [prefsdir '/' varargin{j} '.layout.mat'];            end        end    elseif strncmp(varargin{j},'newexpt',7)        j = j+1;        eid = varargin{j};        if length(varargin) > j            args = varargin(j+1:end);        else            args = {};        end        Clusters = AllV.mygetappdata(DATA,'Clusters');        AllV.mysetappdata(DATA,'LastClusters',Clusters);        set(DATA.toplevel,'name',['Switching to Expt', num2str(eid)]);         drawnow;        p = AllV.ProbeNumber(DATA);        if DATA.loadfromspikes            name = [DATA.datadir '/Expt' num2str(eid) 'Spikes'];        elseif strncmp(DATA.DataType,'GridData',8)            name = [DATA.name '/Expt' num2str(eid) '.p' num2str(p) 'FullV.mat'];        else            name = [DATA.name '/Expt' num2str(eid) 'FullV.mat'];        end        if isappdata(DATA.toplevel,'Vall')            rmappdata(DATA.toplevel,'Vall');        end        if isappdata(DATA.toplevel,'ClusterDetails')            rmappdata(DATA.toplevel,'ClusterDetails');        end        clear Vall;        DATA.trigtimes = {};        if DATA.loadfromspikes            AllV.AllVPcs(name, 'tchan', p, args{:});            SetFigureName(DATA.toplevel,DATA.tag.top);            return;        end        if ~exist(name)             fprintf('%s Does Not Exist\n',name);            return;        end        if DATA.auto.uselastcluster            args = {args{:} DATA.LastClusters{p}};        end        fprintf('Loading %s ',name);        FullV = LoadFullV(name, convertarg{:});        FullV = AllV.SetFullVNames(DATA, FullV);        fprintf('took  %.2f (%.2f disk) %.1fMb\n',FullV.loadtime,FullV.initialloadtime,FullV.size);        AllV.AllVPcs(FullV, 'tchan', p, args{:});        clear FullV;        SetFigureName(DATA.toplevel,DATA.tag.top);         return;    elseif strncmp(varargin{j},'nomean',5)        addmean = 0;    elseif strncmp(varargin{j},'noninteract',7)        DATA.interactive = -1;        %figure('visible','off');        DATA.watchplots = 0;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'nocheck',5)        checklast = 0;        DATA.checkclusters = 0;    elseif strncmp(varargin{j},'nolog',5)        DATA.nolog = 1;    elseif strncmp(varargin{j},'ncomponents',6)        j = j+1;        DATA.ncomponents = varargin{j};    elseif strncmp(varargin{j},'parallel',7)        parallel = 1;    elseif strncmp(varargin{j},'ptsz',4)        j = j+1;        DATA.ptsz = varargin{j};        if length(DATA.ptsz) ==1            DATA.ptsz(2) = DATA.ptsz(1);        end    elseif strncmp(varargin{j},'refineall',9)         if length(varargin) > j && iscell(varargin{j+1})            j = j+1;            UseClusters = varargin{j};        else            UseClusters = {};        end       DATA.autorefine = 3;       refineall = 1;    elseif sum(strncmp(varargin{j},{'applylast'},6))         recluster = 1;        userefcluster = 3;    elseif sum(strncmp(varargin{j},{'refclusterset'},13))         j = j+1;        DATA.refcut.currentset = varargin{j};    elseif sum(strncmp(varargin{j},{'refclusters' 'refcut'},6)) %        j = j+1;%        rfile = varargin{j};%default is to use refcluster only on files without previous cut, or only%an autocut.  Use 'refclusterforce' to force use of the refcluster.        DATA.RefClusters = LoadRefClusters(DATA);        if ~isempty(DATA.RefClusters)            passonargs = {passonargs{:} varargin{j}};            if strncmp(varargin{j},'refclusterforce',11)                 userefcluster = 1;            else                userefcluster = 2;            end            if recluster == 0                recluster = 1;            end        end    elseif strncmp(varargin{j},'refinecrit',8)        j = j+1;        DATA.autorefine = varargin{j};    elseif strncmp(varargin{j},'refinemode',8)        passonargs = {passonargs{:} varargin{j} varargin{j+1}};        j = j+1;        DATA.refinemode = varargin{j};    elseif strncmp(varargin{j},'refine',6)        refinecluster = 1;        DATA.autorefine = 3; %only refine in origninal scluster dp > 3        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            DATA.autorefine = varargin{j};        elseif forcecluster ==1            DATA.autorefine = 0.1; %if only named 1 cluster, force refine        end    elseif strncmp(varargin{j},'strict',6)        DATA.strictscaling = 1;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'submean',6)        j = j+1;        DATA.subtractmeanV = 1;        meanV = varargin{j};    elseif strncmp(varargin{j},'subdir',6)        j = j+1;        DATA.clustersubdir = varargin{j};    elseif strncmp(varargin{j},'saveautocut',10)        saveautocut = 1;    elseif strncmp(varargin{j},'savespikes',6)        saveclusters = 1;        DATA.savespikes = 1;        savearg = j;        if strncmp(varargin{j},'savespikesonly',14) %just rebuild .spk files            saveclusters = 3;            DATA.savespikes = 3;        end        if strncmp(varargin{j},'savespikesifsafe',14)            saveclusters = 2;        end        if strncmp(varargin{j},'savespikestoman',14)            saveautocut = 2;        end        passonargs = {passonargs{:} varargin{j}};        if j ==1 && saveautocut ~= 2 && length(varargin) == 1 %savespikes lone argument  = save current GUI spikes            it = findobj('type','figure','tag',DATA.tag.top);            if length(it) == 1                DATA = get(it,'UserData');            end            if DATA.cluster.auto == 1 && DATA.recluster == 0                outname = AllV.ClusterFile(DATA.name,DATA.Expt,'auto');            else                outname = AllV.ClusterFile(DATA.name,DATA);            end            DATA =  AllV.SaveClusters(DATA, outname);            AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));           return;        end    elseif strncmp(varargin{j},'savetrigger',6)        DATA.savetrigger = 1;    elseif strncmp(varargin{j},'switchmode',6)        j = j+1;        DATA.probeswitchmode = varargin{j};    elseif strncmp(varargin{j},'subtractadj',9)        subtractadj = 1;    elseif strncmp(varargin{j},'summary',6)        gettrigtimes = 2;             plotsummary = 1;        DATA.probeswitchmode = 'usecluster';    elseif strncmp(varargin{j},'triggerset',7)        j = j+1;        DATA.triggerset = varargin{j};    elseif strncmp(varargin{j},'density',5)        DATA.clplot = 1;    elseif strncmpi(varargin{j},'clusters',4)        if strncmpi(varargin{j},'clusterscores',10)            calcclscores = 1;        end        if length(varargin) > j & iscell(varargin{j+1})        j = j+1;        Clusters = varargin{j};        end    elseif strncmpi(varargin{j},'setcluster',4)        autocut = 1;        if length(varargin) > j && isnumeric(varargin{j+1})            j =j+1;            clusterprops = varargin{j};        end    elseif strncmpi(varargin{j},'dvdt',4)        DATA.dvdt = 1;        tryall = 0;    elseif strncmpi(varargin{j},'accel',4)        DATA.dvdt = 3;        tryall = 0;    elseif strncmpi(varargin{j},'clear',4)        muscale = 0.8;    elseif strncmpi(varargin{j},'csda',4)        DATA.csd = 2;        tryall = 0;    elseif strncmpi(varargin{j},'csd',3)        DATA.csd = 1;        tryall = 0;    elseif strncmpi(varargin{j},'logfid',6)        j = j+1;        DATA.logfid = varargin{j};    elseif strncmpi(varargin{j},'iteratefit',8)        if length(varargin) > j & isnumeric(varargin{j+1})            j = j+1;            DATA.iteratefit = varargin{j};        else            DATA.iteratefit = 1;        end    elseif strncmpi(varargin{j},'mine',4)        j = j+1;        minenergy = varargin{j};    elseif strncmpi(varargin{j},'minvar',6)        j = j+1;        minvar = varargin{j};    elseif strncmpi(varargin{j},'newdata',7)        newdata = 1;    elseif strncmpi(varargin{j},'ndive',5)        j = j+1;        DATA.autofit.maxthriter = varargin{j};    elseif strncmpi(varargin{j},'showwarn',6)        DATA.showerrs = 1;    elseif strncmpi(varargin{j},'plotrv',6)        DATA.plotrv = 1;    elseif strncmpi(varargin{j},'postperiod',6)        j = j+1;        DATA.postperiod = varargin{j};    elseif strncmpi(varargin{j},'preperiod',6)        j = j+1;        DATA.preperiod = varargin{j};    elseif strncmp(varargin{j},'tagsuff',5)        j = j+1;        DATA.tag.spikes = [DATA.tag.spikes  varargin{j}];    elseif strncmp(varargin{j},'testclassify',6)        tic;        E = AllV.BoundaryFromCluster([],DATA.cluster,1);        E.boundarytype = 0;        AllV.PCCluster(DATA,E,1);%        AllV.ClassifySpikes(DATA,DATA.cluster,'quick');        toc;        return;    elseif strncmp(varargin{j},'tryall',5)        tryall = ones(size(csds));    elseif strncmp(varargin{j},'tchan',5)        if strncmp(varargin{j},'tchanreload',10)            newdata = 1;        elseif strncmp(varargin{j},'tchannew',7) || newdata == 2 %set earlier            newdata = 2;            DATA = AllV.ResetDataForNewProbe(DATA);                    else            newdata = 1;        end        j = j+1;                if strcmp(varargin{j},'all')            ispk = 1:DATA.nprobes;        else            ispk = varargin{j};        end        if length(ispk) > 1            addch = 1;            if strncmp(varargin{j-1},'tchanuse',8)                addch = 2;            end        end        if DATA.loadfromspikes && newdata == 2            DATA.probe = ispk;            [Vall, DATA] = AllV.ReadSpikeFiles(DATA, DATA.name);        end    elseif strncmp(varargin{j},'ichan',5)        j = j+1;        ispk = varargin{j};        DATA.TemplateLabels = AllV.TemplateLabels(DATA,0);    elseif strncmp(varargin{j},'matchcounts',8)        matcheventcounts = 1;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'maxrate',6)        j = j+1;        maxrate = varargin{j};    elseif strncmp(varargin{j},'maxspikes',6)        j = j+1;        maxspikeset = varargin{j};    elseif strncmp(varargin{j},'muscale',6)        j = j+1;        muscale = varargin{j};    elseif strncmp(varargin{j},'nprobepc',6)        j = j+1;        nprobepc = varargin{j};    elseif strncmp(varargin{j},'name',4)        j = j+1;        DATA.name = varargin{j};        passonargs = {passonargs{:} varargin{j-1} varargin{j}};    elseif strncmp(varargin{j},'noplot',4)        plottype = 0;    elseif strncmp(varargin{j},'nspk',4)        j = j+1;        setnspk = varargin{j};    elseif strncmp(varargin{j},'oldcl',4)        oldcluster = 1;        if  ~isempty(DataClusters{DATA.probe(1)})            C = DataClusters{DATA.probe(1)};            if C.mine > 0                minenergy = C.mine;                th = C.th;            end        end    elseif strncmp(varargin{j},'oldt',4)        oldscores = 1;    elseif strncmp(varargin{j},'pcchan',5)        j = j+1;        chspk = varargin{j};        nprobepc = -1;    elseif strncmp(varargin{j},'plotprobes',5)        j = j+1;        DATA.plotspk.probes = varargin{j};    elseif strncmpi(varargin{j},'previous',4)        j = j+1;        DATA.lastcut = varargin{j};    elseif strncmp(varargin{j},'plotv',5)        plotv = 1;        F = findobj('Tag','PCs','Type','Figure');        if ~isempty(F)            DATA = get(F,'UserData');            AllV.PlotFullV(DATA, [0 100]);            return;        end    elseif strncmp(varargin{j},'recut',5) %recut operates on whats in DATA        DATA.cluster = DataClusters{DATA.probe(1)};        DATA.csd = DATA.cluster.csd;        DATA.dvdt = DATA.cluster.dvdt;        DATA = AllV.ReClassify(DATA,'newbound');        set(DATA.toplevel,'UserData',DATA);        return;    elseif strncmp(varargin{j},'quantifyall',11)        reclassifyall = 2;    elseif strncmp(varargin{j},'reclassifyall',13)        reclassifyall = 1;    elseif strncmp(varargin{j},'reclassify',6) %reclassify applies cluster space to new data (thr, crit, etc differen)        recluster= 2;        if length(varargin) > j && isfield(varargin{j+1},'dropi')            j = j+1;            DATA.cluster = varargin{j};            forcecluster = 1;        end    elseif strncmp(varargin{j},'readfromlog',8) %reclassify applies cluster space to new data (thr, crit, etc differen)        readclusterfromlog = 1;    elseif strncmp(varargin{j},'uselst',6) %reclassify applies cluster space to new data (thr, crit, etc differen)        useoldlst = 1;    elseif strncmp(varargin{j},'usecluster',6) %Uses cluster ids,times, does not reapply boudnary = quicker        recluster = 4;        if length(varargin) > j && (isnumeric(varargin{j+1}) || isstruct(varargin{j+1}))            j = j+1;            forceeventlist = varargin{j};        end    elseif strncmp(varargin{j},'keepcluster',6) %applies cluster exactly, using current DATA.cluster        recluster= 1;        forcecluster = 2;    elseif strncmp(varargin{j},'reapply',6) %applies cluster exactly, to whatever data is here        recluster= 1;       if strncmp(varargin{j},'reapplyall',10)           reclassifyall = 2;           DATA.auto.refine = 0;       end     if length(varargin) > j && iscell(varargin{j+1})&& isfield(varargin{j+1}{ispk(1)},'dropi')            j = j+1;            DATA.cluster = rmfields(varargin{j}{ispk(1)},'quick');            forcecluster = 1;            forceclusterexpt = DATA.cluster.exptno;            UseClusters = varargin{j};        elseif length(varargin) > j && isfield(varargin{j+1},'dropi')            j = j+1;            DATA.cluster = varargin{j};            forcecluster = 1;            forceclusterexpt = DATA.cluster.exptno;            if DATA.cluster.probe(1) ~= ispk(1)                pshift = ispk(1)-DATA.cluster.probe;                DATA.cluster.templateshift = pshift;                DATA.cluster.MeanSpike.ms =  circshift(DATA.cluster.MeanSpike.ms,pshift);                if isfield(DATA.cluster,'TemplateUsed')                DATA.cluster.TemplateUsed =  circshift(DATA.cluster.TemplateUsed,pshift);                end                DATA.cluster.probe = ispk(1);                DATA.cluster.chspk = DATA.cluster.chspk+pshift;                DATA.cluster.chspk = DATA.cluster.chspk(DATA.cluster.chspk >0 & DATA.cluster.chspk <= DATA.allnprobes);                 p = size(DATA.cluster.MeanSpike.vdprime,1);                if pshift > 0 && p > 2                    DATA.cluster.MeanSpike.vdprime(p+pshift-2:p+pshift,:) = DATA.cluster.MeanSpike.vdprime(p-2:p,:);                end                for k = 1:length(DATA.cluster.next)                    if isfield(DATA.cluster.next{k},'MeanSpiike')                    DATA.cluster.next{k}.MeanSpike.ms =  circshift(DATA.cluster.next{k}.MeanSpike.ms,pshift);                    DATA.cluster.next{k}.TemplateUsed =  circshift(DATA.cluster.next{k}.TemplateUsed,pshift);                    DATA.cluster.next{k}.probe = ispk(1);                    p = size(DATA.cluster.next{k}.MeanSpike.vdprime,1);                    if pshift > 0 && p > 2                        DATA.cluster.next{k}.MeanSpike.vdprime(p+pshift-2:p+pshift,:) = DATA.cluster.next{k}.MeanSpike.vdprime(p-2:p,:);                    end                    end                end            end            DATA.cluster = rmfields(DATA.cluster,'quick'); %if previous cut was quick, want to start over        end    elseif strncmp(varargin{j},'rejectbydiff',8)        j = j+1        rejectbydiff = varargin{j};    elseif strncmp(varargin{j},'spool',4)        spoolspikes = 1;    elseif strncmp(varargin{j},'spts',4)        j = j+1;        spts = varargin{j};    elseif strncmp(varargin{j},'vsmps',4)        j = j+1;        DATA.vsmps = varargin{j};    elseif strncmpi(varargin{j},'trigtimes',8)        gettrigtimes = 1;    elseif strncmp(varargin{j},'vsmooth',4)        j = j+1;        smoothv = varargin{j};    elseif strncmp(varargin{j},'smooth',4)        j = j+1;        smoothsd = varargin{j};    elseif strncmp(varargin{j},'spkrate',4)        j = j+1;        spkrate = varargin{j};        th = NaN;    elseif strncmp(varargin{j},'th+',3)        thsign = 1;        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end    elseif strncmp(varargin{j},'th-',3)        thsign = 0;        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end    elseif strncmp(varargin{j},'thboth',4)        thsign = 2;    elseif strncmp(varargin{j},'template',6) %reclassify applies cluster space to new data (thr, crit, etc differen)       if strncmp(varargin{j},'templateshift',12) %move template to match probe           forcecluster = 2;       end        j = j+1;        recluster= 3;        DATA.plottype = 3;        if length(varargin{j}) == 1 && ~iscell(varargin{j})            DATA.forceclusters{1} = varargin{j};        else            DATA.forceclusters = varargin{j};        end       if forcecluster == 2        for k = 1:length(DATA.forceclusters)           DATA.forceclusters{k}.MeanSpike.ms =  circshift(DATA.forceclusters{k}.MeanSpike.ms,ispk(1)-DATA.forceclusters{k}.probe);        end       end        DATA.cluster = DATA.forceclusters{1};        forcecluster = 1;        plottype = 0;    elseif strncmp(varargin{j},'bestspace',8)        AllV.PCCluster(DATA, 0, 23);        return;    elseif strncmp(varargin{j},'autobestspace',8)        AllV.PCCluster(DATA, 0, 26);        return;    elseif strncmp(varargin{j},'rpttemplate',6) %rebuild template scores, redo bestspace        AllV.TemplatePlot(DATA);        DATA = get(DATA.toplevel,'UserData');        AllV.PCCluster(DATA, 0, 23);        return;    elseif strncmp(varargin{j},'saveclusters',10)        saveclusters = 1;    elseif strncmp(varargin{j},'templateline',10)        AllV.PCCluster(DATA, 0, 6);    elseif strncmp(varargin{j},'plotold',7)        DATA.clst = DATA.oldclst;        AllV.ReplotPCs(DATA,[]);        set(DATA.toplevel,'UserData',DATA);    elseif strncmp(varargin{j},'plottemplate',8)        AllV.TemplatePlot(DATA);        DATA = get(DATA.toplevel,'UserData');    elseif strncmp(varargin{j},'dtthreshold',5)        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end         if strncmp(varargin{j},'dtthr2',6)             DATA.trigdt = 2;         elseif strncmp(varargin{j},'dtthr3',6)             DATA.trigdt = 3;         else            DATA.trigdt = 1;         end    elseif strncmp(varargin{j},'triggertemplate',10)        if strncmp(varargin{j},'triggertemplatedt',17)            DATA.trigdt = 5;        else            DATA.trigdt = 4;        end        j = j+1;        if length(varargin{j}) == 1            if isfield(varargin{j},'MeanSpike')                DATA.TriggerTemplate = varargin{j}.MeanSpike.ms;            else                DATA.TriggerTemplate = DATA.StdTemplate(1,:);            end        else            DATA.TriggerTemplate = varargin{j};        end    elseif strncmp(varargin{j},'threshold',3)        if isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        else%            fprintf('ERRROR - Input argument ''thr'' needs a value\n');        end        DATA.trigdt = -1; %foce to be 0    elseif strncmp(varargin{j},'verbose',4)        verbose = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'vpts',3)        DATA.plottype =2;    elseif strncmp(varargin{j},'watch',3)        DATA.watcharg{1} = 'front';        DATA.watchplots = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'winfront',4)        FiguresToFront(DATA.tag);    elseif strncmp(varargin{j},'nowatch',5)        DATA.watcharg = {};        DATA.watchplots = 0;    elseif strncmp(varargin{j},'xcorr',3)        DATA.plot.xcorr = 1;    end    j = j+1;endif (ispk == 0 & reclassifyall) | strcmp(DATA.probe,'all')    DATA.probe = 1:DATA.nprobes;    ispk = DATA.probe;endif DATA.profiling    fprintf('Varargs  %.4f\n',mytoc(tt(1).time));endtt = AllV.TimeMark(tt,'After varargs',DATA.profiling);if DATA.trigdt == 3  && thsign ~=2    cprintf('blue','Energy Thresholds with voltage sign are Dangerous - See help\n');endif isfield(Vall,'V')    if isfield(Vall,'t')  && abs(length(Vall.t) - size(Vall.V,2)) > 1        PrintMsg(DATA.logfid,sprintf('Error! Vall length (%d) does not match t (%d)',size(Vall.V,2),length(Vall.t)));        res.err ='time length mismatch';        return;    end    if isfield(Vall,'errmsg')        for j = 1:length(Vall.errmsg)            DATA = AllV.AddErr(DATA,Vall.errmsg{j});        end    endendif isfield(Vall,'meangain')    DATA.meanvdata.meangain = Vall.meangain;endif verbose > 1    fprintf('%s Args processed at %s\n',AllV.IDStr(DATA),datestr(now,'HH:MM:SS'));endif forcecluster == 1    DATA.cluster.src.probe = DATA.cluster.probe;    DATA.cluster.src.exptno = DATA.cluster.exptno;    DATA.cluster.src.ctime = DATA.cluster.ctime;elseif forcecluster == 2    X = get(DATA.toplevel,'UserData');    DATA.cluster = X.cluster;    DATA.cluster.auto = 0;    X = [];endif isempty(DATA.fullvname) && isfield(Vall,'loadname')    DATA.fullvname = Vall.loadname;end%want this after processing varargin so that can do autocutallif autocutall    if length(forcedrive) > 2        Vall.name = regexprep(Vall.name,'[A-Z]:/Spike2/data',forcedrive);    end    if DATA.interactive >= 0        F = AllV.SetFigure(DATA.tag.top, DATA);        DATA.toplevel = F;        set(DATA.toplevel,'UserData',DATA)    else        F = 0;    end    if isempty(ispk) || sum(ispk == 0)        ispk = 1:size(Vall.V,1);    endid = setdiff(1:length(varargin),autocutarg);res = AllV.AutoCutAll(ispk,  F, Vall, DATA, varargin(id));res.toplevel = F;res.logfid = DATA.logfid;return;endif isfield(DATA,'Expt') && GetExptNumber(DATA.Expt) ~= floor(Vall.exptno)    cprintf('red','Using Wrong Expt struct\n');endif reclassifyall == 2    args = {};        DataClusters = AllV.LoadDataClusters(DATA);        DATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);        [DATA, ClusterDetails] = AllV.LoadClusterDetails(DATA,'orauto');        for j = 1:length(ispk)            if length(DataClusters) >= ispk(j)                [needc, reason] = AllV.NeedToQuantify(DataClusters{ispk(j)},DATA.fullvname, ClusterDetails{ispk(j)});                        if needc                fprintf('Reclassifying E%d P%d beacuse %s\n',DATA.exptno,ispk(j),reason);                try                res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify',args{:});                catch ME                    cprintf('errors','AllVPCs ERROR!!! %s\n',ME.message);                    res{j}.errstate = ME;                    res{j}.err = ME.message;                    t = mygetCurrentTask();                    res{j}.workerid = t.ID;                    res{j}.errstate = ME;                end                                res{j}.reason = reason;            end            res{j}.needed = needc;            res{j}.exptno = DATA.exptno;            res{j}.probes = ispk(j);            end        end        return;endif refineall && parallel    if userefcluster == 1 && isfield(DATA,'RefClusters')        UseClusters = DATA.RefClusters;    else        UseClusters = AllV.LoadDataClusters(DATA);    end    ts = now;        passonargs{end+1} = 'nolog';        passonargs{end+1} = 'noninteractive';        for j = 1:length(ispk)            p = ispk(j);            [res, X{j}, Y{j}] =  AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reapply',UseClusters{p},'refine', DATA.autorefine,'savespikesonly');        end        for j = 1:length(ispk)                Clusters{ispk(j)} = X{j};                ClusterDetails{ispk(j)} = Y{j};        end        name = AllV.ClusterFile(DATA.name,DATA);        fprintf('Took %.2f. Saving Clusters to %s\n',mytoc(ts),name)        save(name,'-v7.3','Clusters','FullVData');        save(AllV.ClusterFile(DATA.name,DATA,'details'),'-v7.3','ClusterDetails','FullVData');        res.Clusters = Clusters;        return;        elseif reclassifyall || refineall    args = {};    if userefcluster == 1 && isfield(DATA,'RefClusters')        UseClusters = DATA.RefClusters;    end    if refineall && isempty(UseClusters)        UseClusters = AllV.LoadDataClusters(DATA);    end%if doing a reclassifyall and savespikes, make a backup of the Details        if saveclusters        BackupFile(AllV.ClusterFile(DATA.name,DATA,'details'),'copy','print');    end    if parallel %NOT a good idea if saving spikes/Clusters. Needs more thought        parfor j = 1:length(ispk)            res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify','noninteractive');        end    else    for j = 1:length(ispk)        try        if refineall%in this loop, want to force p to == ispk(j) regardless of Vall%if its differente, want to force loading of new V when AllV.AllVPcs is called            if size(Vall.V,1) ==1 && ispk(j) ~= Vall.chspk                p = ispk(j);            else                p = ispk(j);            end            if isfield(UseClusters{p},'space')            res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reapply',UseClusters{p},'refine', DATA.autorefine);            res{j}.refinemode = DATA.refinemode;            end        elseif reclassifyall == 2            if Clusters{ispk(j)}.quick                res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify');            end                        else            res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify');        end        if fixerrs && res{j}.err == 1 && res{j}.auto == 1            AllV.AllVPcs(Vall,'savespikes');        end        catch ME            cprintf('errors','AllVPCs ERROR!! %s\n',ME.message);                    res{j}.err = ME.message;                    res{j}.errstate = ME;        end        drawnow;    end    end    for j = 1:length(ispk)        res{j}.exptno = Vall.exptno;        res{j}.probes = ispk(j);        if isfield(res{j},'cell')            safes(j) = res{j}.unsafetosave;            cells(j) = res{j}.cell;        end    end    badid = find(cells > 0 & safes ~= 0);    for j = badid(:)'        fprintf('Probe%d, Cell%d not safe %d %s\n',ispk(j),cells(j),safes(j),Code2String(safes(j),'unsafe'));    end    badid = find(cells == 0 & safes ~= 0);    for j = badid(:)'        fprintf('Probe%d, (MU) not safe %d %s\n',ispk(j),safes(j),Code2String(safes(j),'unsafe'));    end    if savedistancematrix        clname = AllV.ClusterFile(DATA.name, DATA, 'DistanceMatrix');        for j = 1:length(res)            if isfield(res{j},'DistanceMatrix')                DistanceMatrix{j} = rmfields(res{j}.DistanceMatrix,'cid');            else                DistanceMatrix{j} = {};                fprintf('E%dP%d Missing Distance Matrix\n',DATA.exptno,j);            end        end        fprintf('Saving Distance Matrices to %s\n',clname);        try        save(clname,'DistanceMatrix');        catch ME            cprintf('errors','Error writing %s\n',clname);            res{1}.errstate = ME;        end    end    return;endif ~isempty(vt) && ispk(1) == 0 %Called with current figure, just to set a variable    set(DATA.toplevel,'UserData',DATA);    return;endif DATA.showerrs        warning('on','stats:gmdistribution:FailedToConverge');        warning('on','stats:gmdistribution:MaxIterations');else        warning('off','stats:gmdistribution:FailedToConverge');        warning('off','stats:gmdistribution:MaxIterations');endif isfield(Vall,'Spikes') && needfullv == 0    if isempty(DataClusters)        [DataClusters, DATA.FullVData] = AllV.LoadDataClusters(DATA);    end    if isfield(DataClusters{1},'duration')        DATA.duration = DataClusters{1}.duration;    elseif isfield(DATA.Expt,'Trials');        DATA.duration = GetEval(DATA.Expt,'duration')./10000;    end    DATA.probelist = 1:DATA.allnprobes;    if strncmp(DATA.DataType,'Grid',4)        DATA.probelist = DATA.probe(1);        DATA.probe = 1;        ispk = 1;    endelse    if ~isfield(Vall,'V') && (isempty(DATA.fullvname) || reloadfullv);        DATA.fullvname = regexprep(DATA.name,'(Expt[0-9]*).*','$1FullV.mat');        if DATA.interactive < 0            Vall = LoadFullV(DATA.fullvname,convertarg{:});        else            h = waitbar(0.5,sprintf('Loading %s',DATA.fullvname));            Vall = LoadFullV(DATA.fullvname,convertarg{:});            delete(h);        end        fprintf('Load took %.2f sec\n',Vall.loadtime);    end    [DATA, Vall, ispk, newdata] = AllV.SetupVall(DATA, Vall, ispk, newdata);    vt = Vall.t;    if ~exist('chspk','var') %can happen switching spikes -> fullv        chspk = 1:size(Vall.V,2);    endendif length(ispk) > 4 && ~ autocutall    AllV.SetFigure(DATA.tag.top,DATA);    args = {};    clname = AllV.ClusterFile(DATA.name,DATA);    if exist(clname,'file')        load(clname);        if calcclscores            args = {args{:},'Clusterscores',Clusters};        end    end    [nr,nc] = Nsubplots(length(ispk));    for j = 1:length(ispk)        res{j} = AllV.AllVPcs(Vall, varargin{:},'tchan',ispk(j),'noplot',args{:});        if thsign == 2            res{j}.pres = AllV.AllVPcs(Vall, varargin{:},'tchan',ispk(j),'th+','noplot',args{:});        end        AllV.SetFigure(DATA.tag.top,DATA);        subplot(nr,nc,j);        id = [];        if DATA.interactive > 0 && isfield(res{j},'id')        AllV.PlotPCs(res{j}.pcs,1,2,DATA.clplot,res{j}.id,DATA.colors);        if DATA.showdipvals        title(sprintf('%.1f dp%.1f,%.1f',max(res{j}.dipvals)*100,res{j}.dp,res{j}.edp));        end        drawnow;        end    end    if calcclscores        hold off;        for k =1:size(res{1}.Clusterscores,1)            for j = 1:length(res)                scores(k,j,1:size(res{j}.Clusterscores,2)) = smooth(res{j}.Clusterscores(k,:),50);            end        subplot(nr,nc,k);        imagesc(squeeze(scores(k,:,:)));        end    end    if isfield(res,'dp') && DATA.interactive > 0    x = cat(1,res{:});    AllV.SetFigure('Dprimes');    hold off;    plot([x.dp]);    hold on;    plot([x.edp],'r');    if isfield(x,'pres')        p = cat(1,x.pres);        plot([x.dp],'o-');        plot([x.edp],'ro-');    end    end    return;end%Here is where the figure is created in a new callt = mygetCurrentTask();fprintf('Worker %d Calling AllV.SetFigure (%d)',t.ID,DATA.interactive);[F, isnew] = AllV.SetFigure(DATA.tag.top,DATA);fprintf('Worker %d Got AllV.SetFigure (%d)',t.ID,F);DATA.toplevel = F;if ~isempty(Expts)    DATA = AllV.mysetappdata(DATA,'Expts',Expts);endif isnew    if isempty(DATA.configfile)        DATA = ReadConfig(DATA,DATA.defaultconfig,'print','nochoose');        if DATA.options.UseLastConfig            fname = strrep(DATA.defaultconfig,'.config','last.config');            DATA = ReadConfig(DATA,fname,'print','nochoose');        end    end    if isempty(DATA.layoutfile)        DATA.layoutfile = DATA.defaultlayout;        if DATA.options.UseLastLayout            DATA.layoutfile = strrep(DATA.defaultlayout,'.layout','last.layout');        end        AllV.ApplyLayout(DATA,'print');    end    if isfield(DATA,'PopupWindowData') && ~isempty(DATA.PopupWindowData)        setappdata(DATA.toplevel,'PopupWindowData',DATA.PopupWindowData);    end        endres.toplevel = F;tt = AllV.TimeMark(tt, 'Laid Out ', DATA.profiling);p = AllV.ProbeNumber(DATA);if newdata %things to reset if its a new file, OR just a new probe    DATA.usegmcid = 0;         DATA.probe = ispk;        AllV.SetTrialList(DATA);        if isfield(DATA,'toplevel')        for f = {'AllCSD' 'AllVoltages'} %can clog up memory        if isappdata(DATA.toplevel,f{1})            rmappdata(DATA.toplevel,f{1});        end        end        end        if newdata == 1 || ~isfield(DATA,'CellList');            DATA = AllV.LoadCellFile(DATA);            AllV.AddCellMenu(DATA);            DATA = AllV.LoadComments(DATA);        end        if DATA.auto.uselastcluster && length(DATA.LastClusters) >= DATA.probe(1)            DATA.cluster = DATA.LastClusters{DATA.probe(1)};            forcecluster = 1;        endendDATA.idstr = AllV.IDStr(DATA);cname = AllV.ClusterFile(DATA.name,'clusterlog',DATA);cname = strrep(cname,'ClusterLog',sprintf('ClusterLogExpt%d',DATA.exptno));if isfield(DATA,'logname') && ~strcmp(DATA.logname,cname) && DATA.logfid > 0  try      fclose(DATA.logfid);  catch      fprintf('ERROR closing logfid\n');  end    DATA.logfid = -1;endif DATA.logfid < 0 && DATA.nolog == 0    DATA.logfid = fopen(cname,'a');    DATA.logname = cname;    if verbose    disp(sprintf('Opened Log %s id=%d\n',cname,DATA.logfid));    endelseif verbose    disp(sprintf('No Log set (%s). logfid is %d',AllV.IDStr(DATA),DATA.logfid));endres.logfid = DATA.logfid;if DATA.logfid > 0    try        fprintf(DATA.logfid,'Ex%d (fid%d) Args %s\r\n',Vall.exptno,DATA.logfid,callstring);    catch        fprintf('Invalid handle %d. Opening %s again\n',DATA.logfid,cname);        DATA.logfid = fopen(cname,'a');    endendif newdata > 0  && isfield(DATA,'name');    DATA.msg = {};    DATA.plotspk.subtrigger = 0;    DATA.plotspk.submean = 0;    DATA.plotspk.submax = 0;    DATA.plotspk.submin = 0;    DATA.plotspk.oneprobe = 0;    DATA.plotspk.includeprepost = 0;    DATA.currenttrial = 1;    DATA.plotspk.muscale = muscale;    if newdata == 1 %%Keep DataClusters if newdata == 2 - new probe        DataClusters = {};        DATA.clst = [];        tt = AllV.TimeMark(tt, 'Loading Clusters ', DATA.profiling);        DataClusters = AllV.LoadDataClusters(DATA);    endelseif newdata == 2 else    DataClusters = {};endtt = AllV.TimeMark(tt, 'Loaded Clusters ', DATA.profiling);if newdata || autocutone;    DATA.cluster.neednewtemplate = 1;    if spkrate && setnspk == 0       setnspk = round(DATA.duration .* spkrate);    else        spkrate = setnspk./DATA.duration;    endendif recluster && (length(DataClusters) < p || ~isfield(DataClusters{p},'space')) && forcecluster == 0    if length(DATA.RefClusters) >= DATA.probe(1)        userefcluster = 1;        fprintf('DataClusters is empty using refcluster\n', DATA.probelist(DATA.probe(1)));    else            DATA = AllV.AddErr(DATA,'Cant Apply  Cluster for %d - DataClusters only %d elements\n', DATA.probelist(DATA.probe(1)),length(DataClusters));    recluster = 0; %just do simple cut if no cluster defined    savespikes = 0;    if DATA.auto.quickcut        autocutone = 2;    end    endendif ~exist('DataClusters','var')    DataClusters = {};endif forcecluster && isempty(DataClusters)endDATA.userefcluster = userefcluster;DATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);if newdata    AllV.MakeProbeMenu(DATA);endif DATA.triggerset > 0    clist = ClusterDef(DataClusters{p});    if isfield(DataClusters{p},'trigset')        tlist = ClusterDef(DataClusters{p}.trigset{1});    else        tlist = [];    end    if ~ismember(DATA.currentcluster,tlist')        tlist = setdiff(1:10,clist);        DATA.currentcluster = tlist(1);    endendif recluster%    DATA.currentcluster = 1;    p = AllV.ProbeNumber(DATA);    DATA.recluster = recluster;    if userefcluster == 3        LastClusters = AllV.mygetappdata(DATA,'LastClusters');    end        if isfield(DATA,'cluster') && isfield(DATA.cluster,'auto') && DATA.cluster.auto ==1        wasauto = 1;    elseif length(DataClusters) < DATA.probelist(DATA.probe(1))        wasauto = 2;    elseif isfield(DataClusters{p},'auto') &&  DataClusters{p}.auto == 1        wasauto = 1;    else        wasauto = 0;    end    if recluster == 4 %load event times, dont calc trigger        cfile = AllV.ClusterFile(DATA.name,DATA,'details');    end    if forcecluster == 0 %%used saved cluster                if (userefcluster == 1 || wasauto) && length(DATA.RefClusters) >= DATA.probelist(DATA.probe(1))            DATA.cluster = DATA.RefClusters{DATA.probelist(DATA.probe(1))};            DATA.cluster.manual = 4;            DATA.userefcluster = 1;            fprintf('Using RefClusters (set %d) for probe %d\n',DATA.refcut.currentset, p)        elseif userefcluster == 3 && length(LastClusters) >= DATA.probelist(DATA.probe(1))            DATA.cluster = LastClusters{DATA.probelist(DATA.probe(1))};            DATA.cluster.manual = 4;            DATA.userefcluster = 3;            DATA.refclusterexpt = DATA.cluster.exptno;            fprintf('Using Clusters from Expt %d\n',DATA.cluster.exptno);            DATA.cluster.exptno = DATA.exptno;        else                        if userefcluster == 2               DATA =  AllV.AddErr(DATA, '-color','blue','%s:Not Applying RefCluster Becuase Existing cut is manual',AllV.IDStr(DATA));            end            C = DataClusters{DATA.probelist(DATA.probe(1))};            if DATA.triggerset > 0 && isfield(C,'trigset') && length(C.trigset) >= DATA.triggerset                DATA.cluster = C.trigset{DATA.triggerset};            else                DATA.cluster = C;            end        end        DATA.cluster.errs = {};  %Don't inherit errors from previous time        if recluster == 2 && isfield(DATA.cluster,'chspk') %force PC chans            chspk = DATA.cluster.chspk;            DATA.chspk = chspk;        end        if ~isfield(DATA.cluster,'minvar')            DATA.cluster.minvar = 0;        end        %        if (recluster == 2 || (newdata == 2) && isfield(DATA.cluster,'Trigger');% why was this set for newdata ==2? Forces old trigger..        if recluster == 2 && isfield(DATA.cluster,'Trigger')            th = DATA.cluster.Trigger;        end    elseif DATA.triggerset > 0        C = DATA.cluster;        if isfield(C,'trigset') && length(C.trigset) >= DATA.triggerset            DATA.cluster = C.trigset{DATA.triggerset};        end    end    DATA.cluster = FixCluster(DATA.cluster, DATA);    if ~isfield(DATA.cluster,'space')        fprintf('Cant recluster  - old cluster is empty\n');        return;    end%if applying an old boundary to new data, use the old trigger only if none%was set   if recluster ==1 && th == 0       th = DATA.cluster.Trigger;   end   if isnan(th)       th = 0;   end    tryall = 0;    if isempty(spts)        spts = DATA.cluster.spts;    end%only set CSd/DVDY for PC calculation if the cluster is in that space%otherwise this just wastes time%check - could go wrong if cluster 2 is cut in PC space    if isfield(DATA.cluster,'csd') && ismember(DATA.cluster.space(1), [1 6])        DATA.csd = DATA.cluster.csd;        DATA.dvdt = DATA.cluster.dvdt;    end%if there is smoothing on the command line, it supercedes the save cluster    if isfield(DATA.cluster,'tsmooth') && smoothsd == 0        smoothsd = DATA.cluster.tsmooth;    end    if isfield(DATA.cluster,'trigdt') && DATA.trigdt == 0        DATA.trigdt = DATA.cluster.trigdt;    end    if DATA.trigdt < 0        DATA.trigdt = 0;    end    if isfield(DATA.cluster,'triggerchan') && length(DATA.cluster.triggerchan) > 1        ispk = DATA.cluster.triggerchan;        if isfield(DATA.cluster,'triggertype')            id = strmatch(DATA.cluster.triggertype,{'sum' 'or' 'sumandreplace'});            if ismember(id,[1 3])                addch = 1;            elseif isempty(id) && length(ispk) > 1                addch = 1;            end        else            addch = 1;        end    end    if ismember(recluster, [1 2])         if DATA.cluster.minenergy > 0        th = DATA.cluster.Trigger;        minenergy = DATA.cluster.minenergy;        minvar = DATA.cluster.minvar;        end        if isfield(DATA.cluster,'vsmps')            DATA.vsmps = DATA.cluster.vsmps;        end    end    if recluster == 2        DATA.clst = [];    end    if ~isfield(DATA.cluster,'excludetrialids')        DATA.cluster.excludetrialids = [];    endelse    DATA.recluster = 0;    if setnspk == 0        setnspk = round(spkrate .* DATA.duration);    endendif ~isfield(DATA,'cluster') || ~ClusterIsSet(DATA.cluster, DATA.currentcluster)    DATA.currentcluster = 1;endif ~isfield(DATA.Expt,'Header')    DATA.cluster.exptreadmethod = -1;elseif isfield(DATA.Expt.Header,'ReadMethod')    DATA.cluster.exptreadmethod = DATA.Expt.Header.ReadMethod;else    DATA.cluster.exptreadmethod = 0;endtt = AllV.TimeMark(tt,'Start Trig', DATA.profiling);DATA.triggertype = 'one';if length(ispk) > 1 && addch    DATA.triggertype = 'sum';endp = AllV.ProbeNumber(DATA);DATA.currentprobe = p;if forcetrigger    ispk = forcetrigger;endif ~isfield(Vall,'Spikes')    if verbose >1        fprintf('Making Trig reference for E%dP%d %s\n',DATA.exptno,AllV.ProbeNumber(DATA),datestr(now,'HHMM:ss'));    end    if length(ispk)  > 1 && addch        rV = mean(double(Vall.V(ispk,:)));        if isinteger(Vall.V)            rV = rV .* Vall.intscale(1)./Vall.intscale(2);        end        DATA.triggertype = 'sum';        if addch == 2            DATA.triggertype = 'sumandreplace';            Vall.V(ispk(1),:) = rV;        end    else        if length(ispk) > 1            DATA.triggertype = 'or';        end        if isinteger(Vall.V)            rV = double(Vall.V(ispk,:))  .* double(Vall.intscale(1))./Vall.intscale(2);        else            rV = Vall.V(ispk,:);        end    end        if length(smoothsd) > 1 %% explose effect of smoothing on the        if verbose >1            %     fprintf('Smoothing  %s\n',datestr(now));        end        colors = mycolors;        AllV.SetFigure(DATA.tag.vhist, DATA);        hold off;        for j = 1:length(smoothsd)            smv = smooth(Vall.V(ispk,:),smoothsd(j),'gauss');            sgn = diff(sign(diff(smv,1,2)),1,2);            id = find(sgn > 0 & V(ispk,2:end-1) < 0);            [a,b] = smhist(Vall.V(ispk,id+1));            plot(b,a,'color',colors{j});            res.skew(j) = moment(Vall.V(ispk,id+1),3);            hold on;        end        return;    elseif smoothsd > 0.1        smv = smooth(rV,smoothsd,'gauss');    else        smoothsd = 0;        smv = rV;    end    clear rV;    if isinteger(smv)        smv = double(smv) .* Vall.intscale(1)./Vall.intscale(2);    end    if subtractadj && ispk > 1 && ispk <= DATA.nprobes        cp = [ispk-1 ispk+1];        subv = mean(Vall.V(cp,:)) .* Vall.intscale(1)./Vall.intscale(2);        smv = smv - subv;        Vall.V = double(Vall.V) .* Vall.intscale(1)./Vall.intscale(2);;        Vall.V(ispk,:) = Vall.V(ispk,:) - subv;    end    if DATA.trigdt        if DATA.trigdt == 3 %10pt moving average of dvdt = energy            smv = smooth(diff(smv).^2,3,'gauss');        elseif ismember(DATA.trigdt,[4 5]) %convolve with template            if recluster && isfield(DATA.cluster,'TriggerTemplate')                DATA.TriggerTemplate = DATA.cluster.TriggerTemplate;            end            if ~isfield(DATA,'TriggerTemplate')                DATA.TriggerTemplate = DATA.cluster.MeanSpike.ms(p,:);            end            if size(DATA.TriggerTemplate,1) > length(ispk)                for j = 1:length(ispk)                    x(j,:) = conv(double(Vall.V(ispk(1),:)),fliplr(DATA.TriggerTemplate(ispk(j),:)));                end                x = mean(x,1);                DATA.TriggerTemplate = DATA.TriggerTemplate(ispk,:);            elseif length(ispk)  > 1                for j = 1:length(ispk)                    x(j,:) = conv(Vall.V(ispk(j),:),fliplr(DATA.TriggerTemplate(j,:)));                end                x = mean(x,1);            else                if DATA.trigdt == 4                    x = conv(smv,fliplr(DATA.TriggerTemplate));                elseif DATA.trigdt == 5                    x = conv(diff(smv),diff(fliplr(DATA.TriggerTemplate)));                end            end            np = round(length(DATA.TriggerTemplate)/2);            if mod(length(DATA.TriggerTemplate),2) == 1                smv = x(np-1:end-np);            else                smv = x(np:end-np);            end        elseif DATA.trigdt == 2 %% acceleration            smv = diff(smv,2);        else            smv = diff(smv);        end    end    DATA.triggersmooth = smoothsd;    DATA.triggerchan = ispk;    DATA.cluster.trigparams.preperiod = DATA.preperiod;    DATA.cluster.trigparams.postperiod = DATA.postperiod;        if smoothv && is        for j = 1:size(Vall.V,1)            Vall.V(j,:) = smooth(double(Vall.V(j,:)),smoothv,'gauss');        end    end            tt = AllV.TimeMark(tt,'Start Trig',DATA.profiling);    if verbose > 1        fprintf('%s %s %s\n',AllV.IDStr(DATA),tt(end).str,datestr(now,'HHMM:ss'));    end    DATA.nprobes = size(Vall.V,1);    if ~isfield(DATA,'cluster') || ~isfield(DATA.cluster,'version')        DATA.cluster.version = DATA.version;    end    F = AllV.SetFigure(DATA.tag.top,DATA);    DATA.toplevel = F;    res.toplevel = F;        if DATA.interactive >= 0        set(F,'UserData',DATA);        DATA = AllV.mysetappdata(DATA,'Vall',Vall);        if newdata            if exist('AutoClusters','var')                setappdata(DATA.toplevel,'AutoClusters',AutoClusters);            end        end    else        DATA = AllV.mysetappdata(DATA,'Vall',Vall);    end    %load trig times before thresholding current channel. Then set trig times    %for current channel to match new values after threshold    if gettrigtimes        if gettrigtimes == 2            [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,1:DATA.nprobes,'savexy');        else            [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,1:DATA.nprobes);        end        if recluster == 2            DATA.lastxy = DATA.xy{1};            DATA.oldtrigtimes = Vall.t(DATA.trigtimes{DATA.probe(1)});            DATA.oldclst = DATA.clst;            AllV.PlotXY(DATA.xy{1},DATA.clst);            th = DATA.cluster.Trigger;        end    elseif recluster == 2        if userefcluster ~= 1            [DATA, DataClusters, oldxyloaded] = AllV.LoadTrigTimes(DATA,[]);            if forcecluster == 0 && isfield(DataClusters{p},'Evec')                DATA.cluster.Evec = DataClusters{p}.Evec;            end            DATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);        end        if oldxyloaded && length(DATA.trigtimes) >= DATA.probe(1)            AllV.SetFigure(DATA.tag.oldxy, DATA);            DATA.lastxy = DATA.xy{1};            if DATA.trigtimes{DATA.probe(1)}(end) > Vall.t(end)                DATA.oldtrigtimes = DATA.trigtimes{DATA.probe(1)};                % can't use followig line,since trigtimes is not int. What problem                % is this meant to solve?                %            DATA.oldtrigtimes = Vall.t(DATA.trigtimes{DATA.probe(1)});            else                DATA.oldtrigtimes = DATA.trigtimes{DATA.probe(1)};            end            [DATA, ClusterDetails] = AllV.LoadClusterDetails(DATA);            DATA.oldclst = ClusterDetails{p}.clst;            if DATA.interactive > 0                AllV.PlotXY(DATA.xy{1},DATA.clst);            end        elseif DATA.interactive > 0            %faster to just use recluster 1. Good if the was called from GUI            % But need 2 if doing batch reclassify and want quantification            recluster = 1;        end        th = DATA.cluster.Trigger;    end        if isempty(spts)        spts = [-12:27];    end        if recluster == 4  %use trig times from saved cluster        D = [];        DATA.xy = {[]}; %in case its not set in AllV.LoadTrigTimes        p = AllV.ProbeNumber(DATA);        DATA.trigcheck(p) = 1;        [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,p);        ClusterDetails = AllV.mygetappdata(DATA,'ClusterDetails');        if length(ClusterDetails) >= p && isfield(ClusterDetails{p},'triggerV')            if length(ClusterDetails{p}.triggerV) == DataClusters{p}.nspks                D.triggerV = ClusterDetails{p}.triggerV;            end        end        DATA.Trigger = DATA.cluster.Trigger;        DATA.autoth = 1;        DATA.spts = DATA.cluster.spts;        DATA.setnspk = DATA.cluster.nspks;        DATA.gmcid = [];        if ~isempty(forceeventlist)            %        id = find(ismember(Vall.t,forceeventlist)); %if list is times            if isfield(forceeventlist,'tid')                id = forceeventlist.tid; %if list is index # in Vall.V            elseif isfield(forceeventlist,'spk_inds')                id = forceeventlist.spk_inds; %if list is index # in Vall.V            elseif isnumeric(forceeventlist)                id = forceeventlist; %if list is index # in Vall.V            end            if isfield(forceeventlist,'clst')                DATA.clst = 1+forceeventlist.clst;            elseif isfield(forceeventlist,'spike_clusts')                DATA.clst = forceeventlist.spike_clusts;            else                DATA.clst = ones(1,length(id));            end        else            id = DATA.trigtimes{p};        end    else        %in ver 1.1 and before, some triggers (trigdt) were save to clsueter without        %converting to double        if (th > max(smv) || th < min(smv)) && DATA.cluster.version <= 1.1             a = th;            if isfield(Vall,'intscale')                th = th .* Vall.intscale(1)./Vall.intscale(2);                DATA = AllV.AddErr(DATA,'Converting Trigger to double %.0f -> %.3f',a, th);            end        end        DATA.Trigger = th;        DATA.autoth = 1;        DATA.spts = spts;        DATA.thsign = thsign;        if setnspk > 0            DATA.setnspk = setnspk;        elseif DATA.spkrate > 0            DATA.setnspk = 0;        end        if recluster == 1 && matcheventcounts            DATA.Trigger = 0;            DATA.thsign = (1+sign(th))/2;            if isfield(DATA.cluster,'eventrate')                DATA.setnspk = round(DATA.cluster.eventrate .* length(smv));            else                DATA.setnspk = DATA.cluster.nspks;            end        end                        [id,  DATA.Trigger, D] = AllV.TriggerV(DATA, smv);                if length(id) > 1e6            if DATA.interactive  < 0                if ~isfield(DATA,'chspk')                    DATA.chspk = 0;                end                fprintf('E%dP%d> 1 million events. (Trigger %f) Exiting AllVPcs\n',DATA.exptno,DATA.chspk(1),DATA.Trigger);                return;            end            yn =  questdlg('>1Million events. Proceed?','trigger','Yes','No','No');            if strcmpi(yn,'no')                return;            end        end        DATA.cluster.eventrate = D.nevents./length(smv);        DATA.cluster.trigparams = CopyFields(DATA.cluster.trigparams,D,{'skew' 'roc' 'qq'});    end    tt = AllV.TimeMark(tt,'End Trig', DATA.profiling);    if spkrate > 0        DATA.spkrate = spkrate;    else        DATA.spkrate = DATA.cluster.eventrate./Vall.samper;    end        clear sgn;    %remove any spikes at very beginning or end where there isn't enough    %data to include the whole spike    if size(id,1) > 1        id = id';    end        if verbose > 0 fprintf('E%dP%d %dEvents (%.1fHz)\n',DATA.exptno,AllV.ProbeNumber(DATA),length(id),length(id)./DATA.duration); end    ignoreid = [];    missedtrials = [];    if isfield(DATA, 'Expt') && isfield(DATA.Expt,'Trials') && DATA.usetrials        if isfield(DATA.Expt.Header,'expname')            res.expname = DATA.Expt.Header.expname;        end        iid = [];        piid = [];        if isfield(DATA.cluster,'excludetrialids')            xct = DATA.cluster.excludetrialids;        else            xct = [];        end        missedtrials = [];        blkend = (Vall.blkstart + Vall.blklen.*Vall.samper).*10000;        blkstart = Vall.blkstart .* 10000;                for j = 1:length(DATA.Expt.Trials)            tid = find(blkstart < DATA.Expt.Trials(j).Start(1) & blkend > DATA.Expt.Trials(j).End(end));            if isempty(tid)                missedtrials = [missedtrials DATA.Expt.Trials(j).id];            end            oid = find(vt(id) > DATA.Expt.Trials(j).Start(1)./10000 - DATA.preperiod & ...                vt(id) < DATA.Expt.Trials(j).End(end)/10000 + DATA.postperiod);            pid = find(vt(id(oid)) > DATA.Expt.Trials(j).End(end)/10000); %in postperiod            iid = [iid oid];            piid = [piid oid(pid)];        end        ntrials = j;        uid = unique(iid);        if length(DATA.clst) == length(id)            DATA.clst = DATA.clst(uid);            if recluster == 4 && length(DATA.xy{1}) >= max(uid)                DATA.xy{1} = DATA.xy{1}(uid,:);            end        end        ignoreid = setdiff(id,id(uid));        id = id(uid);        [a, pid] = ismember(piid,uid);        DATA.postevents = pid; %index to event index, not FullV times        if isfield(DATA.Expt.Header,'trialdur')            DATA.duration = (DATA.Expt.Header.trialdur+ntrials*(DATA.preperiod+DATA.postperiod))./10000;        else            disp(sprintf('Header Missing trialdur E%dP%d\n',DATA.exptno,DATA.probe(1)));            DATA.duration = ntrials * (2+DATA.preperiod+DATA.postperiod);        end        setnspk = DATA.duration * spkrate;    else        DATA.postevents = [];    end    DATA.missedtrials = missedtrials;    if length(missedtrials)        DATA = AllV.AddErr(DATA,'Missing %d/%dTrials%s\n',length(missedtrials),ntrials,sprintf(' %d',missedtrials));    end        if maxrate > 0        maxspikeset = DATA.duration .* maxrate;    end            if isempty(id)        DATA = AllV.AddErr(DATA,'No Spikes in Expt\n');        res.t = [];        res.Trigger = DATA.Trigger;        return;    else        fprintf('%d events in Trials',length(id));    end    if isfield(D,'trigid') && length(D.trigid) >= max(uid)        DATA.rV = smv(:,D.trigid(uid));    elseif isfield(D,'triggerV') %loaded from file        DATA.rV = D.triggerV;    else        DATA.rV = smv(:,id);    end    DATA.trigtimes{DATA.probe(1)} = id; %want real trig times    DATA.trigcheck(DATA.probe(1)) = 1;    res.t = vt(id);    if DATA.plotrv        allid = repmat(id,length(spts),1) + repmat(spts',1,length(id));        AllrV = smv(allid);    end    if checklast == 2 || keeptrigger        DATA = AllV.mysetappdata(DATA,'TriggerV',smv);    end        clear smv;else % end  of processing FullV insteatd of Spike Snippets    DATA.posteevents = [];end % end  of processing FullV insteatd of Spike SnippetsDATA.nvpts = length(spts);res.toplevel = DATA.toplevel;res.th = th;allid = [];if ~isempty(DATA.allints)    DATA = AllV.mysetappdata(DATA, 'AllInts',DATA.allints);    DATA.allints = [];endres.maxspksused = 0;if isfield(Vall,'Spikes')    tt = AllV.TimeMark(tt,'Convert Spikes',DATA.profiling);    S = Vall.Spikes;    if isfield(S,'xchans')        AllVoltages = zeros([DATA.allnprobes size(S.values,2) size(S.values,1)]);        AllVoltages(DATA.probe(1),:,:) = double(S.values') .* S.maxv./S.maxint;        chspk = DataClusters{DATA.probe(1)}.chspk;        AllVoltages(S.xchans,:,:)= double(S.xvalues) .* S.xmaxv./S.maxint;        newchspk = sort([p S.xchans]);        DATA.nprobes = length(newchspk);        if sum(~ismember(chspk,newchspk)) %don't have channels            chspk = newchspk;            fprintf('Dont have all spike channels for%s\n',sprintf(' %d',chspk));        end    else        AllVoltages(DATA.probe(1),:,:) = double(S.values') .* S.maxv./S.maxint;        chspk = DATA.probe(1); %1 for single Fullv files    end    res.t = S.times(:)'./10000; %column vector        spts = DataClusters{p}.spts;    tpt = find(spts ==0);    DATA.spts = spts;    [DATA, Cd] = AllV.LoadClusterDetails(DATA,'orauto');    tt = AllV.TimeMark(tt,'Convert Trigger',DATA.profiling);    if isfield(S,'TriggerV') %trigger stored with spikes takes precednce        DATA.rV = S.TriggerV;    elseif isfield(Cd{p},'triggerV')        DATA.rV = Cd{p}.triggerV;    else        DATA.rV = squeeze(mean(AllVoltages(DataClusters{p}.triggerchan,tpt,:),1));    end    if length(DATA.rV) > size(AllVoltages,3)        DATA = AllV.AddErr(DATA,'Details lengts do not match');        DATA.rV = DATA.rV(1:size(AllVoltages,3)); %force match    end    DATA = CopyFields(DATA, DataClusters{p},{'Trigger'});%    DATA.Trigger = DataClusters{p}.Trigger;    DATA.triggersmooth = DataClusters{p}.tsmooth;    DATA.triggerchan = DataClusters{p}.triggerchan;    DATA.missedtrials = DataClusters{p}.missingtrials;    DATA.chspk = 1:DATA.nprobes;    if ~isfield(DATA,'cluster') || ~isfield(DATA.cluster,'version')        DATA.cluster.version = DATA.version;    end    if recluster == 2 %can;'t do reclassify with just spikes        recluster = 1;    end    tt = AllV.TimeMark(tt,'End Trigger',DATA.profiling);elseif minenergy    if verbose        fprintf('Applying min energy at %s\n',datestr(now,'HHMM:ss'));    end    allid = repmat(id,length(spts),1) + repmat(spts',1,length(id));    AllVoltages = reshape(Vall.V(ispk(1),allid),[size(allid)]);    if isinteger(AllVoltages)        AllVoltages = double(AllVoltages) .* Vall.intscale(1)/Vall.intscale(2);    end    clear allid;    allid = [];    energy = sqrt(squeeze(sum(diff(AllVoltages,1,1).^2)));    spkvar = std(AllVoltages);    clear AllVoltages;    ie = [];    adjustenergy = 0;   %if the user has set minenergy, don't mess with it. With autocutting seems like sometimes   %want to adjust minenergy, but not sure when. When it comes up, set   %adjustenergy    if length(energy) <= setnspk        ie = [1:length(energy)];    elseif adjustenergy        while length(ie) < setnspk            ie = find(energy > minenergy & spkvar > minvar);            minenergy = minenergy * 0.8;            minvar = minvar * 0.8;        end    else            ie = find(energy > minenergy & spkvar > minvar);    end       if  length(ie)  > maxspikeset        if th(1) < 0            prc = 100 * maxspikeset./length(ie);        else            prc = 100-(100 * maxspikeset./length(ie));        end        th = prctile(DATA.rV,prc);    end    while length(ie) > maxspksallowed         minenergy = minenergy * 1.1;        minvar = minvar * 1.1;        ie = find(energy > minenergy & spkvar > minvar);        res.maxspksused = length(ie);    end            DATA.rV = DATA.rV(ie);    clear energy;    clear spkvar;    clear AllVoltages;    [AllVoltages, DATA] = AllV.BuildAllV(DATA, id(ie), spts);    res.t = vt(id(ie));    [a,b] = ismember(DATA.postevents,ie);    DATA.postevents = b;    id = id(ie);    DATA.trigtimes{DATA.probe(1)} = id;else    [AllVoltages, DATA] = AllV.BuildAllV(DATA, id, spts);endDATA.nevents = size(AllVoltages,3);if DATA.Trigger(1) <0    res.xsd = std(DATA.rV(1,:));elseendtt = AllV.TimeMark(tt,'Created AllVoltages',DATA.profiling);res.spkrate = DATA.nevents./DATA.duration;if verbose > 0 fprintf('E%dP%d Built AllVoltages %d events (%.2f)\n',DATA.exptno,AllV.ProbeNumber(DATA),DATA.nevents,mytoc(tt(1).time)); endif ~isempty(addmean)    DATA.addmean = addmean;elseif isfield(DATA.cluster,'addmean')    DATA.addmean = DATA.cluster.addmean;elseif isfield(DATA.cluster,'version')    if DATA.cluster.version <= 1.10        DATA.addmean = 0; %default in ver 1.10    endend%addmean should be doen in Build AllV. Should%never use thisif isfield(Vall,'meanV') && ~isempty(allid)    if isfield(Vall,'meanV') && DATA.addmean%  slightly faster, but might cause memory swapping%        mV = shiftdim(repmat(Vall.meanV(allid),[1 1 24]),2);%        AllVoltages = AllVoltages+mV;        for j = 1:size(AllVoltages,1)            AllVoltages(j,:,:) = squeeze(AllVoltages(j,:,:)) + Vall.meanV(allid);        end    endelseif ~isfield(DATA,'meanV')     if size(AllVoltages,1) > 1        DATA.meanV = squeeze(mean(AllVoltages,1));        DATA.addmean = 1;    else        DATA.meanV = squeeze(mean(AllVoltages,1));        DATA.addmean = 1;    endenda = whos('Vall');DATA.fullvsize = AllV.memsize(Vall);y = max(max(abs(AllVoltages(DATA.probe(1),:,:))));DATA.voffset = [1:DATA.nprobes].*y;if isfield(DATA,'trueprobe')    if isfield(Vall,'chspk') && nprobepc >= 0 %not forced    chspk = Vall.chspk;    endendclear Vall;if ~isfield(DATA,'meanV')%    DATA.addmean = 0;end%reject artifacts where there is a large evvent int he mean%only do this if the mean has been added back in. Otherwise, there%shouldn't be the artifact!  Logic since 2012 when addmean = 0 was defaultif rejectbydiff    a = max(abs(diff(DATA.meanV)));    bid = find(a > rejectbydiff);elseif DATA.addmean && DATA.loadfromspikes == 0%With older grid files, mmean subtraction was not done. So the artifact%refjsetion was done on the mean of the channels own voltage.  %in some cases this was important - e.g. jbeG015 E15P2. So keep it     if recluster == 2 && DATA.cluster.version < 1.13  && length(DATA.ArrayConfig.Y) > 90        DATA.meanV = squeeze(mean(AllVoltages,1));    elseif recluster ==2 && size(AllVoltages,1) ==1 && ~isfield(DATA,'meanV')        DATA.meanV = squeeze(mean(AllVoltages,1));    end    allbid = [];    gid = 1:size(AllVoltages,3);    avar = sum(DATA.meanV(:,gid).^2);    bid = find(avar > prctile(avar,99) * 2);    while length(bid)        allbid = [allbid bid];        gid = setdiff(1:size(AllVoltages,3),allbid);        avar = std(DATA.meanV(:,gid));        avar = sum(DATA.meanV(:,gid).^2);        bid = find(avar > prctile(avar,99) * 2);        bid = gid(bid);    end    avar = sum(abs(diff(DATA.meanV(:,gid))));    bvar = smooth(avar,10);    bid = find(avar > prctile(avar,99) * 1.5);    while length(bid)        allbid = [allbid bid];        gid = setdiff(1:size(AllVoltages,3),allbid);        avar = sum(abs(diff(DATA.meanV(:,gid))));        bid = find(avar > prctile(avar,99) * 1.5);        bid = gid(bid);    end    bid = allbid;elseif size(AllVoltages,1) == 24%avar = squeeze(std(mean(AllVoltages(1:16,:,:))));%bvar = squeeze(std(mean(AllVoltages(17:24,:,:))));%[da, aid] = sort(avar);%[db, bid] = sort(avar);%avar and bvar are really completely correlated because the channels sum to 0%bid = find(avar > prctile(avar,99) * 2 & bvar > prctile(bvar,99) * 2);bid = [];else    bid = [];endclear avar;clear bvar;res.t = res.t(:)';  %force to a row vectorif length(bid)    DATA.artifacttimes = res.t(bid);    fprintf('%s Made AllVoltages  %d spikes. Removed %d suspicious events at %s,\n',AllV.IDStr(DATA),size(AllVoltages,3),length(bid),datestr(now,'HHMM:ss'));    if DATA.interactive >= 0    AllV.SetFigure(DATA.tag.vare,DATA, DATA.watcharg{:});    if DATA.nprobes == 24    hold off;    plot(squeeze(mean(AllVoltages(17:24,:,bid))));    hold on;    plot(squeeze(mean(AllVoltages(1:16,:,bid))));    else        plot(DATA.meanV(:,bid));    end    drawnow;    end    gid = setdiff(1:size(AllVoltages,3),bid);    [a,b] = ismember(DATA.postevents,gid);    DATA.postevents = b;    if length(DATA.clst) == size(AllVoltages,3)        DATA.clst = DATA.clst(gid);    end            AllVoltages = AllVoltages(:,:,gid);    DATA.meanV = DATA.meanV(:,gid);       res.t = res.t(gid);    if DATA.plotrv    AllrV = AllrV(:,gid);    end    DATA.rV = DATA.rV(gid);    nerr = nerr+1;    errs{nerr} = sprintf('Removed %d suspicous events, ',length(bid));    DATA.trigtimes{DATA.probe(1)} = DATA.trigtimes{DATA.probe(1)}(gid);    ignoreid = [ignoreid id(bid)];elseif verbose    fprintf('E%dP%d Made AllVoltages  %d spikes at %s (%.2f)\n',DATA.exptno,AllV.ProbeNumber(DATA),size(AllVoltages,3),datestr(now,'HHMM:ss'),mytoc(tt(1).time));endtt = AllV.TimeMark(tt,'Built AllVoltages',DATA.profiling);res.trigartifacts = length(bid);if DATA.plotrv && DATA.interactive >= 0    setappdata(DATA.toplevel,'AllrV',AllrV);    clear AllrV ;endclear allid;fullcov = 1;DATA.nevents = size(AllVoltages,3);res.spkrate = DATA.nevents./DATA.duration;if ~isfield(DATA,'meanV') %should really load meanV for Grids, but not done yet.    DATA = AllV.mysetappdata(DATA,'MeanV', zeros(size(AllVoltages,2),size(AllVoltages,3)));else    DATA = AllV.mysetappdata(DATA,'MeanV', DATA.meanV);endif isfield(DATA.cluster,'addmean')    DATA.addmean = DATA.cluster.addmean;endif recluster == 2  % 'reclassify' = compare with last also    if checklast && isfield(DATA,'oldtrigtimes')    [t, ida] = setdiff(DATA.oldtrigtimes,res.t);    if checklast == 2        spkfile = AllV.SpkFileName(DATA);        try          a = load(spkfile);          if isfield(a.Spikes,'maxv')              a.Spikes.values = double(a.Spikes.values) * a.Spikes.maxv./a.Spikes.maxint;          end          DATA.oldSpikes = a.Spikes;        catch            DATA = AllV.AddErr(DATA,'Error loading %s\n',spkfile);        end        goodid = [];        for j = 1:length(ida)            d = min(abs(res.t-DATA.oldtrigtimes(ida(j))));            if d < 0.0005                goodid = [ida(j) goodid];                baddiff(j) = 0;            else                baddiff(j) = 1;            end            tdiff(j) = d;        end        ida = setdiff(ida, goodid);        t = DATA.oldtrigtimes(ida);    end                n = length(ida); %number of old times not here    [a, ida] = ismember(t,vt);    ida = ida(ida > 0);    bid = find(~ismember(ida,ignoreid)); %missing and not actively removed    if isempty(ignoreid)        ignoreid = 0;    end    for j = 1:length(bid)        xid(1,j) = min(abs(id-ida(bid(j))));        xid(2,j) = min(abs(ignoreid-ida(bid(j))));    end    if length(bid)        nid = find(xid(1,:) >5 & xid(2,:) > 5);    else        nid = [];    end% reclustern(1) = #of old trig times not in new list% reclustern(2) = #of those that are not on the ignore list (ignoreid)% reclustern(4) = # of events in old trig times    DATA.reclustern = [n length(bid) length(nid) length(DATA.oldtrigtimes)];    fprintf('Triggers %d/%d old ones gone. (%d not ignored, %d >0.5ms from closest)\n',n,length(DATA.oldtrigtimes),length(bid),length(nid));    else        DATA.reclustern = [0 0 0 0];    end    try            res.VCdatediff = DATA.cluster.savetime(end)-FullVData.builddate;    catch    endelse    if ~isempty(addmean) %let command line override        DATA.addmean = addmean;    endendpcplots = [1 2; ...           1 3; ...           1 4; ...           1 5; ...           2 3; ...           2 4; ...           2 5; ...           3 5];%need to reset vpts for new probes, because probe # is added   vsmps = DATA.vsmps;DATA.dvpts = [0 9 0 13; ...           0 9 0 16; ...           0 9 -1 9; ...           0 13 1 13; ...           0 20 -1 14; ...           0 10 -1 5; ...           0 10 0 30; ...           0 9 0 12];if length(ispk) == 1    DATA.dvpts = [0 9 0 13; ...           0 9 0 16; ...           0 9 0 13; ...           0 9 0 5; ...           0 9 0 20; ...           0 5 0 13; ...           0 5 0 20; ...           0 5 0 16; ...           0 12 0 20];end if newdata == 1 || ~isfield(DATA,'vspace')    DATA = AllV.SetTemplatePlots(DATA);    DATA.gmtypes = [1 0 2 3];    %                      1       2       3       4           5           6            7             DATA.gmtypelabels = {'PCs', 'Var-E', 'ADC', 'Template' 'Template2' 'Reserved' 'StdTemplate' ...        'dVdV' 'Energy'     '????' '?' '?' '?' '?'     'StdTemplate3'};    %     8      9           10     11 12 13 14         15     DATA.pcspace = [1:4];  %N-D fits use first four PCs    DATA.tmplspace  = [1 2 8 10 5 12];    DATA.tmplspace(2,:)  = [1 2 3 4 0 0]; %for Template group 2    DATA.tmplspace(3,:)  = [1 2 3 4 0 0]; %for fixed std templates    DATA.tmplspace(4,:)  = [1 2 3 4 0 0]; %for fixed std templates    DATA.vspace = [6 11 15 20];    DATA.restricttimerange = [];    DATA.excludetrialids = [];    DATA.selectprobe = zeros(1,DATA.nprobes); end DATA.minenergy = minenergy;DATA.minvar = minvar;DATA.energy = [];if isfield(DATA,'trueprobe')    vprobe = DATA.trueprobe;else    vprobe = ispk(1);endDATA.energy(1,:) = sqrt(squeeze(sum(diff(AllVoltages(vprobe,:,:),1,2).^2,2)));DATA.eprobe(1) = vprobe;DATA.uid = 1:size(AllVoltages,3);%if DATA.thsign ==2 && length(DATA.rV) == length(DATA.uid)%    DATA.uid = find(DATA.rV < 0); %just use - trig first%DATA.uid not he way to go.  USe Add Cluster with new rigger%endif size(AllVoltages,1) > 20 && size(AllVoltages,1) >= chspk(1)    DATA.probe = chspk(1);endDATA.probe = ispk;if ~isfield(DATA.cluster,'chspk')    if isfield(DATA,'chspk')    endendif nprobepc < 0    DATA.chspk = chspk;elseif loadfromspikes    DATA.chspk = DataClusters{DATA.probe(1)}.chspk;elseif ismember(recluster,[1 2]) && isfield(DATA.cluster,'chspk')    if strncmp(DATA.DataType,'MicroWire',8)        dp = 0;    elseif ~strncmp(DATA.DataType,'Grid',4)        dp = ispk(1) - DATA.cluster.probe(1); %happens if apply cluster from another probe    else        dp = 0;    end    DATA.chspk = DATA.cluster.chspk+dp;    else    if size(AllVoltages,1) ==1        nprobepc = 0;    end    DATA.chspk = SetProbesToUse(DATA, ispk, nprobepc);    if ~isfield(DATA.cluster,'chspk')        DATA.cluster.chspk = DATA.chspk;    endendif sum(ismember(DATA.probe,DATA.chspk)) == 0     cprintf('red','Trigger Chan not in chspk\n');endnp = size(AllVoltages,1);nv = size(AllVoltages,2);DATA.nvpts = nv;DATA.vpts = AllV.SetVsamples(DATA,ispk(1),np,nv);DATA.npallv = np;DATA.dvpts(:,1) = DATA.dvpts(:,1) + DATA.probe(1);DATA.dvpts(:,3) = DATA.dvpts(:,3) + DATA.probe(1);id = find(DATA.dvpts(:,1) < 1);DATA.dvpts(id,1) = 1;id = find(DATA.dvpts(:,1) > np);DATA.dvpts(id,1) = np;id = find(DATA.dvpts(:,3) < 1);DATA.dvpts(id,3) = 1;id = find(DATA.dvpts(:,3) > np);DATA.dvpts(id,3) = np;id = find(DATA.dvpts(:,2) > nv);DATA.dvpts(id,2) = nv;id = find(DATA.dvpts(:,4) > nv);DATA.dvpts(id,4) = nv; DATA.pcplots = pcplots;DATA.t = res.t;DATA.spksperview = 100;DATA.spklst = 1:100;DATA.pcprobes = DATA.chspk; %? noew redundant?id = find(DATA.vspace > length(DATA.spts));DATA.vspace(id) = length(DATA.spts);if recluster == 0    DATA.cluster.spts = DATA.spts;endDATA.TemplateLabels = AllV.TemplateLabels(DATA,0);DATA.forcecluster = forcecluster;if isempty(DATA.plotspk.probes)DATA.plotspk.probes = DATA.chspk;endtt = AllV.TimeMark(tt,'Before Energy',DATA.profiling);%if only loaded one probe, can't do chspkif size(AllVoltages,1) == 1    DATA.chspk = ispk(1);    chspk = ispk(1);    nprobepc = 0;endxspk = DATA.chspk(DATA.chspk ~= vprobe);for j = 1:length(xspk)    DATA.energy(j+1,:) = sqrt(squeeze(sum(diff(AllVoltages(xspk(j),:,:),1,2).^2,2)));    DATA.eprobe(j+1) = xspk(j);endtt = AllV.TimeMark(tt,'Calc Energy',DATA.profiling);F = AllV.SetFigure(DATA.tag.top,DATA);if DATA.interactive >= 0    setappdata(F,'plotcsd',0);endDATA.toplevel = F;set(F,'UserData',DATA);%xsd is the SD of all local minima. Closer that 1sd to zero doesnt'%get explored automatically - roo much risk of running out ouf memory%clear AllVoltages;F = AllV.SetFigure(DATA.tag.top,DATA);AllV.SetGUI(DATA);if verbose >1    fprintf('Cacluating PCs %s %s\n',AllV.IDStr(DATA),datestr(now,'HHMM:ss'));endDATA.errs = {DATA.errs{:} errs{:}};if length(tryall) > 1 % when reapplying, just use CSD/Dvdt as before    np = size(DATA.pcplots,1);    for j = 1:length(tryall)        if tryall(j)        DATA.dvdt = dvdts(j);         DATA.csd = csds(j);        [Cs{j}, Evec{j}, pcs{j}, dips{j}, chsppks{j}, errs, fits{j}] = AllV.CalcPCs(DATA,AllVoltages,nprobepc);        DATA.errs = {DATA.errs{:} errs{:}};        else            dips{j} = 0;        end    end    res.alldips = cell2mat(dips');    if DATA.usebmi    [a,b] = max(max(res.alldips(:,1:np)'));    [c,d] = max(res.alldips(:,9)); %mahal distance for first 4     else        [c,d] = max(res.alldips);        b = d;    end    if d ~= b  %different answer        cb = max(res.alldips(d,1:8));        am = res.alldips(b,9);        DATA.msg = {DATA.msg{:} sprintf('Best PC type %d (bm%.2f,mahal%.1f) or %d(%.2f,%.1f)',b,a,am,d,cb,c)};        if verbose > 1        fprintf('%s\n',DATA.msg{end});        end        if b > 2 && a < 0.25            b = d;        end    end    res.pcs = pcs{b};    res.dipvals = dips{b};    DATA.dvdt = dvdts(b);    DATA.csd = csds(b);    DATA.Evec = Evec{b};    DATA.pcfit = fits{b};    res.Evec = Evec{b};%    DATA.chspk = chspk;    C = Cs{b};    DATA.alldips = res.alldips;    DATA.pcs(DATA.uid,:) = res.pcs;else    if recluster %no need to calcuate GMfits etc        [C, res.Evec, res.pcs, dip, chspk, errs] = AllV.CalcPCs(DATA,AllVoltages,nprobepc,'nofit');        DATA.errs = {DATA.errs{:} errs{:}};        if isfield(DATA.cluster,'Evec') && size(res.Evec.Evec,2) == size(DATA.cluster.Evec.Evec,2)            sgn = sign(sum(res.Evec.Evec .* DATA.cluster.Evec.Evec,1));            nid = find(sgn < 0);            res.Evec.Evec(:,nid) = -res.Evec.Evec(:,nid);            res.pcs(:,nid) = -res.pcs(:,nid);        end        DATA.pcfit.took = 0;        res.dipvals = 0;    else        [C, res.Evec, res.pcs, dip, chspk, errs, DATA.pcfit] = AllV.CalcPCs(DATA,AllVoltages,nprobepc);        res.dipvals = dip;    endDATA.pcs(DATA.uid,1:size(res.pcs,2)) = res.pcs;DATA.Evec = res.Evec;DATA.errs = {DATA.errs{:} errs{:}};endtt = AllV.TimeMark(tt,'PCs done',DATA.profiling);if isfield(res,'alldips')DATA.dipvals = res.alldips;else    DATA.dipvals = res.dipvals;endDATA.pcs = res.pcs;DATA.spkvar = [];for j = DATA.chspkDATA.spkvar(j,:) = squeeze(std(AllVoltages(j,:,:),[],2));endif DATA.profligateres.edip = HartigansDipTest(sort(DATA.energy(1,:)));endtt = AllV.TimeMark(tt,'SpkVar done',DATA.profiling);DATA.nprobepc = nprobepc;DATA.cluster.trigparams.preperiod = DATA.preperiod;DATA.cluster.trigparams.postperiod = DATA.postperiod;DATA.clid = [];DATA.nid = [];y = max(max(abs(AllVoltages(DATA.probe(1),:,:))));DATA.voffset = CalcVoffset(AllVoltages, DATA.chspk,DATA.gui.spikeVoverlap);%DATA.voffset = [1:size(AllVoltages,1)].*y;DATA.plotcsd = 0;xres = rmfield(res,'pcs');res.chspk = DATA.chspk;res.memsz = [0 DATA.fullvsize];str = 'manual';if saveautocut || autocutone    str = 'auto';    endDATA.cutmode = str;if verbose    fprintf('Making Cut %s %s (%.1f) (%s)\n',AllV.IDStr(DATA),datestr(now,'HHMM:ss'),mytoc(tt(1).time),AllV.ClusterFile(DATA.name,DATA,str));endF = AllV.SetFigure(DATA.tag.top,DATA);DATA.toplevel = F;DATA =  AllV.mysetappdata(DATA,'AllVoltages',AllVoltages);if saveautocut == 1    [E, res.cluster] = AllV.CutAndSave(DATA,'refine');    DATA = get(DATA.toplevel,'UserData');    DATA.MeanSpike = res.cluster.MeanSpike;    res.chspk = DATA.chspk;    if max(DATA.clid) < size(DATA.energy,2)        res.cluster.minspke = prctile(DATA.energy(1,DATA.clid),1) .* 0.95;        res.cluster.minspkvar = prctile(DATA.spkvar(DATA.probe(1),DATA.clid),1) .* 0.95;    end    set(DATA.toplevel,'UserData',DATA);    if DATA.savespikes         AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));    end    tt = AllV.TimeMark(tt,'Finish', DATA.profiling);    res.times = tt;    res.cluster = AllV.SmallCluster(res.cluster);    res.memsz = [AllV.memsize(DATA) DATA.fullvsize];    return;endif autocutone && recluster == 2    autocutone = 2;  %call autocut after reclassifyendif autocutone ==1    DATA.cluster = FixCluster(DATA.cluster,oldcluster);    if strcmp(DATA.autocutmode,'quick')        DATA.cluster.probe = AllV.ProbeNumber(DATA);        DATA = AllV.QuickAutoCut(DATA);        res.cluster = DATA.cluster;        E = AllV.BoundaryFromCluster([],DATA.cluster,1);    else        [E, res.cluster] = AllV.CutAndSave(DATA,'nosave','refine');    end    DATA = get(DATA.toplevel,'UserData');elseif autocutone == 2        DATA.cluster.probe = AllV.ProbeNumber(DATA);        DATA.cluster = FixCluster(DATA.cluster);        DATA = AllV.QuickAutoCut(DATA);        res.cluster = DATA.cluster;        E = AllV.BoundaryFromCluster([],DATA.cluster,1); elseif recluster    plottype = 0;  %don't do other things after classify    DATA.cluster = FixCluster(DATA.cluster,DATA);    if DATA.usealltrials     elseif isfield(DATA.cluster,'excludetrialids') && ~isempty(DATA.cluster.excludetrialids)        DATA.excludetrialids = DATA.cluster.excludetrialids;        AllV.SetTrialList(DATA);        if length(DATA.clst) < size(DATA.pcs,1);            DATA.clst = ones(size(DATA.pcs,1),1);        end        [DATA, AllVoltages] = AllV.ExcludeTrials(DATA,DATA.cluster.excludetrialids,0);        DATA = AllV.SetPCs(DATA, 0, 1);        DATA.pcs = DATA.pcs(DATA.uid,:);        DATA = AllV.mysetappdata(DATA,'AllVoltages',AllVoltages);    elseif isfield(DATA.cluster,'restricttimerange') && ~isempty(DATA.cluster.restricttimerange)        DATA = AllV.RestrictTimeRange(DATA,DATA.cluster.restricttimerange);        DATA = AllV.SetPCs(DATA,0,1);    end    if recluster == 3  %just use template        if length(DATA.forceclusters) > 1            for j = 1:length(DATA.forceclusters)                DATA.clid = [];                DATA.cluster = DATA.forceclusters{j};                DATA = AllV.ReClassify(DATA,'template');                res.cluster{j} = rmfield(DATA.cluster,{'r' 'bestcl'});            end        else            DATA = AllV.ReClassify(DATA,'template');            res.cluster = DATA.cluster;        end    elseif recluster == 4 %use previous ids        DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],DATA.cluster, DATA.currentcluster));        needtemplate = AllV.NeedTemplateForCluster(DATA.cluster,1);        DATA.plottype = AllV.WhichPlotType(DATA.cluster, DATA.currentcluster);        if needtemplate & (~isfield(DATA,'TemplateScores') ||newdata)            DATA = AllV.CalcTemplateScores(DATA);        elseif isfield(DATA,'TemplateScores')            DATA = rmfields(DATA, {'TemplateScores' 'TemplateUsed'});        end        if DATA.cluster.space(1) == 6            DATA.cluster.shape = 2;            [DATA.ndxy, a, b] = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            if b.err & ~isfield(DATA,'TemplateScores')                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);                DATA.plottype = 3;                res.err = 1;            end        end        res.cluster = AllV.SmallCluster(DATA.cluster);        if 0 %% old way. Why need to recalc Mean?? Quicker switching without        DATA.cluster.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',1);        id = unique(DATA.clst);        for j = 3:length(id)            DATA.cluster.next{j-2}.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',j-1);        end        else        id = unique(DATA.clst);        for j = 2:length(id)            AllV.PlotMeanSpike(DATA,'cluster',j-1);        end        end        DATA.clid = find(DATA.clst == 2);        DATA.nid = find(DATA.clst == 1);        AllV.ReplotPCs(DATA,[]);        AllV.PlotTriggerHist(DATA,DATA.cluster,'quick');        if DATA.plotspk.showmean            AllV.PlotSpikes(DATA,1);        end    elseif recluster == 2  || recluster == 1 %space, but new data        res.err = 0;        DATA.cluster.exptno = DATA.exptno;        DATA.cluster.clst = ones(DATA.nevents,1);        [iscll, cellid] =  AllV.isacell(DATA, DATA.exptno, AllV.ProbeNumber(DATA));        if iscll            a = find(cellid > 0);            res.cell = cellid(a(1));            res.cellid = cellid;        else            res.cell = 0;        end        if ~isfield(DATA.cluster,'clusterprog')            DATA.cluster.progversion = 0;            DATA.cluster.clusterprog = 'AllVPvs';        elseif ~isfield(DATA.cluster,'progversion')            id = strfind(DATA.cluster.clusterprog,' ');            if isempty(id)                DATA.cluster.progversion = 0;            else                DATA.cluster.progversion = sscanf(DATA.cluster.clusterprog(id(end):end),'%f');            end        end        if readclusterfromlog            DATA = AllV.ReadFromLog(DATA);        end        if recluster == 2 && oldxyloaded            oldid = find(DATA.oldclst == 2);            olnid = find(DATA.oldclst == 1);            xcl = [];            goodxcl = ones(size(DATA.excludetrialids));            for j = 1:length(DATA.cluster.excludetrialids)                t = find([DATA.Expt.Trials.id] == DATA.cluster.excludetrialids(j));                if length(t) == 1                    id = find(DATA.oldtrigtimes > DATA.Expt.Trials(t).Start(1)./10000 - DATA.preperiod & ...                        DATA.oldtrigtimes < DATA.postperiod+DATA.Expt.Trials(t).End(end)./10000);                    xcl = [xcl id];                elseif isempty(t)                    fprintf('Id %d no longer in Expt!\n',DATA.cluster.excludetrialids(j));                    goodxcl(j) = 0;                end            end            DATA.cluster.excludetrialids = DATA.cluster.excludetrialids(find(goodxcl));            DATA.excludetrialids = DATA.cluster.excludetrialids;            oldid = setdiff(oldid,xcl);        end        if DATA.cluster.space(1) ~= 6 && DATA.cluster.shape == 2            DATA = AllV.AddErr(DATA,'Error Shape 2 but space %s\n',sprintf('%d ',DATA.cluster.space));            DATA.cluster.shape = 1;        end                if DATA.cluster.auto == 2 %was set in plotcluster            DATA.cluster.auto = 0;        end        E = AllV.BoundaryFromCluster([],DATA.cluster, DATA.currentcluster);        if DATA.profiling            fprintf('Return from BoundaryCluster %.4f at %.4f\n',mytoc(E.endtime),mytoc(tt(1).time));        end        DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(E);        [needtemplate, plottypes] = AllV.NeedTemplateForCluster(DATA.cluster,1);        DATA.plottype = AllV.WhichPlotType(DATA.cluster, DATA.currentcluster);        if needtemplate & (~isfield(DATA,'TemplateScores') ||newdata)            if isfield(DATA.cluster,'TemplateUsed')                if size(DATA.cluster.TemplateUsed,1) == 2 && DATA.plottype ~= 7 && 0                    DATA.plottype = 7;                    DATA.cluster.space = [6 7];                    DATA.cluster.shape = 2;                end                DATA = AllV.SetTemplateData(DATA,DATA.currentcluster);            elseif sum(isnan(DATA.cluster.MeanSpike.ms(DATA.probe(1),:)))                DATA.clst = ones(length(DATA.t(DATA.uid)),1);                [a, id] = find(ismember(DATA.t,DATA.oldtrigtimes(oldid)));                if length(id)                    DATA.clst(id) = 2;                    AllV.TemplatePlot(DATA,'nodip');                    DATA = get(DATA.toplevel,'UserData');                else                    DATA = AllV.AddErr(DATA,'NAN Meanspike\n');                    DATA.cluster.space = [1 1 2];                end            else                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);%used to call this lager and remove filesd form dta here.  WHy?   can cause%ProjectND to fail%            elseif isfield(DATA,'TemplateScores')%                DATA = rmfields(DATA, {'TemplateScores' 'TemplateUsed'});            end            if ~isfield(DATA.cluster,'TemplateUsed')                DATA.cluster.TemplateUsed = DATA.TemplateUsed;            end        end        %if this clsuter previously used predefined eigenvectors, use those again        %if the cluster does not require this, but forceevec in on the command%line, set it in the cluster         if isfield(DATA.cluster,'forceevec')            if forceevec > 0                DATA.cluster.forceevec = forceevec;            elseif recluster == 2                forceevec = DATA.cluster.forceevec;            end        end        if DATA.cluster.space(1) == 6            clusterspace = DATA.cluster.space(2);        else            clusterspace = DATA.cluster.space(1);        end                if (ismember(recluster,[1 2]) || forceevec) && clusterspace == 1                        if isfield(DATA.cluster,'Evec') && (recluster == 2 || forceevec) %recalssify used old PCs.                 if ~isfield(DATA.cluster.Evec,'chspk')                    DATA.cluster.Evec.chspk = DATA.cluster.chspk;                end                [a,DATA.Evec, c] = AllV.CalcPCs(DATA, AllVoltages, DATA.nprobepc, DATA.cluster.Evec);                DATA.pcs(DATA.uid,1:size(c,2)) = c;                DATA.cluster.forceevec = 1;            elseif loadfromspikes == 0%When do we need to do this?  SHould have been done above?  ?? for rclassify%Also makes a mess because it doesn't pass existing Evec....%            [a,DATA.Evec, DATA.pcs(DATA.uid,:)] = AllV.CalcPCs(DATA, AllVoltages, DATA.nprobepc);            DATA.cluster.forceevec = 0;            else            DATA.cluster.forceevec = 0;            end            tt = AllV.TimeMark(tt,'PCs Redone',DATA.profiling);        end                if AllV.NeedNDspace(DATA.cluster)            if strncmp(DATA.cluster.clusterprog,'AllVpcs',7) && DATA.cluster.progversion <= 1.2                DATA.cluster.shape = 2;            end            [DATA.ndxy, a, b] = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            DATA.xy{1} = xyrotate(DATA.ndxy(:,1),DATA.ndxy(:,2),DATA.cluster.angle);            res.err = b.err;            if b.err & ~isfield(DATA,'TemplateScores')                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);                DATA.plottype = 3;            end            if b.err ==1 && DATA.cluster.auto == 1 %redo autocut                PrintMsg(DATA.logfid,'Redoing AllV.AutoCut to fix dimension error');                autocutone = 1;            end        elseif DATA.cluster.space(1) == 2 && DATA.cluster.shape ==2 && DATA.cluster.space(2) == 4 %earlier bug            DATA.ndxy = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            DATA.xy{1} = xyrotate(DATA.ndxy(:,1),DATA.ndxy(:,2),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 1            DATA.xy{1} = xyrotate(DATA.pcs(:,DATA.cluster.space(2)),DATA.pcs(:,DATA.cluster.space(3)),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 3            DATA.xy{1} = xyrotate(DATA.TemplateScores(:,DATA.cluster.space(2)),DATA.TemplateScores(:,DATA.cluster.space(3)),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 2 && length(DATA.cluster.space) > 4 %adc values            p = DATA.cluster.space(2:end);            xy(DATA.uid,1) = AllVoltages(p(1),p(2),DATA.uid);            xy(DATA.uid,2) = AllVoltages(p(3),p(4),DATA.uid);            %            x =  squeeze(AllVoltages(a(1),a(2),:));            DATA.xy{1} = xyrotate(squeeze(AllVoltages(p(1),p(2),:)),squeeze(AllVoltages(p(3),p(4),:)),DATA.cluster.angle);        end                if max(DATA.uid) > length(DATA.xy{1}) &&  length(DATA.uid) == length(DATA.xy{1})            uid = 1:length(DATA.xy{1});        else            uid = DATA.uid;        end    flipstr = [];    flip = 1;    DATA.cluster = AllV.CheckScoreScaling(DATA, DATA.cluster);    if DATA.cluster.auto && strcmp(DATA.cluster.automode,'james')        DATA.autocutmode = 'james';    elseif DATA.cluster.shape > 0 %not an ellipse - check sign        if DATA.cluster.crit < 0            ncut = sum(DATA.xy{1}(uid,1) < DATA.cluster.crit);            nalt =  sum(DATA.xy{1}(uid,1) > -DATA.cluster.crit);        else            ncut = sum(DATA.xy{1}(uid,1) > DATA.cluster.crit);            nalt =  sum(DATA.xy{1}(uid,1) < -DATA.cluster.crit);        end        if recluster == 2 && exist('oldid','var')             nspk = length(oldid);            if ncut < nspk/10 && nalt > nspk/5                DATA.cluster.crit = DATA.cluster.crit .* -1;                DATA.cluster.sign = DATA.cluster.sign .* -1;                flipstr = 'flip';                flip = -1;            end        end    end    if autocutone        [E, scores, dips, xy, details] = AllV.AutoCut(DATA);        DATA = get(DATA.toplevel,'UserData');        DATA.ndxy = xy;        DATA.cluster = AllV.ClusterFromBoundary(E, DATA.cluster);        AllV.CheckClusters(DATA.cluster,'CheckFitSpace')        %            DATA.ndxy = AllV.ProjectND(DATA, E.space(2), E.gmfit);    end    if length(DATA.uid) == 0 && isfield(DATA.cluster,'restricttimerange')        DATA = AllV.UseAllEvents(DATA);    end    ctimes(1) = DATA.cluster.ctime;    for j = 1:length(DATA.cluster.next)        if isfield(DATA.cluster.next{j},'ctime')            ctimes(j+1) = DATA.cluster.next{j}.ctime;        else            if isempty(DATA.cluster.next{j})                ctimes(j+1) = 0;            else                errordlg(sprintf('Missing ctime Cluster %d',j+1),'Cluster Cut Time','modal');                ctimes(j+1) = j+1;            end        end    end    ctimes = ctimes(ctimes > 0);    [a, tlist] = sort(ctimes);    tt = AllV.TimeMark(tt, 'Pre Cluster', DATA.profiling);    %check to see if there are missing "next" clusters    wasempty = 0;    p = AllV.ProbeNumber(DATA);    if recluster == 2 && DATA.reclustern(1) == 0 && oldxyloaded %trigger times match - can use old clst        DATA.clst = DATA.oldclst;        cc = DATA.currentcluster;        for j = 1:length(DATA.cluster.next)            if isempty(DATA.cluster.next{j})                wasempty = 1;                if sum(DATA.clst ==  j+2) > 1                    DATA.currentcluster = j+1;                    DATA.cluster.next{j}.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');                end            elseif wasempty                wasempty = 2;            end        end        DATA.currentcluster = cc;    end    if useoldlst == 0        DATA.clst = [];    end%if its non interactive, don't use quick clustering        if recluster == 1 && DATA.watchplots < 2 && DATA.interactive >= 0        DATA = AllV.ClassifyAll(DATA,1,'quick','recluster');    else        DATA = AllV.ClassifyAll(DATA,1,'recluster');    end    tt = AllV.TimeMark(tt,'Classified',DATA.profiling);    %if an error messed up the classification, don't copy meanspike    res.cluster = AllV.SmallCluster(DATA.cluster);    AllV.ReplotPCs(DATA,[],'tofront');    if recluster ~= 1 %will have been called in AllV.ClassifySpikes        AllV.PlotTriggerHist(DATA,DATA.cluster);    end     tt = AllV.TimeMark(tt,'Replotted', DATA.profiling);    if recluster == 2 && isfield(DataClusters{p},'space') && exist('oldid','var')        oldC = DataClusters{p};        if length(oldC.space) == 1            oldC.space(2) = 0;        end        if max(oldid) > length(DATA.oldtrigtimes)            oldid = oldid(oldid <= length(DATA.oldtrigtimes));        end        %idxa is matching times for classified spikes        [ts, idxa, idxb] = intersect(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));        unsafetosave = 0;        [ida, iida] = setdiff(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));        [a,iidb, c, b] = MatchTimes(DATA.t(DATA.clid),DATA.oldtrigtimes(oldid),0.0005);        idb = DATA.oldtrigtimes(oldid(iidb)); %old times not in new        if checklast > 1            DATA = AllV.CompareSpikeLists(DATA,ida, idb,iida,iidb);        end                        if DATA.interactive >= 0 && ~isempty(DATA.clid) && ~isempty(oldid)            AllV.SetFigure(DATA.tag.oldxy, DATA);            subplot(2,1,2);            AllV.PlotXY(flip .*DATA.lastxy,DATA.oldclst);            title(sprintf('Mahal 1D %.2f, 2D %.2f Space%s',oldC.mahal(4),oldC.mahal(1),...                sprintf(' %d',oldC.space)));            subplot(2,1,1);            hold off;            h(1) = plot(DATA.oldtrigtimes,flip.*DATA.lastxy(:,1),'k.','buttondownfcn',{@AllV.ShowFullV, 1}); %old events            labels{1} = 'old triggers';            hold on;            h(2) = plot(DATA.t(DATA.uid),DATA.xy{1}(DATA.uid,1),'c.','buttondownfcn',{@AllV.ShowFullV, 2});            labels{2} = 'New Triggers';            h(3) = plot(DATA.oldtrigtimes(oldid),flip.*DATA.lastxy(oldid,1),'.','buttondownfcn',{@AllV.ShowFullV, 1}); %old cell            labels{3} = 'old cell';            h(4) = plot(DATA.t(DATA.clid),DATA.xy{1}(DATA.clid,1),'r.','buttondownfcn',{@AllV.ShowFullV, 2});            labels{4} = 'New Cell';            yl = get(gca,'ylim');            yl(2) = yl(1) + diff(yl)/8;            if isfield(DATA.Expt,'Trials')                for j = 1:length(DATA.Expt.Trials)                    t = DATA.Expt.Trials(j).Start(1)./10000;                    plot([t t],yl,'k-');                end            end            if ~isempty(idxa)            h(5) = plot(DATA.t(DATA.clid(idxa)),DATA.xy{1}(DATA.clid(idxa),1),'g.');            end            labels{5} = '?';            if ishandle(h)                legend(h,labels);            end                                    AllV.SetFigure(DATA.tag.hist, DATA);            subplot(2,1,2);            h = ishold;            hold on;            if ~isempty(iida)                plot(DATA.xy{1}(DATA.clid(iida),1),DATA.xy{1}(DATA.clid(iida),2),'x');            end            if h == 0                hold off;            end        end        str = sprintf('P%d last cut at %s: %d/%d New spikes not in old.  %d/%d old spikes not new (%s)',...            AllV.ProbeNumber(DATA),datestr(oldC.ctime),length(ida),...            length(DATA.clid),length(idb),length(oldid),flipstr);        res.matchcounts = [length(ida) length(DATA.clid) length(idb) length(oldid) NaN];        if DATA.reclustern(1) == 0 %trigger times match - can compare lsts            if length(DATA.uid) == length(DATA.oldclst)                res.matchcounts(5) = sum(DATA.clst(DATA.uid) ~= DATA.oldclst);            elseif length(DATA.clst) == length(DATA.oldclst)                res.matchcounts(5) = sum(DATA.clst ~= DATA.oldclst);            end        end        if abs(length(DATA.clid)-length(oldid))/length(oldid)  > 0.2            unsafetosave = 1;            unsafelabels{1} = 'classified id length mismatch';        end        PrintMsg(DATA.logfid,str);        ida = setdiff( DATA.oldtrigtimes,DATA.t);        fprintf('Triggers %d/%d old ones gone\n',length(ida),length(DATA.oldtrigtimes))                id = find(DATA.cluster.clst ==2);        missid = setdiff(oldC.times,DATA.t(id));        res.matchcounts(6) = length(missid);        nx = min([length(DATA.cluster.next) length(oldC.next)]);        for k = 1:nx            if isfield(DATA.cluster.next{k},'times') && isfield(oldC.next{k},'times')                id = find(DATA.cluster.clst ==2+k);                missid = setdiff(oldC.next{k}.times,DATA.t(id));                res.matchcounts(6+k) = length(missid);            end        end        if DATA.interactive >= 0        AllV.SetFigure(DATA.tag.oldxy, DATA);        title(str);        AllV.SetFigure(DATA.tag.comparexy, DATA);        hold off;        plot(DATA.xy{1}(DATA.clid(idxa),1),DATA.lastxy(oldid(idxb),1),'.');        hold on;        plot(DATA.xy{1}(DATA.clid(idxa),2),DATA.lastxy(oldid(idxb),2),'r.');        refline(1);        end        if length(idxa) > 1            xc = corrcoef(DATA.xy{1}(DATA.clid(idxa),1),DATA.lastxy(oldid(idxb),1));            yc = corrcoef(DATA.xy{1}(DATA.clid(idxa),2),DATA.lastxy(oldid(idxb),2));            if abs(xc(1,2)) < 0.5                unsafetosave = unsafetosave+2;            end        else            xc = [];            if length(oldid) > 5 % if there are no spikes in the older file, there is no problem                unsafetosave = unsafetosave+2;            end        end                if autocutone %'autocut' on command line            unsafetosave = -unsafetosave;        end        PrintMsg(DATA.logfid,'%s Trigger match %d %d %d %d',AllV.IDStr(DATA),DATA.reclustern(1),DATA.reclustern(2),DATA.reclustern(3),DATA.reclustern(4)); %reclustern(3) is missing triggers that dont have a match at +-0.5ms        if DATA.reclustern(3)./DATA.reclustern(4) > 0.1            unsafetosave = unsafetosave+4;        end        %manual == 4 means using reflcuster, don't worry about matching old        %space        if DATA.cluster.manual ~= 4            DATA.cluster.auto = DataClusters{p}.auto;        end        if DATA.cluster.manual ==2 %done in plotcluster but not ye quantified. = Can't check            unsafetosave = -1000;        elseif unsafetosave & DATA.cluster.auto == 1  && ~AllV.isacell(DATA, DATA.exptno, p);            if isfield(DATA.cluster,'automode')                DATA.autocutmode = DATA.cluster.automode;            end            if DATA.savespikes                fprintf('Mismatched, so redoing autocut and saving\n');                [E, res.cluster] = AllV.CutAndSave(DATA,'savetomain');            else                fprintf('Mismatched, so redoing autocut\n');                [E, res.cluster] = AllV.CutAndSave(DATA,'nosave');            end            DATA = get(DATA.toplevel,'UserData');            AllV.CheckClusters(DATA.cluster,'CheckFitSpace')            unsafetosave  = -unsafetosave;        end        if wasempty == 2  %empty clusters were saved            unsafetosave = unsafetosave + 128;        end % sometimes triggerchan has 2 probes but trigger clearly was really just % one.  Mark this so can check if necessary        if unsafetosave > 0 && length(DATA.cluster.triggerchan) > 1            unsafetosave = unsafetosave + 64;        end%if saved cluster is quick, then can't use saved xy,clst%so just look at times of classified events        if isfield(oldC,'quick') && oldC.quick             if sum(res.matchcounts(6:end)) == 0                fprintf('List of clustered spike times matches\n');                unsafetosave = 0;            end            res.wasquick = 1;        else            res.wasquick = 0;        end        if ismember(unsafetosave,1) && fixellipse            oldclid = DATA.clid(idxa);            [ts, idx] = intersect(round(DATA.t.*1000), round(DATA.oldtrigtimes(oldid).*1000));            oldclid = idx; %current spikes that were in cluster before            [ts, idx] = intersect(round(DATA.t.*1000), round(DATA.oldtrigtimes(DATA.oldclst ~= 2).*1000));            oldnotcl = idx; %current spikes that were in cluster before            newid = cat(1,oldclid(:),oldnotcl(:));            clst = ones(size(newid))';            clst(1:length(oldclid)) = 2;            if DATA.interactive >= 0                fargs = {'plot' 'tag' 'NewEllipse'};            else                fargs = {};            end            [xyr, score] = FindEllipse(DATA.xy{1}(newid,:),clst(:), fargs{:});            DATA.cluster.xyr = xyr(1:4);            DATA.cluster.angle = xyr(5);            for j = 1:length(DATA.cluster.next)                if isfield(DATA.cluster.next{j},'xyr')                    [ts, idx] = intersect(round(DATA.t.*1000), round(DATA.oldtrigtimes(DATA.oldclst == j+2).*1000));                    oldclid = idx; %current spikes that were in cluster before                    [ts, idx] = intersect(round(DATA.t.*1000), round(DATA.oldtrigtimes(DATA.oldclst ~= j+2).*1000));                    oldnotcl = idx; %current spikes that were in cluster before                    newid = cat(1,oldclid(:),oldnotcl(:));                    clst = ones(size(newid))';                    clst(1:length(oldclid)) = 2;                    [xyr, score] = FindEllipse(DATA.xy{j+1}(newid,:),clst(:),fargs{:});                    DATA.cluster.next{1}.xyr = xyr(1:4);                    DATA.cluster.next{j}.angle = xyr(5);                end            end            DATA = AllV.ClassifyAll(DATA,1,'recluster');            if checklast > 1                [ida, iida] = setdiff(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));                [idb, iidb] = setdiff( round(DATA.oldtrigtimes(oldid).*1000),round(DATA.t(DATA.clid).*1000));                DATA = AllV.CompareSpikeLists(DATA,ida, idb,iida,iidb);            end            [ts, idx] = intersect(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));            fprintf('After fixing ellipse %d/%d new spikes are in old.  Old spikes was %d\n',length(idx),length(DATA.clid),length(oldid));            if abs(length(DATA.clid)-length(oldid))/length(oldid)  < 0.2                unsafetosave = 0;            end        end        res.overlapn = length(ts);        res.cutfraction(1) = length(oldid)./length(DATA.oldclst);        res.cutfraction(2) = length(DATA.clid)./length(DATA.clst);        res.trigmatch = DATA.reclustern;        res.stds  = cat(1,std(DATA.xy{1}),std(DATA.lastxy));        if length(xc) > 1            res.xcorr = [xc(1,2) yc(1,2)];        else            res.xcorr = [0 0 ];        end        DATA.cluster.reclassify.matchcounts = res.matchcounts;        DATA.cluster.reclassify.trigmatch = res.trigmatch;        DATA.cluster.reclassify.xcorr = res.xcorr;        DATA.cluster.reclassify.unsafetosave = unsafetosave;        DATA.cluster.reclassify.probe = p;        DATA.cluster.reclassify.expt = DATA.exptno;        DATA.cluster.reclassify.ctime = now;    elseif recluster == 1 && refinecluster% Would like to fit old ellipse, then use this starting point to fit GM% model in this space, and adjust ellipse to catpure those points.  But GM% model may go off and fit something else entirelys, esp whern there are% two clusters.%lemM211 Expt 35 P6 is  a good example          if length(DataClusters)< p || ~isfield(DataClusters{p},'mahal')                  unsafetosave = 0;          elseif DataClusters{p}.mahal(1) > DATA.cluster.mahal(1)             if forcecluster == 0                 unsafetosave = 1;             end         elseif DataClusters{p}.auto == 0 && DATA.cluster.exptno ~= forceclusterexpt             %for now only replace auto cuts with refined manual cuts             %if auto == 0 but manual ==3, means this is a previous             %"refinement", so overwrite.              if isfield(DataClusters{p},'manual') && ...                     DataClusters{p}.manual == 1             unsafetosave = unsafetosave+256;             end         end    else        unsafetosave = NaN; %don't know this    end        res.auto = DATA.cluster.auto;        res.unsafetosave = unsafetosave;        if DATA.interactive > 0            drawnow;        end    elseif recluster == 10  %old 2, diabled for now        DATA = AllV.ReClassify(DATA);        res.cluster = AllV.SmallCluster(DATA.cluster);    else        DATA = AllV.ReClassify(DATA);        res.cluster = AllV.SmallCluster(DATA.cluster);    end    E = DATA.clusterboundary{DATA.currentcluster};    if DATA.profiling        fprintf('Return from BoundaryCluster %.4f at %.4f\n',mytoc(E.endtime),mytoc(tt(1).time));    end    if isfield(E,'space')    DATA.plottype = AllV.WhichPlotType(E,1);    end    AllV.PlotHistogram(DATA,E, DATA.quickcutmode);    if DATA.profiling        fprintf('Return from PlotHistoGram at %.4f\n',mytoc(tt(1).time));    end    if recluster == 2 && unsafetosave >= 0 && DATA.interactive > 0 %<0 = redone autocut, so may not match        subplot(2,1,2);        hold on;        plot(DATA.xy{1}(DATA.clid(iida),1),DATA.xy{1}(DATA.clid(iida),2),'gx');        hold off;    end    if DATA.autorefine        res.refinemode = DATA.refinemode;    end    if calcdistancematrix        res.DistanceMatrix = AllV.CalcDistanceMatrices(DATA, calcdistancematrix);        DATA.errs = {DATA.errs{:} res.DistanceMatrix.errs{:}};        DATA.errstates = {DATA.errstates{:} res.DistanceMatrix.errstates{:}};        if DATA.interactive >= 0            b = res.DistanceMatrix;            DATA.gmcid = res.DistanceMatrix.cid;            DATA.usegmcid = 1;            GetFigure('DistanceMatrix');            [E,V] = eig(squeeze(b.D(:,:,1)));            [c,d] = sort(E(:,1));            D = MatrixPermute(b.D(:,:,1),d);            imagesc(D);            caxis([0 5]);            AllV.ReplotPCs(DATA,[]);%            set(DATA.toplevel,'UserData',DATA);        end    end%    AllV.UpdateClusterDetails(DATA);elseif DATA.interactive >= 0  %this is inteactive for sure    DATA.cluster = FixCluster(DATA.cluster,DATA);    DATA.watchplots = 1;    DATA.watcharg = {'front'};    DATA.interactive = 1;    plotdprimemax = 1;%    [d, details] = FindDip(DATA.pcs(:,1),DATA.energy(1,:));    [d, details] = GMDip(DATA.pcs(:,1:2),DATA.energy(1,:),'label',DATA.idstr);    dcrit = d(1);    E = AllV.BoundaryFromCluster([],DATA.cluster,DATA.currentcluster);    E.pos(1) = dcrit;    E.pos(3) = dcrit;    E.pos(2)= min(DATA.pcs(:,2));    E.pos(4)= max(DATA.pcs(:,2));    p = E.pos;    E.xyr = [mean(p([1 3])) mean(p([2 4])) abs(diff(p([1 3]))/2) abs(diff(p([2 4]))/2)];    E.shape = 1;    E.space = [1 1 2];    E.h = [];    E.pcplot = [1 2];    if dcrit < 0        DATA.clid = find(DATA.pcs(:,1) < dcrit);        DATA.nid = find(DATA.pcs(:,1) >= dcrit);        cid = find(DATA.pcs(:,1) < d(2));        nid = find(DATA.pcs(:,1) >= dcrit);    else        DATA.clid = find(DATA.pcs(:,1) > dcrit);        DATA.nid = find(DATA.pcs(:,1) <= dcrit);    end    res.id = DATA.clid;%    res.dprime = abs(details.dprime);    res.dvdt = DATA.dvdt;    res.csd = DATA.csd;endif DATA.profiling    fprintf('recluster done at  %.4f\n',mytoc(tt(1).time));endif ~isfield(DATA.cluster,'auto')    DATA.cluster.auto = 0;endif calcclscores    k = 0;    for j = 1:length(Clusters)        if ~isempty(Clusters{j});            k = k+1;          res.Clusterscores(k,:) = Clusters{j}.MeanSpike.ms * squeeze(AllVoltages(ispk(1),:,:));         end    endend    if plotsummary        AllV.SetFigure(DATA.tag.allspikes, DATA);        AllV.PlotQuickSpikes(DATA,500);        AllV.PlotAllProbes(DATA,'xy')    endres.saved = 0;if saveclusters == 1 || saveclusters == 3 || (saveclusters == 2 && unsafetosave <= 0)%Calls from teh command line mean that this is automatic clustering. %Unless its a recluster    if saveautocut == 2        DATA.cluster.auto=1;        DATA.savespikes = 2;    end    if (recluster == 0 && DATA.cluster.auto ~= 1) || recluster >  0 || saveautocut == 2    outname = AllV.ClusterFile(DATA.name,DATA);    else    outname = AllV.ClusterFile(DATA.name,DATA,'auto');    end    DATA =  AllV.SaveClusters(DATA, outname);    res.saved = 1;    set(DATA.toplevel,'UserData',DATA);    Cluster = DATA.cluster;% Can't do this any more - DATA.MeanSpike might be for cl 2%    cluster.MeanSpike = DATA.MeanSpike;    if DATA.savespikes        AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));    endendres.memsz = [AllV.memsize(DATA) DATA.fullvsize];if DATA.csd && DATA.interactive >= 0    AllCSD = diff(AllVoltages,DATA.csd,1);    setappdata(DATA.toplevel,'AllCSD',AllCSD);endif DATA.interactive >= 0 && DATA.plot.covarAllV.SetFigure(DATA.tag.covar, DATA);imagesc(C);endDATA.nid = 1:size(AllVoltages,3);if DATA.readlayout == 2    AllV.ApplyLayout(DATA);endif recluster    if DATA.profiling        fprintf('QuickSpks at %.4f\n',mytoc(tt(1).time));    end    if DATA.quickcutmode.plotspikes && DATA.interactive >=0        AllV.QuickSpks(DATA, 1000);    end    fprintf('recluster %s took %.2f (at %s)\n',AllV.IDStr(DATA),mytoc(tt(1).time),datestr(now));    if DATA.profiling        t = timediff([tt.time]);        for j = 1:length(tt)            fprintf('  %s took %.2f \n',tt(j).str,t(j));        end    endendif DATA.profiling > 1endif DATA.plot.exptfit > 0 || DATA.plot.expt    DATA.Expt = AllV.PlotExptCounts(DATA);endif DATA.interactive >= 0    figure(DATA.toplevel);        AllV.AddCompareMenu(DATA);    if DATA.elmousept.shape < 0  DATA.currentcluster ~= DATA.elmousept.cluster        DATA = AllV.SetEllipseDrawing(DATA, 1, 'cluster', DATA.currentcluster);    elseif DATA.currentcluster ~= DATA.elmousept.cluster        DATA = AllV.SetEllipseDrawing(DATA, DATA.elmousept.shape, 'cluster', DATA.currentcluster);    endendres.errs = DATA.errs;if isfield(DATA.cluster,'errs')    res.errs = {res.errs{:} DATA.cluster.errs{:}};endif plottype == 0%may not get logfid from GUI if not interactive %which means each call will open a new handle. So close here    DATA = AllV.CloseLog(DATA);    res.logfid = DATA.logfid;    res.errstates = DATA.errstates;    res.times = tt;    DATA.profiletimes = tt;    if DATA.interactive >= 0        drawnow; % force draing of any other figurs to be sure this sets active figure        set(0,'currentfigure',DATA.toplevel);        AllV.SetGUI(DATA);        set(DATA.toplevel,'UserData',DATA);    end    if nargout == 3 %need cluster bits back        Clusters = AllV.mygetappdata(DATA,'Clusters');        ClusterDetails = AllV.mygetappdata(DATA,'ClusterDetails');        varargout{1} = Clusters{AllV.ProbeNumber(DATA)};        varargout{2} = ClusterDetails{AllV.ProbeNumber(DATA)};    end    return;endDATA.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');if DATA.interactive >= 0    AllV.SetFigure(DATA.tag.vare, DATA);    hold off;    c = DATA.probe(1);    plot(DATA.energy(1,:),DATA.spkvar(c,:)./DATA.energy(1,:),'.');    set(DATA.toplevel,'UserData',DATA);    AllV.ShowTaggedProbes(DATA);    AllV.SetFigure(DATA.tag.spikes, DATA);    DATA.plotdvdt = 0;    AllV.PlotSpikes(DATA,1:100);endif oldscores & ~isempty(DataClusters{DATA.probe(1)})    DATA = AllV.CalcTemplatesFromMean(DATA, DataClusters{DATA.probe(1)}.MeanSpike);    DATA.plottype = AllV.WhichPlotType(DataClusters{DATA.probe(1)},1);    E = AllV.BoundaryFromCluster(E,DataClusters{DATA.probe(1)}, DATA.currentcluster);    E.pcplot = DataClusters{DATA.probe(1)}.space(2:end);    DATA.cluster = DataClusters{DATA.probe(1)};endif ~isfield(DATA,'TemplateUsed')    DATA.TemplateUsed = [];endif recluster == 0 && DATA.interactive >= 0 if autocutone == 0 %niether auto not recluster = simple cut    %if recluster is 0, templates may not have been calcualted.  Don't use    %existing "TemplateScores" field - might belong to earlier probe    if ismember(DATA.plottype,[3 4])        DATA.plottype = 1;    end    DATA.cluster.space = [1 1 2];    [cl, Cluster] = AllV.ClassifySpikes(DATA,E,'quick');    cl.MeanSpike = AllV.PlotMeanSpike(DATA);    DATA.clid = cl.id;    DATA.nid = cl.nid;    DATA.clst = cl.clst;    Cluster.MeanSpike = cl.MeanSpike;    Cluster.chspk = DATA.chspk;    Cluster.minspke = min(DATA.energy(1,DATA.clid));    DATA.cluster = Cluster;    DATA.xy{1} = xyrotate(DATA.pcs(:,DATA.cluster.space(2)),DATA.pcs(:,DATA.cluster.space(3)),DATA.cluster.angle);    E = Cluster;endAllV.PlotHistogram(DATA,E,'quick');DATA = AllV.ReplotPCs(DATA,E);tt = AllV.TimeMark(tt,'Finish',DATA.profiling);res.times = tt;endif spoolspikes    AllV.SpoolSpikes(DATA,DATA.watcharg{:});endif DATA.checkclustersAllV.CheckClusters(DataClusters,'Start');AllV.CheckClusters(DataClusters,'CheckNexts','Start');AllV.CheckClusters(DataClusters,'CheckFitSpace');endres.toplevel = DATA.toplevel;if ~isfield(DATA.cluster,'next')    DATA.cluster.next = {};endDATA = AllV.CloseLog(DATA);if F > 0    set(F,'UserData',DATA);endif nargout > 2    Clusters = AllV.mygetappdata(DATA,'Clusters');    ClusterDetails = AllV.mygetappdata(DATA,'ClusterDetails');    varargout{1} = Clusters{AllV.ProbeNumber(DATA)};    varargout{2} = ClusterDetails{AllV.ProbeNumber(DATA)};endAllV.SetGUI(DATA);