function [DATA, details]  = EckerAutoCut(DATA, varargin)usev = 0;retrigger = 0;reapply = 0;explore = 1;j = 1;while j <= length(varargin)    if strncmpi(varargin{j},'quick',5)        explore = 0;    elseif strncmpi(varargin{j},'reapply',5)        reapply= 1;        j = j+1;        C = varargin{j};    elseif strncmpi(varargin{j},'retrigger',5)        retrigger = 1;    end    j = j+1;endaddpath('/b/group/matlab/agb');Vall = AllV.mygetappdata(DATA,'Vall');Vall.Vtime = Vall.t;Vall.Fs = 40000;X.Vtime = Vall.t;X.Fs = 40000;if isinteger(Vall.V)    %X.V = double(Vall.V').*Vall.intscale(1)/Vall.intscale(2);else    X.V = Vall.V;endif retriggerelseif explore      fits{1} =  TryKalman(DATA, DATA.pcs(:,1:5)',[1 1:5]);      fits{2} =  TryKalman(DATA, DATA.pcs(:,1:8)',[1 1:8]);      fits{3} =  TryKalman(DATA, DATA.pcs(:,1:12)',[1 1:12]);      if ~isfield(DATA,'TemplateScores')%almost certainly worth more work here - use a quick template, or use%best cluster from above          DATA.usestdtemplates = 1;          DATA = AllV.CalcTemplateScores(DATA);          DATA.cluster.TemplateUsed = DATA.TemplateUsed;      end      fits{4} =  TryKalman(DATA, DATA.TemplateScores,[3 [1:size(DATA.TemplateScores,2)]]);      fits{5} =  TryKalman(DATA, DATA.TemplateScores(:,[1 8 10 15]),[3 1 8 10 15]);      id = unique(DATA.tmplots(1:8,:));      fits{6} =  TryKalman(DATA, DATA.TemplateScores(:,id),[3 id(:)']);      %fits{7} =  TryKalman(DATA, DATA.TemplateScores(:,id),[3 1 2]);      fit = ChooseBestFit(fits);      DATA.cluster.autofits = CondenseFits(fits);;%      DATA.cluster.autofits = fits; %Each has a clst, wasteful for now, but may want to lookelseif reapplyelse        if DATA.plottype == 3            id = unique(DATA.tmplots(1:8,:));            fits{1} = TryKalman(DATA, DATA.TemplateScores(:,id(1:5))', [3 1:5]);            if isempty(fits{1}.bestscores) && length(id) > 5                fits{2} = TryKalman(DATA, DATA.TemplateScores(:,id)', [3 id(:)']);            else                fits{2} = TryKalman(DATA, DATA.TemplateScores', [3 1:size(DATA.TemplateScores,2)]);            end            fit = ChooseBestFit(fits);        else            fit = TryKalman(DATA, DATA.pcs(:,1:10)', [1 1:10],'zscore');        endendDATA.cluster.cluster =1;details.newDATA = 0;[DATA, DATA.cluster] = SetClusterFromFit(DATA, DATA.cluster, fit);DATA.cluster = AllV.PlotTriggerHist(DATA,DATA.cluster,'fitall');DATA.cluster.eckercluster.dropi(1,:) = DATA.cluster.hashdropi;DATA.cluster.eckercluster.dropi(2,:) = DATA.cluster.dropi;for j = 1:length(DATA.cluster.next)    if isfield(DATA.cluster.next{j},'dropi')        DATA.cluster.eckercluster.dropi(j+2,:) = DATA.cluster.next{j}.dropi;    endendDATA.usegmcid = 1;  %plot results according to GM clusteringfunction fits = CondenseFits(F)fields = {'params' 'mu_t' 'mu' 'C' 'Cmu' 'priors' 'df' };cfields = {'Y' 't' 'train' 'test'};for j = 1:length(F)    for k = 1:length(fields)        f = fields{k};        if iscell(F)            fits(j).eckercluser.fit.(f) = F{j}.eckercluster.fit.(f);        else            fits(j).(f) = F(j).(f);        end    endendfunction [DATA, C] = SetClusterFromFit(DATA, C, fit)C = DATA.cluster;C.eckercluster = fit.eckercluster;C.ctime = now;DATA.clst = fit.clst;if ~isfield(fit,'SU') %failed    fit.SU = 0;endmu = find(fit.SU ==0);DATA.clid = find(DATA.clst == C.cluster+1);DATA.nid = find(DATA.clst ~= C.cluster+1);DATA.gmcid = DATA.clst;cls = unique(DATA.clst);spaces = [];C.space = [14 1 2];C.next = {};Tbins = linspace(min(DATA.rV),max(DATA.rV));%a == a is MU, so only cls-1 clustersfor j = 1:length(cls)-1    spaces = [spaces fit.space{j+1,1}(1:3)];    fit.bestspace(j+1,:) = fit.space{j+1,1}(1:3);    if fit.bestspace(j+1,1) == 1        DATA.xy{j} = DATA.pcs(:,fit.bestspace(j+1,2:3));    elseif fit.bestspace(j+1,1) == 3        DATA.xy{j} = DATA.TemplateScores(:,fit.bestspace(j+1,2:3));    end    sid = find(DATA.clst == j+1);    [a,b] = hist(DATA.rV(sid),Tbins);    if j > 1         C.next{j-1}.space = fit.bestspace(j,:);        C.next{j-1}.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',j,'noplot');        C.next{j-1}.mahal(1) = fit.eckercluster.type1(j);        C.next{j-1}.mahal(2) = fit.eckercluster.type2(j);        C.next{j-1}.mahal(3) = fit.eckercluster.SU(j);        C.next{j-1}.mahal(4) = 0;        C.next{j-1}.vhist = a;        C.next{j-1}.auto = 2;        C.next{j-1}.shape = 3;        C.next{j-1}.isolation = fit.isolation(j+1,:);               C.next{j-1}.vhistrange = minmax(b);        C.next{j-1}.cluster = j;        Amps(j+1,:) = C.next{j-1}.MeanSpike.amp./max(C.next{j-1}.MeanSpike.amp);    else        C.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',1,'noplot');        C.space = fit.bestspace(j,:);        C.vhist = a;        C.vhistrange = minmax(b);        C.isolation = fit.isolation(2,:);               Amps(2,:) = C.MeanSpike.amp./max(C.MeanSpike.amp);    end        endsid = find(DATA.clst == 1);if ~isfield(fit,'space')    fit.bestspace = [1 1 2];    fit.isolation = 0;elseif length(cls) ==1 %no cluster found    spaces = [spaces fit.space{1,1}(1:3)];    fit.bestspace(1,:) = fit.space{1,1}(1:3)    if fit.bestspace(1,1) == 1        DATA.xy{1} = DATA.pcs(:,fit.bestspace(2:3));    elseif fit.bestspace(1,1) == 3        DATA.xy{1} = DATA.TemplateScores(:,fit.bestspace(1,2:3));    end    C.dropi = [0 0 NaN NaN];    fit.bestspace(1,:) = fit.space{1,1}(1:3); %best space for 0 vs 1else    fit.bestspace(1,:) = fit.space{1,2}(1:3); %best space for 0 vs 1endV = AllV.mygetappdata(DATA,'AllVoltages');ms = mean(V(:,:,sid),3);A = std(ms');Amps(1,:) = A/max(A);C.eckercluster.bestspace = fit.bestspace;C.eckercluster.isolation = fit.isolation;C.eckercluster.amplitudes = Amps;C.autocutmode = 'ecker';C = CopyFields(C,DATA,{'probe','Trigger' 'autocutmode' 'chspk'});C.auto  = 2;C.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','noplot');C.clst = DATA.clst;C.bmc = 0;C.mahal(1) = fit.eckercluster.type1(1);C.mahal(2) = fit.eckercluster.type2(1);C.mahal(3) = fit.eckercluster.SU(1);C.mahal(4) = 0;C.eDistance = fit.D;C.ctime = now;C.shape = 3;DATA.usegmcid = 1;  %plot results according to GM clusteringdetails.newDATA = 0;C.cluster = 1;C.ncut = length(DATA.clid);C.nspks = length(DATA.clst);C = rmfields(C,'jamescluster');C.autocutmode = 'ecker';C.ctime = now;function bestfit = ChooseBestFit(fits)AllD = {};for j = 1:length(fits)    if isfield(fits{j},'bestscores')        best(j,1:length(fits{j}.bestscores)) = sort(fits{j}.bestscores,'descend');        AllD{j} = fits{j}.D;    endendb = [];score = zeros(1,size(best,1));for j = 1:size(best,2)    [a(j), b(j)] = max(best(:,j));    if(a(j) > 2.5)        score(b(j)) = score(b(j)) + (size(best,2)-j);    endendif isempty(b) %no fits worked    bestfit = fits{1};    bestfit.bestfit = 1;elseif length(b) ==1 || b(1) == b(2)    bestfit = fits{b(1)};    bestfit.bestfit = b(1);else    [a,c] = max(score);    bestfit = fits{c};    bestfit.bestfit = c;endbestfit.eckercluster.AllD = AllD;function K = TryKalman(DATA, S, space, varargin)K = [];dozscore = 0;j = 1;while j <= length(varargin)    if strcmp(varargin{j},'zscore')        dozscore = 1;    end    j = j+1;endif diff(size(S)) < 0    S = S';endif dozscore    S = zscore(S);endsx = std(S,[],2);id = find(~isnan(sx) & sx > 0); %remove empty rowsS = S(id,:);K.fitspace = space;try    DATA.usegmcid = 1;    %might wadnt to try 'blocksize' arg too    [a,b,c] = MoKsm_agb(S);%make sure cl=1 is MU if poss, to be like manual %if all SU or all NOT SU, find probably mu    if ~sum(c.SU ==0) || ~sum(c.SU ==1)  %something is probably mu. Make most likely candidate 1        [a,c] = SetClusterOrder(a,c,DATA);    elseif sum(c.SU ==1) == 1 && sum(c.SU ==0) ==1 %check for switch        [a,c] = SetClusterOrder(a,c,DATA);    end        if ~isempty(c.SU) && c.SU(1) == 1 && sum(c.SU ==0)        mu = find(c.SU ==0);        id = find(a == mu(1));        a(a == 1) = mu(1);        a(id) = 1;        c.SU(1) = 0;        c.SU(mu(1)) = 1;    end    DATA.gmcid = a;    C = DATA.cluster;    C.next = {};    C.space = space;    X = AllV.CalcMyDistanceMatrix(DATA,C);    K.D = X.D;    K.bestscores = X.bestscores;    K.space = X.space;    K.SU = c.SU;    K.eckercluster = c;    K.clst = a;    cls = unique(a);    for j = cls(:)';        K.isolation(j,:) = CalcIsolation(S',a,j);    endcatch    cprintf('red','Error Doing Kalman Filter cut on probe %d\n',DATA.probe);    K.clst = ones(size(DATA.pcs,1),1);    K.eckercluster.type1 = [NaN NaN];    K.eckercluster.type2 = [NaN NaN];    K.eckercluster.SU=0;    K.D = [];    K.bestscores = [];endfunction [a,cout] = SetClusterOrder(a,c,DATA)     cout = c;     E = sum(DATA.energy(ismember(DATA.eprobe,DATA.probe),:),1);     for j  = 1:length(unique(a));         sid = find(a== j);         ctrig(j) = nanmean(DATA.rV(sid));         energy(j) = nanmean(E(sid));     end     [mintrig,mu] =  min(energy);     if mu ~= 1         sid = find(a==1);         a(a == mu) = 1;         a(sid) = mu;         cout.SU(1) = c.SU(mu);         cout.SU(mu) = c.SU(1);     end