function [SSD, details ] = MinimiseEllipseb(params, DATA, state)%[SSD, details ] = AllV.MinimiseEllipseb(params, DATA, state)%find ellipze that maximizes separation of 2 Gaussian fits in 1d%does not allow change to ellipse aspectratiocx = params(1);cy = params(2);if length(params) == 2    rx = state.rx;    ry = state.ry;    a = state.angle;elseif length(params) == 4rx = params(3);ry = params(3) * state.initialar;a = params(4);endxy = DATA.xy{state.cluster};xys = xyrotate(xy(:,1)-cx,(xy(:,2)-cy) ./state.aspectratio,a);r = ((xys(:,1))./rx).^2 + ((xys(:,2))./(ry./state.aspectratio)).^2;%r = AllV.Rprime(r);if isfield(state,'finished')    details.r = r;enddetails.r = r;C = DATA.cluster;C.shape(1) = 0; if isfield(state,'type') && strncmp(state.type,'mahaldprime',8)     C.clst(r < 1) = 2;     C.clst(r >= 1) = 1;     x = CalcIsolation(xy, C.clst,2);     dp = mean(x(1:2));     if strcmp(state.type,'mahaldprimesu')         SSD = 1/x(1);     else         SSD = 1/dp;     end else[dp, fits, fdetails] = AllV.Fit2Gauss(C, r, DATA);%don't just fit on traditional dprime.  If noise is far away, can%pay to find samll sd for cluster, even by putting boundary in the%middle of the clusterif isempty(fits{1}) || isempty(fits{2})    SSD = 1e10;elsedpa = (1 - fits{1}.mean)./fits{1}.sd;dpb = (fits{2}.mean-1)./fits{2}.sd;details.fits = fits;details.x = fdetails.x;if isfield(state,'finished')    details.xrange = fdetails.xrange;    details.nbins = fdetails.nbins;end%%if mintype == 1 don't just sum. Favor the smaller number, If one dp is large, don' t let improvements%in that swamp the smaller one%if mintype == 2, just use whichever dp is the worst. Otherwise can do%funny things to make dp for inside ellispe very good, and allow dp for%outsiders to be much owrks%mintype = 3. Use fitted values at bounary, relative to amplitude. So its%minimizing the "dip"if state.mintype == 1    dp = -(sqrt(dpa)+sqrt(dpb)).^2;elseif state.mintype == 2    dp = -min([dpa./sqrt(fits{1}.amp) dpb./sqrt(fits{2}.amp)]);elseif state.mintype == 3      if ~isfield(fits{1},'fitted') || ~isfield(fits{2},'fitted')          dp = 1e6;      else          dp = fits{1}.fitted(end)./sqrt(fits{1}.amp)+fits{2}.fitted(1)./sqrt(fits{2}.amp);          dp = (fits{1}.fitted(end)+fits{2}.fitted(1))./min([fits{1}.amp fits{2}.amp]);%          dp = -dp;      end else    dp = -(dpa+dpb);endif dpa < 0 || dpb < 0    if state.mintype == 3        SSD = 1e6;    else        SSD = 0;    endelse    SSD = dp; endendif abs(imag(SSD)) > abs(SSD)/1000 %shouldn't happen    SSDend endfitparams = getappdata(DATA.toplevel,'fitparams');fitparams = [fitparams; [params dp]];setappdata(DATA.toplevel,'fitparams',fitparams);rhist = histc(r,linspace(0, max(r)));fithists = getappdata(DATA.toplevel,'fithists');fithists = cat(2,fithists,rhist);setappdata(DATA.toplevel,'fithists',fithists);