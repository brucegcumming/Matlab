function [DATA, E] = OptimizeBoundary(DATA);    C = AllV.OptimizeClusterBoundary(DATA);%    DataClusters{DATA.probe(1)}.angle = C.angle;%    DataClusters{DATA.probe(1)}.crit = C.crit;    if DATA.currentcluster > 1        c = DATA.currentcluster-1;        DATA.cluster.next{c}.angle = C.angle;        DATA.cluster.next{c}.crit = C.crit;        DATA.cluster.next{c}.sign = C.sign;        if isfield(C,'xyr')            DATA.cluster.next{c}.xyr = C.xyr;        end        DATA.cluster.next{c}.manual = 3;        DATA.cluster.next{c}.y = C.y;        DATA.cluster.next{c}.fitdprime = C.fitdprime;    else        DATA.cluster.angle = C.angle;        DATA.cluster.crit = C.crit;        DATA.cluster.sign = C.sign;        if isfield(C,'xyr')            DATA.cluster.xyr = C.xyr;        end        DATA.cluster.manual = 3;        DATA.cluster.y = C.y;        if isfield(C,'fitdprime')        DATA.cluster.fitdprime = C.fitdprime;        end    end    E = AllV.BoundaryFromCluster([],DATA.cluster, DATA.currentcluster);    [cl, cluster, DATA.xy{1}] = AllV.ClassifySpikes(DATA,DATA.cluster,DATA.quickcutmode);    if isfield(cluster,'sign')        E.sign = cluster.sign;    end    if isfield(cluster,'fitdpparams')        E.fitdpparams = cluster.fitdpparams;        E.fitdprime = cluster.fitdprime;    end    DATA.cluster = cluster;    DATA.clid = cl.id;    DATA.nid = cl.nid;    DATA.clst = cl.clst;    