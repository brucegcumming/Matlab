function [res, varargout] = AllVPcs(V, varargin)%AllVPcs(V, ...)  takes an MxN matrix (electrode by voltage) of continuous%voltages, extracts segments triggered off one row, and plots PCS.%  V can also be a filename of a FullV file.  Will only load if new. %%AllVPcs(V,'tchan',c,..    uses Channel c to find trigger points.%AllVPcs(V,'tchan',c,'reclassify')  uses saved clustering and exaclty%recaptiulates%AllVPcs(V,'tchan',c,'reapply')  uses saved clustering parameters, but%appies them to new data (e.g. changes in trigger, new probe).%AllVPcs(V,'tchan',c,'reapply', Clusters{p}) uses cluster given %AllVPcs(V,'tchan',c,'usecluster') Doesn't recalculate space. Just usesAuto%                    times and classifications from ClusterTimes%AllVPcs(V,'tchan',c,'usecluster', force) uses a list of time indices%        in 'force' as the event list. If force is a strcutre, then%        force.tid gives time indices%        force.clst gives classification%%AllVPcs(name, 'tchan', c, 'refcut')    Applies the cluster defined in RefClusters.mat, if no cluster is yet defined%AllVPcs(name, 'tchan', c, 'refclusterforce') forces application of cluster defined in RefClusters.mat;%%AllVPcs(V, 'tchan',c,'trigdt') or AllV.AllVPcs(V, 'tchan',c,'dtthr')  trigggers off dVdt%AllVPcs(V, 'tchan',c,'dtthr2') Triggers off second temporal derivative%%AllVPcs(V, 'tchan',c,'dtthr3') Triggers off energy.  N.B. This is dagnerous, because %  of an attempt to align spikes. The trigger point is moved to the nearest max (th+) or min (th-)%  in the voltage record.  The means that the histogram of trigger values is altered (measures energy at the new%  trigger point, whihc is different, so no longer get a hard edge to the histogram.%   ....'dtthr3','thboth') disables the voltage alignment so that the tirgger values are correct%  but this can produce artifactual clustering...%%%AllVPcs(V, 'tchan',c, 'triggertemplate', Clusters{p}) convolves trgger%    channel with template in cluster, triggers on peaks%%%AllVPcs(V, 'tchan',c,'pcchan',P)  uses the channels defined in vector P%  to build PCA scores, and summed template scores. Make the second element%  of P your trigger channel - plots by probe are P(2) vs P(1) and P(2) vs%  P(end)%%AllVPcs(V, 'tchan',c,'smooth', sigma)  Smooths the trigger channel with a%Gaussain before triggering. NB this smoothing is NOT applied to the data%then used after triggering. %%By default, AllV.AllVPcs only includes events that happened in a trial%        (+pre/postperiod). To include more events:%...,'usealltrials') includes trials terminated by badfix etc%...,'allspikes')  includes all spikes, ignoring teh expt%       (But be sure teh FullV has everything , ProcessGridFullV(...,'nochopfile'%AllVPcs(V, 'tchan',c,%to build the V file, use MakeProbeIndex to build a list of files% then u%            FullV =% %% PlotSpikeC(files,5,'probes',probelist,'sumv','submean','makev');% to make FullV, the strucutre then used by AllV.AllVPcs%BuildAllFullV calls this for all expts% to fix try% calculateing energy/spkvar for all probes is silly. Wastes memory and% time.%%  Isues to explore. M170 Expt1 Bestspace mahal is 5 but and bmc is 00.32.%  But bmc for PC 1,2 is 0.33.  Is this really the best space? check out%  mahal distances for 1 and 2 D here. THE PC plot is a funny one witha%  ring, and the cluster is stronges on other probes, so may not be soo%  important.  th(1) = 0;setnspk = 0;DATA.addmean = 0; %New default Jan 2012. Add mean back just in avg.ispk = 0;DATA.logfid = -1;%Save memory if load FullV as int and leave them  as ints.  If this causes%trouble, setting convertarg to 'convert' forces conversion to doulbe at%load timeconvertarg = {'noconvert'};nprobepc = 1; % number of probes to include in in pc calculationDATA.clplot = 0; %1 for density plotplottype = 1; %plots made on first pass Could probably be 0 now...plotv = 0;  %plot spikes superimposed on full voltage trace.clusterprops = [];spts = [];gettrigtimes = 0;smoothsd = 0; %smoothing just for trigger criterionsmoothv = 0; %smoothing of all traces for subsequent processingsubtractadj = 0; %subtract off addjacent channeldtryall = [1 0 0 0]; %default set of CSD/dvdt combinations to usedvdts = [0 1 0 0];csds = [0 0 1 2];rejectbydiff = 0;calcdistancematrix = 0;savedistancematrix = 0;DATA.idstr = '';DATA.dvdt = 0;DATA.plotdvdt = 0;DATA.tag.Expt = 'ExptFig';DATA.plot.dprimemin = 0;DATA.plot.xcorrtype = 'xcorr';DATA.plot.labelwithid = 0;DATA.autocutmode = 'mahal';DATA.autorefine = 0;DATA.csd = 0;DATA.dvdy = 0;DATA.ncomponents =2;DATA.name = [];  %directory for current cellDATA.fullvname = []; %full V filename, current exptDATA.plotspk.probes = [];DATA.plotspk.bytrial = 1;DATA.plotspk.allprobes = 0;DATA.plotspk.showmean = 0;DATA.plotspk.showfullv = 0;DATA.plotspk.nfullvprobes = 1;DATA.plotspk.includeprepost = 0;DATA.plotspk.oneprobe = 0;DATA.savetrigger = 0;DATA.cutmode = 'manual';DATA.plottype = 1;DATA.hanldes = [];DATA.ptsz = [1 1];DATA.comparecell = [];DATA.usealltrials = 0;%1 PCS  2-ADCvals  3-template%10-ICSDATA.tmpnorm = 1;DATA.plot.xcorr = 0;DATA.plot.expt = 0;DATA.plot.expttype = 'means';DATA.plot.exptfit = 0;DATA.plot.scaledensity = 0;DATA.plot.meantype = 'image+lines';DATA.plot.comparemean = 0;DATA.hidecluster = 0;DATA.vsmps = [20 6 15 11 30 20];DATA.currentcluster = 1;DATA.autofit.maxthriter = 0; %max number of iterations lowering thresholdDATA.usebmi = 0; %now do evertyhing on GM fit. Calculating old indices wastes a lot of timeDATA.lastcut = [];DATA.SpaceTypes = {'Pcs' 'VarE'  'RawV' 'Template'};DATA.elmousept.down = 0;DATA.elmousept.shape = -1;DATA.elmousept.handles = [];DATA.templatecluster = 1;DATA.vsep = 4;DATA.user = GetUserName();DATA.readlayout = 0;DATA.loadedClusterDetails = 0;prefsdir = '/bgc/group/matlab/preferences/AllVPcs';DATA.gui.prefsidr = prefsdir;DATA.layoutfile = [];DATA.configfile = [];DATA.plot.isi = 0;DATA.plot.xyseq = 0;DATA.plot.vare = 0; %Show Var/Energy  plotDATA.plot.covar = 0; %plot covariance matrixDATA.plot.xcorrprobes = 0;DATA.subtractmeanV = 0;DATA.isicheck = [20 3];DATA.exptno = 0;DATA.version = 1.11;DATA.progname = ['AllVPcs ' num2str(DATA.version)];DATA.trigdt = 0;DATA.maintitle=-1;DATA.clustericon = -1;DATA.clustersubdir = [];DATA.quickcutmode.fit1cut = 0;DATA.quickcutmode.fit2gauss = 1;DATA.quickcutmode.fitallcut = 0;DATA.quickcutmode.quickest = 0;DATA.quickcutmode.plotspikes = 1;DATA.quickcutmode.dropi = 0;DATA.quickcutmode.mean = 0;DATA.quickcutmode.triggerhist = 1;DATA.quickcutmode.dips = 0;DATA.auto.savexy = 1;DATA.auto.backupcluster = 1;DATA.fullvswitchmode.summary = 0;DATA.iteratefit = 0;DATA.interactive = 0;DATA.expttype = 'Default';DATA.auto.advanceprobe = 0;DATA.auto.advanceexpt = 0;DATA.auto.saveref = 0;DATA.auto.checkxcorr = 0; %check xcorr for cl1/2 if bothDATA.auto.uselastcluster = 0;DATA.auto.replotcluster = 0;DATA.auto.checkcluster = 1;DATA.auto.showxysaved =0;DATA.auto.quickcut=0;DATA.auto.trigstats = 0;DATA.checkclusters = 1;DATA.check.dropi = [0 2.5];DATA.probelabel = [];DATA.setspkrate = 0;DATA.refinemode = 'cautious';DATA.LastClusters = {};DATA.Comments = [];DATA.ncelltotry = [5 3];DATA.verbose  =0;DATA.errs = {};DATA.errstates = {};DATA.saveallspikes = 1;DATA.ArrayConfig = [];DATA.xyplot.density = 0;DATA.errpopup = 0;DATA.strictscaling = 0;Expts = {};forcetrigger = 0;forceevec = 0;forceeventlist = [];matcheventcounts = 0;fixerrs = 0;plotsummary = 0;DATA.StdTemplate(1,:) = [    -0.1054   -0.1231   -0.1500   -0.2199   -0.4136   -0.7840 ...      -1.2472   -1.6826   -1.8786   -1.6787   -1.2104   -0.6746   -0.2085    0.1502 ...          0.4361    0.6637    0.8064    0.8326    0.7798    0.7036    0.6378    0.5895 ...             0.5435    0.5011    0.4573    0.4182    0.3855    0.3550    0.3323...             0.3 0.27 0.24 0.21 0.19 0.17 0.15 0.14 0.13 0.12 0.11]; DATA.StdTemplate(2,:) = [ -0.036 0.058 0.351 0.804 1.108 0.712 -0.372 -1.346 -1.804 -1.445 0.000 0.700 1.000 0.800 0.650 0.540 0.450 0.400 0.350 0.300 0.250 0.218 0.173 0.139 0.108 0.081 0.064 0.049 0.042 0.035 0.031 0.026 0.022 0.022 0.018 0.014 0.010 0.011 0.012 0.010 ];DATA.StdTemplate(3,:) = [ -0.036 0.058 0.351 0.804 1.108 0.712 -0.372 -1.346 -1.804 -1.445 0.000 0.700 1.000 0.800 0.650 0.540 0.450 0.400 0.350 0.300 0.250 0.218 0.173 0.139 0.108 0.081 0.064 0.049 0.042 0.035 0.031 0.026 0.022 0.022 0.018 0.014 0.010 0.011 0.012 0.010 ];DATA.usestdtemplates = 0;DATA.TemplateUsed = [];DATA.Template = [];DATA.RefClusters = {};thsign = 0;calcpconly = 0;calcclscores = 0;muscale = 1;newdata = 0;addch = 0;minenergy = 0;minvar = 0;oldscores = 0;oldcluster = 0;unsafetosave = 0;newdata = 0;DATA.nolog = 0;saveautocut = 0;readclusterfromlog = 0;DATA.trigtimes = {};DATA.artifacttimes = [];DATA.savespikes = 0;DATA.watcharg = {};DATA.watchplots = 1;DATA.profligate = 0;DATA.keepsmooth = 0;DATA.gui.fontsize(1) = 14;DATA.gui.spikeVoverlap = 0.02;DATA.usegmcid = 0;DATA.restricttimerange = [];DATA.excludetrialids = [];DATA.colors{1} = [0.5 0.5 0.5];DATA.colors {2} = [1 0 0];DATA.colors {3} = [0 1 0];DATA.colors {4} = [0 0 1];DATA.colors {5} = [1 0 1];DATA.colors {6} = [1 1 0];DATA.colors {7} = [0 1 1];DATA.colors {8} = [0 1 0];DATA.colors {9} = [0 1 0];DATA.preperiod = 0.05;DATA.postperiod = 0.1;DATA.usetrials = 1;DATA.tag.vhist = 'Vhist';DATA.tag.spikes = 'Spikes';DATA.tag.allspikes = 'AllSpikes';DATA.tag.allxy = 'AllXY';DATA.tag.hist = 'Hist';DATA.tag.probeselect = 'ProbeSelect';DATA.tag.top = 'PCs';DATA.tag.tmplscore = 'TemplateScores';DATA.tag.vare = 'VarE';DATA.tag.meanspike = 'MeanSpike';DATA.tag.covar = 'Covar';DATA.tag.dips = 'Dips';DATA.tag.xcorr = 'Xcorrs';DATA.tag.oldxy = 'previousXY';DATA.tag.comparexy = 'CompareXY';DATA.tag.preferences = 'Preferences';DATA.probeswitchmode = 'reapply';DATA.probe = 0; % if no fields, tests cause errorsDATA.tag.allxy = 'AllXY';DATA.tag.celllist = 'AllCellList';DATA.tag.fullv = 'FullV';DATA.tag.comments = 'AllVcomment';DATA.profiling = 0;DATA.hostname = gethostname;DATA.defaultconfig = [prefsdir '/' DATA.hostname '.' GetUserName '.config'];DATA.defaultlayout = [prefsdir '/' DATA.hostname '.' GetUserName '.layout.mat'];DATA.plotrv = 0;useguidata = 0;useoldlst = 0;userefcluster = 0;checklast = 1;reclassifyall = 0;refineall = 0;saveclusters = 0;spkrate = 50;autocutone = 0;forcecluster = 0;forceclusterexpt = 0;maxspksallowed = 600000;maxspikeset = NaN;maxrate = NaN;recluster = 0;refinecluster = 0;vt = [];plotdprimemax = 0;  %old way to find boundaries. Really no good.bmcrit = 0.21;verbose = 1;DATA.cstarttime = now;oldxyloaded = 0;loadfromspikes = 0;keeptrigger = 1;spoolspikes = 0;forcedrive = 'C:/bgc/data';forcedrive = [];forcename = [];fullVname = [];errs = {};nerr = 0;DATA.showerrs = 0;DATA.showdipvals = 0;tt = [];tt = AllV.TimeMark(tt,'Start',DATA.profiling);if length(varargin) & strcmp(varargin{end},'autocutall')    autocutall = 1;    autocutarg = length(varargin);else    autocutall = 0;endworker = mygetCurrentTask();callstring = [];j = 1;while j <= length(varargin)  %some varags must be parsed first    if isnumeric(varargin{j});        if length(varargin{j}) > 2            callstring = [callstring ' ' num2str(varargin{j}(1)) ':' num2str(varargin{j}(end))];        else            callstring = [callstring ' ' num2str(varargin{j})];        end    elseif ischar(varargin{j})        callstring = [callstring ' ' varargin{j}];    elseif isstruct(varargin{j})        if isfield(varargin{j},'probe')            callstring = [callstring 'Clusters{' num2str(varargin{j}.probe) '}'];        end    end    if strcmp(varargin{j},'drive')        j = j+1;        if length(varargin{j}) <= 2            if exist('Vall','var')                if Vall.name(2) == ':';                    Vall.name = [varargin{j} Vall.name(3:end)];                else                    Vall.name = [varargin{j} Vall.name];                end            end        else            forcedrive = varargin{j};        end    elseif strncmp(varargin{j},'Expts',5)        j = j+1;        Expts = varargin{j};    elseif strncmp(varargin{j},'Expt',4)        j = j+1;        DATA.Expt = varargin{j};    elseif strncmpi(varargin{j},'exptname',7)        j = j+1;        DATA.exptname = varargin{j};    elseif strncmpi(varargin{j},'Gridonline',8)        DATA.DataType = 'GridData 96';        DATA.expttype = 'gridonline';    elseif strncmpi(varargin{j},'GridData',5)        DATA.DataType = 'GridData 96';    elseif strncmpi(varargin{j},'name',4)        j = j+1;        forcename = varargin{j};    elseif strncmpi(varargin{j},'highpass',6)        convertarg = {convertarg{:} varargin{j} varargin{j+1}};        j = j+1;1;        DATA.keepsmooth = 1;    elseif strncmp(varargin{j},'noninteract',7)        DATA.interactive = -1;        DATA.checkclusters = 0;        DATA.auto.trigstats = 1;        fprintf('Worker %d Nonintereactive',worker.ID);    elseif strncmpi(varargin{j},'trigstats',6)        DATA.auto.trigstats = 1;    elseif strncmpi(varargin{j},'toplevel',6)        j = j+1;        DATA.toplevel = varargin{j};    elseif strncmp(varargin{j},'tchan',5)        j = j+1;        DATA.probe = varargin{j};        ispk = varargin{j};    elseif strncmpi(varargin{j},'toptag',6)        j = j+1;        DATA.tag.top = varargin{j};    elseif strncmp(varargin{j},'usealltrials',7)        DATA.usealltrials = 1;    elseif strncmp(varargin{j},'verbose',4)        verbose = 2;        DATA.verbose = 2;    end    j = j+1;endit = findobj('tag','PCs','type','figure');if ~isempty(it)    X = get(it,'UserData');    if isfield(X,'profiling')        DATA.profiling = X.profiling;    end    if DATA.profiling > 1        profile on;        tt = AllV.TimeMark(tt,'Profile ON',1);    endendif ischar(V)    if strcmp(V,'nowarn');        warning('off','stats:gmdistribution:FailedToConverge');        warning('off','stats:gmdistribution:MaxIterations');        return;    end    if strcmp(V,'quickop'); %timesaver for working on a new routine.        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        AllV.PCCluster(DATA,[],'PCmultiple');        return;    end    if strncmp(V,'tmplspace',8) %set space for manual ND auto cut        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        DATA.tmplspace(2,1:length(varargin{1})) = varargin{1};        if length(varargin) > 1 && isnumeric(varargin{2})            DATA.ncelltotry = varargin{2}; %number os GM clusters to trya, and which ond to use tof plotting points        end        fprintf('Dimensions are:\n');        for k = 1:length(DATA.TemplateLabels)            fprintf('%d: %s\n',k,DATA.TemplateLabels{k});        end        if strncmp(V,'tmplspacefit',11)           AllV.PCCluster(DATA,[], 'NCellTemplate');        else            set(DATA.toplevel,'UserData',DATA);        end        return;    end    if strncmp(V,'plottrial',8);        id = varargin{1};        it = findobj('type','figure','tag',DATA.tag.top);        DATA = get(it,'UserData');        if strncmp(V,'plottrialtime',13)            DATA.onespiketime = id;            tid = find([DATA.Expt.Trials.Start] < id);            if isempty(tid)                tid = find([DATA.Expt.Trials.End] > id);                id = tid(1);            else                id = tid(end);            end        end        [DATA.currenttrial, DATA.spklst] = AllV.PlotTrialSpikes(DATA,id,'showall');        tic;        set(DATA.toplevel,'UserData',DATA);        return;    end    if exist(V,'file')        fullVname = V;        toplevel = findobj('type','figure','tag',DATA.tag.top);        if isempty(toplevel)            X.fullvname = '';            b = 'NOFILE';        else            X = get(toplevel,'UserData');            b = regexprep(X.fullvname,'\.p[0-9]*FullV','FullV');        end        a = regexprep(V,'\.p[0-9]*FullV','FullV');        if strcmp(V,X.fullvname) && isappdata(toplevel,'Vall')            DATA = AllV.GetGuiState(DATA, toplevel);            Vall = getappdata(toplevel, 'Vall');            DATA.Expt = X.Expt;            DATA.name = X.name;            DATA.interval = X.interval;            DATA.fullvname = X.fullvname;            newdata = 2;        elseif strcmp(a,b) && isappdata(toplevel,'Vall')            DATA = AllV.GetGuiState(DATA, toplevel);            if verbose > 1                fprintf('%s Loading %s\n',AllV.IDStr(DATA,V));            end            FullV = LoadFullV(V, convertarg{:});            if verbose > 1                fprintf('Loaded %s\n',AllV.IDStr(DATA,V));            end            FullV = AllV.SetFullVNames(DATA, FullV);            DATA.Expt = X.Expt;            DATA.name = X.name;            DATA.interval = X.interval;            DATA.fullvname = fullVname;            V = FullV;            clear FullV;        elseif 1 || ~autocutall %need this for autocutall too            DATA.fullvname = V;            tt = AllV.TimeMark(tt,sprintf('Loading %s (No GUI)',fullVname),1);            %fi figure is already up, clear existing Full first to reduce memory use            if length(toplevel) == 1                 if isappdata(toplevel,'Vall')                rmappdata(toplevel,'Vall');                end                if isappdata(toplevel,'ClusterDetails')                rmappdata(toplevel,'ClusterDetails');                end                DATA.loadedClusterDetails = 0;            end            if verbose                tic;                fprintf('Loading %s %s',fullVname,datestr(now,'HHMM:ss'));            end            FullV = LoadFullV(V, convertarg{:});            FullV = AllV.SetFullVNames(DATA, FullV);                if verbose                fprintf(' took %.2f (%d bytes/sec)\n',toc,FullV.readrate);            end            maxl = size(FullV.V,2)-32;            chspk = 1:size(FullV.V,1);            V = FullV;            clear FullV;        else            Vall = V;        end        clear X;    elseif strfind(V,'Spikes') %load AllV from SpikeFiles        loadfromspikes = 1;    else         it = findobj('tag',V,'type','figure');        if length(it) == 1        F = AllV.SetFigure(V);        DATA = get(F,'UserData');        Vall = getappdata(F,'Vall');        vt = DATA.t;        else            mycprintf('errors','Can''t Find %s\n',V);            return;        end    endendDATA.loadfromspikes = loadfromspikes;if loadfromspikes    nprobepc = -1; %use DATA.chspk    DATA.name = V;    DATA.fullvname = '';    clear V;    [DATA, V] = AllV.ReadSpikeFiles(DATA, DATA.name);    tt = AllV.TimeMark(tt, sprintf('Loaded Spikes ',mytoc(tt(1).time)),DATA.profiling);endif isstruct(V)    newdata = 1;    Vall = V;    if isfield(Vall,'loadname')        [a,fname] = fileparts(Vall.name);        DATA.name = [fileparts(Vall.loadname)];        if size(Vall.V,1) ==1            p = AllV.GetProbeFromName(Vall.loadname);            if p > 0 && ispk(1) > 0 && p ~= ispk(1);                newname = sprintf('%s/Expt%d.p%dFullV.mat',DATA.name,Vall.exptno,ispk(1));                fprintf('Loading %s\n',newname);                Vall = LoadFullV(newname,convertarg{:});            end        end    else        DATA.name = Vall.name;    end        if isfield(V,'Spikes')    elseif ~isfield(Vall,'V') || isempty(Vall.V)        return;    elseif isinteger(Vall.V) && strcmp(convertarg{1},'convert');        fprintf('Vall Needs converting -> double\n');        Vall.V = double(Vall.V) .* Vall.intscale(1)/Vall.intscale(2);    end%new data but figure is already up,     if DATA.interactive >= 0 || ~isfield(DATA,'Expt')    DATA.Expt = [];    end    it = findobj('type','figure','tag',DATA.tag.top);    if length(it) == 1  & useguidata        DATA = get(it,'UserData');        DATA = AllV.ResetDataForNewProbe(DATA);    elseif length(it) == 1         DATA = AllV.GetGuiState(DATA, it);        DATA.toplevel = it;    end    if length(forcename)        DATA.name = forcename;    elseif length(forcedrive)        DATA.name = regexprep(DATA.name,'[A-Z]:/Spike2/data',forcedrive);        DATA.name = regexprep(DATA.name,'[A-Z]:/smr',forcedrive);    end    tt = AllV.TimeMark(tt,'Pre Expt Load',DATA.profiling);    if isfield(Vall,'exptno')        DATA.exptno = Vall.exptno;        if isempty(Expts) && isfield(DATA,'toplevel') && isfigure(DATA.toplevel) && AllV.myisappdata(DATA,'Expts')            if verbose > 1                fprintf('%s Using Expt appdata\n',AllV.IDStr(DATA));            end            Expts = AllV.mygetappdata(DATA,'Expts');        end        if length(Expts) >= Vall.exptno            DATA.Expt = Expts{Vall.exptno};        end        if DATA.interactive < 0 && isfield(DATA.Expt,'Trials')            DATA.Expt.Header.trialdur = sum([DATA.Expt.Trials.dur]);            fprintf('%s Expt already loaded\n',AllV.IDStr(DATA));        elseif isfield(DATA.Expt,'exptno') && DATA.Expt.exptno == Vall.exptno && ~isempty(Expts)            Expts = Expts;        elseif length(Expts) >= Vall.exptno            DATA.Expt = Expts{Vall.exptno};        elseif isfield(Vall,'matfile')%If there are separate .smr files for each Expt, use LoadExpt. If one .smr file for all%(Utah recordings), use LoadExptA.%Im not sure hwen onefile ever exists. But in practice drops down to exit(Vall.matfile%Could be that this is an error in the order of the arguments to strrep            onefile = strrep(Vall.matfile,'.mat',['Expt' num2str(Vall.exptno) '.mat']);            if exist(onefile,'file')                DATA.Expt = AllV.LoadExptA(DATA,onefile,0);            elseif regexp(Vall.matfile,'\.[0-9]*.mat');                DATA.Expt = AllV.LoadExptA(DATA,Vall.matfile,Vall.exptno);            elseif exist(Vall.matfile) %%Need this for Utah files                DATA.Expt = AllV.LoadExptA(DATA,Vall.matfile,Vall.exptno);                            elseif isfield(Vall,'loadname') && exist(dir2name(fileparts(Vall.loadname),'file'),'file') %%Need this for Utah files                newfile = dir2name(fileparts(Vall.loadname),'file');                AllV.AddErr(DATA,'Cant Read %s, using %s instead',Vall.matfile,newfile);                DATA.Expt = AllV.LoadExptA(DATA,newfile,Vall.exptno);                            else                [DATA.Expt, DATA.matfile] = AllV.LoadExpt(DATA,Vall.exptno);            end            if isempty(DATA.Expt)                res.error = sprintf('No Expt in %s\n',Vall.matfile);                return;            end            if isfield(DATA.Expt.Stimvals,'po') && DATA.Expt.Stimvals.po > DATA.postperiod                DATA.postperiod = DATA.Expt.Stimvals.po;                DATA.Expt.Header.postperiod = DATA.postperiod .*10000;            end            if isfield(DATA.Expt.Stimvals,'pr') && DATA.Expt.Stimvals.pr > DATA.preperiod                DATA.preperiod = DATA.Expt.Stimvals.pr;                DATA.Expt.Header.preperiod = DATA.preperiod .*10000;            end            DATA.matfile = Vall.matfile;        else            [DATA.Expt, DATA.matfile] = AllV.LoadExpt(DATA,Vall.exptno);        end    if verbose > 1        fprintf('%s Expt loaded\n',AllV.IDStr(DATA));    end    tt = AllV.TimeMark(tt,'Expt Loaded',DATA.profiling);                if isempty(DATA.Expt)            DATA.cluster.exptreadmethod = -1;%            DATA.plotspk.bytrial = 0;        elseif isfield(DATA.Expt.Header,'ReadMethod')            DATA.cluster.exptreadmethod = DATA.Expt.Header.ReadMethod;        else            DATA.cluster.exptreadmethod = 0;        end        if isfield(DATA.Expt,'Header') && isfield(DATA.Expt.Header,'DataType')            DATA.DataType = DATA.Expt.Header.DataType;        else            DATA.DataType = 'Default';        end        DATA.Expt.exptno = Vall.exptno;        DATA.Trialidlist = AllV.SetTrialList(DATA);    end    if isfield(Vall,'firstblk')        DATA.Expt.blk = Vall.firstblk;        DATA.Expt.exptno = DATA.Expt.exptno+0.1;    else        DATA.Expt.blk = 0;    end    if isfield(Vall,'start')    DATA.starttime = Vall.start;    end    if isfield(Vall,'samper')    DATA.interval = Vall.samper;    DATA.samplerate = 1./DATA.interval;    else    DATA.samplerate = 40000;    DATA.interval = 1./DATA.samplerate;    end    if isfield(Vall,'blklen')        DATA.blklen = Vall.blklen;        DATA.blkstart = Vall.blkstart;    end    DATA.args = varargin;    clear V;elseif isfigure(V)    DATA = get(V,'UserData');    Vall = AllV.mygetappdata(DATA,'Vall');    vt = DATA.t;    newdata = 2;elseif ~isfield(DATA,'name')    Vall.V = V;    newdata = 1;endif DATA.profiling    fprintf('BuildVall  %.4f\n',mytoc(tt(1).time));endif ~isdir(DATA.name)    DATA.datadir = fileparts(DATA.name);else    DATA.datadir = DATA.name;endArray = GetArrayConfig(DATA.datadir);if isempty(DATA.ArrayConfig)    DATA.ArrayConfig = Array;endif isfield(DATA,'toplevel') && isfigure(DATA.toplevel)    DataClusters = AllV.mygetappdata(DATA,'Clusters');else    DataClusters = {};endreloadfullv = 0;if exist('Vall','var') && ~ischar(Vall) && ~isempty(Vall);    if isfield(Vall,'Spikes')        DATA.nprobes = 1;        DATA.allnprobes = length(Array.X);        DATA.spkvar(DATA.probe(1),:) = std(double(Vall.Spikes.values),[],2);        chspk = 1:DATA.allnprobes;    elseif DATA.loadfromspikes  && DATA.exptno ~= Vall.exptno        reloadfullv = 1;    else        maxl = size(Vall.V,2)-32;        chspk = 1:size(Vall.V,1);        DATA.nprobes = size(Vall.V,1);        DATA.exptno = Vall.exptno;        DATA.samplerate = 1./Vall.samper;        DATA.allnprobes = DATA.nprobes;    end    if isfield(Vall,'NSlabel')        DATA.probelabel = deblank(Vall.NSlabel);    end    if strncmp(DATA.DataType,'GridData',6)        DATA.allnprobes = sscanf(DATA.DataType,'GridData %d');    endendif verbose > 1    fprintf('%s Start args\n',AllV.IDStr(DATA));endaddmean = [];autocutarg = 0;passonargs = {};j = 1;while j <= length(varargin)    if iscell(varargin{j}) %do nothing. May be parsed in first run above            elseif strncmp(varargin{j},'adcplot',3)        DATA.plottype = 2;      elseif strncmp(varargin{j},'addmean',7)        addmean = 1;    elseif strncmp(varargin{j},'allspikes',5)        DATA.usetrials = 0;    elseif strncmp(varargin{j},'autocutall',10)        autocutall = 1;        autocutarg = j;    elseif strncmp(varargin{j},'quickautocutall',13)        autocutall = 2;        autocutarg = j;        DATA.autocutmode = 'quick';    elseif strncmp(varargin{j},'quickautocut',9)        autocutone = 1;        DATA.autocutmode = 'quick';    elseif strncmp(varargin{j},'automode',7)        j = j+1;        DATA.autocutmode = varargin{j};    elseif strncmp(varargin{j},'autocut',7)        autocutone = 1;    elseif strncmp(varargin{j},'checklast',8)        checklast = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'cutmode',7)        j = j+1;        DATA.autocutmode = varargin{j};    elseif strncmp(varargin{j},'distancematrix',7)        calcdistancematrix = 6;        savedistancematrix = 1;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'drive',5) %force drive letter        j = j+1;        if length(varargin{j}) == 1        if Vall.name(2) == ':';            Vall.name = [varargin{j} Vall.name(2:end)];        else            Vall.name = [varargin{j} Vall.name];        end        elseif length(varargin{j}) == 2            if Vall.name(2) == ':';                Vall.name = [varargin{j} Vall.name(3:end)];            else                Vall.name = [varargin{j} Vall.name];            end        else            forcedrive = varargin{j};        end        passonargs = {passonargs{:} varargin{j-1} varargin{j}};    elseif strncmp(varargin{j},'fontsize',6)        j = j+1;        DATA.gui.fontsize = varargin{j};    elseif strncmpi(varargin{j},'forceevec',7)        forceevec = 1;        passonargs = {passonargs{:} varargin{j}};  elseif strncmp(varargin{j},'forcetrigger',7)        j = j+1;        forcetrigger = varargin{j};    elseif strncmp(varargin{j},'fixerrs',5)        fixerrs = 1;    elseif strncmpi(varargin{j},'Gridonline',8)        DATA.DataType = 'GridData 96';        DATA.expttype = 'gridonline';    elseif strncmpi(varargin{j},'GridData',5)        DATA.DataType = 'GridData 96';;    elseif strncmp(varargin{j},'ignoretrials',10)        DATA.plotspk.bytrial = 0;    elseif strncmp(varargin{j},'config',5)        DATA.readlayout = 2;        if length(varargin) > j && ischar(varargin{j+1})            j = j+1;            if regexp(varargin{j},'^[A-Z]:') | strfind(varargin{j},'/') %real path                DATA.configfile = varargin{j};            else                DATA.configfile = [prefsdir '/' varargin{j} '.config'];            end        end        DATA = ReadConfig(DATA, DATA.configfile);    elseif strncmp(varargin{j},'layout',5)        DATA.readlayout = 2;         if strncmp(varargin{j},'layoutapply',8)             DATA.readlayout = 2;         end        if length(varargin) > j && ischar(varargin{j+1})            j = j+1;            if regexp(varargin{j},'^[A-Z]:') | strfind(varargin{j},'/') %real path                DATA.layoutfile = varargin{j};            else                DATA.layoutfile = [prefsdir '/' varargin{j} '.layout.mat'];            end        end    elseif strncmp(varargin{j},'newexpt',7)        j = j+1;        eid = varargin{j};        if length(varargin) > j            args = varargin(j+1:end);        else            args = {};        end        set(DATA.toplevel,'name',['Switching to Expt', num2str(eid)]);         drawnow;        p = AllV.ProbeNumber(DATA);        if DATA.loadfromspikes            name = [DATA.datadir '/Expt' num2str(eid) 'Spikes'];        elseif strncmp(DATA.DataType,'GridData',8)            name = [DATA.name '/Expt' num2str(eid) '.p' num2str(p) 'FullV.mat'];        else            name = [DATA.name '/Expt' num2str(eid) 'FullV.mat'];        end        if isappdata(DATA.toplevel,'Vall')            rmappdata(DATA.toplevel,'Vall');        end        if isappdata(DATA.toplevel,'ClusterDetails')            rmappdata(DATA.toplevel,'ClusterDetails');        end        clear Vall;        DATA.trigtimes = {};        if DATA.loadfromspikes            AllV.AllVPcs(name, 'tchan', p, args{:});            SetFigureName(DATA.toplevel,DATA.tag.top);            return;        end        if ~exist(name)             fprintf('%s Does Not Exist\n',name);            return;        end        if DATA.auto.uselastcluster            args = {args{:} DATA.LastClusters{p}};        end        FullV = LoadFullV(name, convertarg{:});        FullV = AllV.SetFullVNames(DATA, FullV);        fprintf('Loading %s took  %.2f (%.2f disk) %.1fMb\n',name,FullV.loadtime,FullV.initialloadtime,FullV.size);        AllV.AllVPcs(FullV, 'tchan', p, args{:});        clear FullV;        SetFigureName(DATA.toplevel,DATA.tag.top);         return;    elseif strncmp(varargin{j},'nomean',5)        addmean = 0;    elseif strncmp(varargin{j},'noninteract',7)        DATA.interactive = -1;        %figure('visible','off');        DATA.watchplots = 0;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'nocheck',5)        checklast = 0;        DATA.checkclusters = 0;    elseif strncmp(varargin{j},'nolog',5)        DATA.nolog = 1;    elseif strncmp(varargin{j},'ncomponents',6)        j = j+1;        DATA.ncomponents = varargin{j};    elseif strncmp(varargin{j},'ptsz',4)        j = j+1;        DATA.ptsz = varargin{j};        if length(DATA.ptsz) ==1            DATA.ptsz(2) = DATA.ptsz(1);        end    elseif strncmp(varargin{j},'refineall',9)         if length(varargin) > j && iscell(varargin{j+1})            j = j+1;            UseClusters = varargin{j};        else            UseClusters = {};        end       DATA.autorefine = 3;       refineall = 1;    elseif sum(strncmp(varargin{j},{'refclusters' 'refcut'},6)) %        j = j+1;%        rfile = varargin{j};%default is to use refcluster only on files without previous cut, or only%an autocut.  Use 'refclusterforce' to force use of the refcluster.        rfile = [DATA.name '/RefClusters.mat'];        if exist(rfile,'file')            load(rfile);            DATA.RefClusters = AllV.CondenseClusters(Clusters,0);            passonargs = {passonargs{:} varargin{j}};            if strncmp(varargin{j},'refclusterforce',11)                 userefcluster = 1;            end        end        if recluster == 0            recluster = 1;        end    elseif strncmp(varargin{j},'refinecrit',8)        j = j+1;        DATA.autorefine = varargin{j};    elseif strncmp(varargin{j},'refinemode',8)        passonargs = {passonargs{:} varargin{j} varargin{j+1}};        j = j+1;        DATA.refinemode = varargin{j};    elseif strncmp(varargin{j},'refine',6)        refinecluster = 1;        DATA.autorefine = 3; %only refine in origninal scluster dp > 3        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            DATA.autorefine = varargin{j};        elseif forcecluster ==1            DATA.autorefine = 0.1; %if only named 1 cluster, force refine        end    elseif strncmp(varargin{j},'strict',6)        DATA.strictscaling = 1;    elseif strncmp(varargin{j},'submean',6)        j = j+1;        DATA.subtractmeanV = 1;        meanV = varargin{j};    elseif strncmp(varargin{j},'subdir',6)        j = j+1;        DATA.clustersubdir = varargin{j};    elseif strncmp(varargin{j},'saveautocut',10)        saveautocut = 1;    elseif strncmp(varargin{j},'savespikes',6)        saveclusters = 1;        DATA.savespikes = 1;        if strncmp(varargin{j},'savespikesonly',14) %just rebuild .spk files            saveclusters = 3;            DATA.savespikes = 3;        end        if strncmp(varargin{j},'savespikesifsafe',16)            saveclusters = 2;        end        if strncmp(varargin{j},'savespikestoman',14)            saveautocut = 2;        end        passonargs = {passonargs{:} varargin{j}};        if j ==1 && saveautocut ~= 2 && length(varargin) == 1 %savespikes lone argument  = save current GUI spikes            it = findobj('type','figure','tag',DATA.tag.top);            if length(it) == 1                DATA = get(it,'UserData');            end            if DATA.cluster.auto == 1 && DATA.recluster == 0                outname = AllV.ClusterFile(DATA.name,DATA.Expt,'auto','subdir',DATA.clustersubdir);            else                outname = AllV.ClusterFile(DATA.name,DATA.Expt,'subdir',DATA.clustersubdir);            end            DATA =  AllV.SaveClusters(DATA, outname);            AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));           return;        end    elseif strncmp(varargin{j},'savetrigger',6)        DATA.savetrigger = 1;    elseif strncmp(varargin{j},'switchmode',6)        j = j+1;        DATA.probeswitchmode = varargin{j};    elseif strncmp(varargin{j},'subtractadj',9)        subtractadj = 1;    elseif strncmp(varargin{j},'summary',6)        gettrigtimes = 2;             plotsummary = 1;        DATA.probeswitchmode = 'usecluster';    elseif strncmp(varargin{j},'density',5)        DATA.clplot = 1;    elseif strncmpi(varargin{j},'clusters',4)        if strncmpi(varargin{j},'clusterscores',10)            calcclscores = 1;        end        if length(varargin) > j & iscell(varargin{j+1})        j = j+1;        Clusters = varargin{j};        end    elseif strncmpi(varargin{j},'setcluster',4)        autocut = 1;        if length(varargin) > j && isnumeric(varargin{j+1})            j =j+1;            clusterprops = varargin{j};        end    elseif strncmpi(varargin{j},'dvdt',4)        DATA.dvdt = 1;        tryall = 0;    elseif strncmpi(varargin{j},'accel',4)        DATA.dvdt = 3;        tryall = 0;    elseif strncmpi(varargin{j},'clear',4)        muscale = 0.8;    elseif strncmpi(varargin{j},'csda',4)        DATA.csd = 2;        tryall = 0;    elseif strncmpi(varargin{j},'csd',3)        DATA.csd = 1;        tryall = 0;    elseif strncmpi(varargin{j},'logfid',6)        j = j+1;        DATA.logfid = varargin{j};    elseif strncmpi(varargin{j},'iteratefit',8)        if length(varargin) > j & isnumeric(varargin{j+1})            j = j+1;            DATA.iteratefit = varargin{j};        else            DATA.iteratefit = 1;        end    elseif strncmpi(varargin{j},'mine',4)        j = j+1;        minenergy = varargin{j};    elseif strncmpi(varargin{j},'minvar',6)        j = j+1;        minvar = varargin{j};    elseif strncmpi(varargin{j},'newdata',7)        newdata = 1;    elseif strncmpi(varargin{j},'ndive',5)        j = j+1;        DATA.autofit.maxthriter = varargin{j};    elseif strncmpi(varargin{j},'showwarn',6)        DATA.showerrs = 1;    elseif strncmpi(varargin{j},'plotrv',6)        DATA.plotrv = 1;    elseif strncmpi(varargin{j},'postperiod',6)        j = j+1;        DATA.postperiod = varargin{j};    elseif strncmpi(varargin{j},'preperiod',6)        j = j+1;        DATA.preperiod = varargin{j};    elseif strncmp(varargin{j},'tagsuff',5)        j = j+1;        DATA.tag.spikes = [DATA.tag.spikes  varargin{j}];    elseif strncmp(varargin{j},'testclassify',6)        tic;        E = AllV.BoundaryFromCluster([],DATA.cluster,1);        E.boundarytype = 0;        profile on;        AllV.PCCluster(DATA,E,1);        profile  viewer;%        AllV.ClassifySpikes(DATA,DATA.cluster,'quick');        toc;        return;    elseif strncmp(varargin{j},'tryall',5)        tryall = ones(size(csds));    elseif strncmp(varargin{j},'tchan',5)        if strncmp(varargin{j},'tchannew',7) || newdata == 2 %set earlier            newdata = 2;            DATA = AllV.ResetDataForNewProbe(DATA);        else            newdata = 1;        end        j = j+1;                if strcmp(varargin{j},'all')            ispk = 1:DATA.nprobes;        else            ispk = varargin{j};        end        if length(ispk) > 1            addch = 1;            if strncmp(varargin{j-1},'tchanuse',8)                addch = 2;            end        end        if DATA.loadfromspikes && newdata == 2            DATA.probe = ispk;            [DATA,Vall] = AllV.ReadSpikeFiles(DATA, DATA.name);        end    elseif strncmp(varargin{j},'ichan',5)        j = j+1;        ispk = varargin{j};        DATA.TemplateLabels = AllV.TemplateLabels(DATA,0);    elseif strncmp(varargin{j},'matchcounts',8)        matcheventcounts = 1;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'maxrate',6)        j = j+1;        maxrate = varargin{j};    elseif strncmp(varargin{j},'maxspikes',6)        j = j+1;        maxspikeset = varargin{j};    elseif strncmp(varargin{j},'muscale',6)        j = j+1;        muscale = varargin{j};    elseif strncmp(varargin{j},'nprobepc',6)        j = j+1;        nprobepc = varargin{j};    elseif strncmp(varargin{j},'name',4)        j = j+1;        DATA.name = varargin{j};        passonargs = {passonargs{:} varargin{j-1} varargin{j}};    elseif strncmp(varargin{j},'noplot',4)        plottype = 0;    elseif strncmp(varargin{j},'nspk',4)        j = j+1;        setnspk = varargin{j};    elseif strncmp(varargin{j},'oldcl',4)        oldcluster = 1;        if  ~isempty(DataClusters{DATA.probe(1)})            C = DataClusters{DATA.probe(1)};            if C.mine > 0                minenergy = C.mine;                th = C.th;            end        end    elseif strncmp(varargin{j},'oldt',4)        oldscores = 1;    elseif strncmp(varargin{j},'pcchan',5)        j = j+1;        chspk = varargin{j};        nprobepc = -1;    elseif strncmp(varargin{j},'plotprobes',5)        j = j+1;        DATA.plotspk.probes = varargin{j};    elseif strncmpi(varargin{j},'previous',4)        j = j+1;        DATA.lastcut = varargin{j};    elseif strncmp(varargin{j},'plotv',5)        plotv = 1;        F = findobj('Tag','PCs','Type','Figure');        if ~isempty(F)            DATA = get(F,'UserData');            AllV.PlotFullV(DATA, [0 100]);            return;        end    elseif strncmp(varargin{j},'recut',5) %recut operates on whats in DATA        DATA.cluster = DataClusters{DATA.probe(1)};        DATA.csd = DATA.cluster.csd;        DATA.dvdt = DATA.cluster.dvdt;        DATA = AllV.ReClassify(DATA,'newbound');        set(DATA.toplevel,'UserData',DATA);        return;    elseif strncmp(varargin{j},'quantifyall',11)        reclassifyall = 2;    elseif strncmp(varargin{j},'reclassifyall',13)        reclassifyall = 1;    elseif strncmp(varargin{j},'reclassify',6) %reclassify applies cluster space to new data (thr, crit, etc differen)        recluster= 2;        if length(varargin) > j && isfield(varargin{j+1},'dropi')            j = j+1;            DATA.cluster = varargin{j};            forcecluster = 1;        end    elseif strncmp(varargin{j},'readfromlog',8) %reclassify applies cluster space to new data (thr, crit, etc differen)        readclusterfromlog = 1;    elseif strncmp(varargin{j},'uselst',6) %reclassify applies cluster space to new data (thr, crit, etc differen)        useoldlst = 1;    elseif strncmp(varargin{j},'usecluster',6) %Uses cluster ids,times, does not reapply boudnary = quicker        recluster = 4;        if length(varargin) > j && (isnumeric(varargin{j+1}) || isstruct(varargin{j+1}))            j = j+1;            forceeventlist = varargin{j};        end    elseif strncmp(varargin{j},'keepcluster',6) %applies cluster exactly, using current DATA.cluster        recluster= 1;        forcecluster = 2;    elseif strncmp(varargin{j},'reapply',6) %applies cluster exactly, to whatever data is here        recluster= 1;       if strncmp(varargin{j},'reapplyall',10)           reclassifyall = 2;           DATA.auto.refine = 0;       end     if length(varargin) > j && iscell(varargin{j+1})&& isfield(varargin{j+1}{ispk(1)},'dropi')            j = j+1;            DATA.cluster = rmfields(varargin{j}{ispk(1)},'quick');            forcecluster = 1;            forceclusterexpt = DATA.cluster.exptno;            UseClusters = varargin{j};        elseif length(varargin) > j && isfield(varargin{j+1},'dropi')            j = j+1;            DATA.cluster = varargin{j};            forcecluster = 1;            forceclusterexpt = DATA.cluster.exptno;            if DATA.cluster.probe(1) ~= ispk(1)                pshift = ispk(1)-DATA.cluster.probe;                DATA.cluster.templateshift = pshift;                DATA.cluster.MeanSpike.ms =  circshift(DATA.cluster.MeanSpike.ms,pshift);                if isfield(DATA.cluster,'TemplateUsed')                DATA.cluster.TemplateUsed =  circshift(DATA.cluster.TemplateUsed,pshift);                end                DATA.cluster.probe = ispk(1);                DATA.cluster.chspk = DATA.cluster.chspk+pshift;                DATA.cluster.chspk = DATA.cluster.chspk(DATA.cluster.chspk >0 & DATA.cluster.chspk <= DATA.allnprobes);                 p = size(DATA.cluster.MeanSpike.vdprime,1);                if pshift > 0 && p > 2                    DATA.cluster.MeanSpike.vdprime(p+pshift-2:p+pshift,:) = DATA.cluster.MeanSpike.vdprime(p-2:p,:);                end                for k = 1:length(DATA.cluster.next)                    if isfield(DATA.cluster.next{k},'MeanSpiike')                    DATA.cluster.next{k}.MeanSpike.ms =  circshift(DATA.cluster.next{k}.MeanSpike.ms,pshift);                    DATA.cluster.next{k}.TemplateUsed =  circshift(DATA.cluster.next{k}.TemplateUsed,pshift);                    DATA.cluster.next{k}.probe = ispk(1);                    p = size(DATA.cluster.next{k}.MeanSpike.vdprime,1);                    if pshift > 0 && p > 2                        DATA.cluster.next{k}.MeanSpike.vdprime(p+pshift-2:p+pshift,:) = DATA.cluster.next{k}.MeanSpike.vdprime(p-2:p,:);                    end                    end                end            end            DATA.cluster = rmfields(DATA.cluster,'quick'); %if previous cut was quick, want to start over        end    elseif strncmp(varargin{j},'rejectbydiff',8)        j = j+1        rejectbydiff = varargin{j};    elseif strncmp(varargin{j},'spool',4)        spoolspikes = 1;    elseif strncmp(varargin{j},'spts',4)        j = j+1;        spts = varargin{j};    elseif strncmp(varargin{j},'vsmps',4)        j = j+1;        DATA.vsmps = varargin{j};    elseif strncmpi(varargin{j},'trigtimes',8)        gettrigtimes = 1;    elseif strncmp(varargin{j},'vsmooth',4)        j = j+1;        smoothv = varargin{j};    elseif strncmp(varargin{j},'smooth',4)        j = j+1;        smoothsd = varargin{j};    elseif strncmp(varargin{j},'spkrate',4)        j = j+1;        spkrate = varargin{j};        th = NaN;    elseif strncmp(varargin{j},'th+',3)        thsign = 1;        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end    elseif strncmp(varargin{j},'th-',3)        thsign = 0;        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end    elseif strncmp(varargin{j},'thboth',4)        thsign = 2;    elseif strncmp(varargin{j},'template',6) %reclassify applies cluster space to new data (thr, crit, etc differen)       if strncmp(varargin{j},'templateshift',12) %move template to match probe           forcecluster = 2;       end        j = j+1;        recluster= 3;        DATA.plottype = 3;        if length(varargin{j}) == 1 && ~iscell(varargin{j})            DATA.forceclusters{1} = varargin{j};        else            DATA.forceclusters = varargin{j};        end       if forcecluster == 2        for k = 1:length(DATA.forceclusters)           DATA.forceclusters{k}.MeanSpike.ms =  circshift(DATA.forceclusters{k}.MeanSpike.ms,ispk(1)-DATA.forceclusters{k}.probe);        end       end        DATA.cluster = DATA.forceclusters{1};        forcecluster = 1;        plottype = 0;    elseif strncmp(varargin{j},'bestspace',8)        AllV.PCCluster(DATA, 0, 23);        return;    elseif strncmp(varargin{j},'autobestspace',8)        AllV.PCCluster(DATA, 0, 26);        return;    elseif strncmp(varargin{j},'rpttemplate',6) %rebuild template scores, redo bestspace        AllV.TemplatePlot(DATA);        DATA = get(DATA.toplevel,'UserData');        AllV.PCCluster(DATA, 0, 23);        return;    elseif strncmp(varargin{j},'saveclusters',10)        saveclusters = 1;    elseif strncmp(varargin{j},'templateline',10)        AllV.PCCluster(DATA, 0, 6);    elseif strncmp(varargin{j},'plotold',7)        DATA.clst = DATA.oldclst;        AllV.ReplotPCs(DATA,[]);        set(DATA.toplevel,'UserData',DATA);    elseif strncmp(varargin{j},'plottemplate',8)        AllV.TemplatePlot(DATA);        DATA = get(DATA.toplevel,'UserData');    elseif strncmp(varargin{j},'dtthreshold',5)        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        end         if strncmp(varargin{j},'dtthr2',6)             DATA.trigdt = 2;         elseif strncmp(varargin{j},'dtthr3',6)             DATA.trigdt = 3;         else            DATA.trigdt = 1;         end    elseif strncmp(varargin{j},'triggertemplate',10)        if strncmp(varargin{j},'triggertemplatedt',17)            DATA.trigdt = 5;        else            DATA.trigdt = 4;        end        j = j+1;        if length(varargin{j}) == 1            if isfield(varargin{j},'MeanSpike')                DATA.TriggerTemplate = varargin{j}.MeanSpike.ms;            else                DATA.TriggerTemplate = DATA.StdTemplate(1,:);            end        else            DATA.TriggerTemplate = varargin{j};        end    elseif strncmp(varargin{j},'threshold',3)        if isnumeric(varargin{j+1})            j = j+1;            th = varargin{j};        else%            fprintf('ERRROR - Input argument ''thr'' needs a value\n');        end        DATA.trigdt = 0;    elseif strncmp(varargin{j},'verbose',4)        verbose = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'vpts',3)        DATA.plottype =2;    elseif strncmp(varargin{j},'watch',3)        DATA.watcharg{1} = 'front';        DATA.watchplots = 2;        passonargs = {passonargs{:} varargin{j}};    elseif strncmp(varargin{j},'winfront',4)        FiguresToFront(DATA.tag);    elseif strncmp(varargin{j},'nowatch',5)        DATA.watcharg = {};        DATA.watchplots = 0;    elseif strncmp(varargin{j},'xcorr',3)        DATA.plot.xcorr = 1;    end    j = j+1;endif (ispk == 0 & reclassifyall) | strcmp(DATA.probe,'all')    DATA.probe = 1:DATA.nprobes;    ispk = DATA.probe;endif DATA.profiling    fprintf('Varargs  %.4f\n',mytoc(tt(1).time));endtt = AllV.TimeMark(tt,'After varargs',DATA.profiling);if DATA.trigdt == 3  && thsign ~=2    cprintf('blue','Energy Thresholds with voltage sign are Dangerous - See help\n');endif isfield(Vall,'V')    if isfield(Vall,'t')  && abs(length(Vall.t) - size(Vall.V,2)) > 1        PrintMsg(DATA.logfid,sprintf('Error! Vall length (%d) does not match t (%d)',size(Vall.V,2),length(Vall.t)));        res.err ='time length mismatch';        return;    endendif verbose > 1    fprintf('%s Args processed at %s\n',AllV.IDStr(DATA),datestr(now,'HH:MM:SS'));endif forcecluster == 1    DATA.cluster.src.probe = DATA.cluster.probe;    DATA.cluster.src.exptno = DATA.cluster.exptno;    DATA.cluster.src.ctime = DATA.cluster.ctime;elseif forcecluster == 2    X = get(DATA.toplevel,'UserData');    DATA.cluster = X.cluster;    DATA.cluster.auto = 0;    clear X;endif isempty(DATA.fullvname) && isfield(Vall,'loadname')    DATA.fullvname = Vall.loadname;end%want this after processing varargin so that can do autocutallif autocutall    if length(forcedrive) > 2        Vall.name = regexprep(Vall.name,'[A-Z]:/Spike2/data',forcedrive);    endF = AllV.SetFigure(DATA.tag.top, DATA);DATA.toplevel = F;set(DATA.toplevel,'UserData',DATA)id = setdiff(1:length(varargin),autocutarg);res = AllV.AutoCutAll(ispk,  F, Vall, DATA, varargin(id));res.toplevel = F;res.logfid = DATA.logfid;return;endif reclassifyall == 2    args = {};        DataClusters = LoadCluster(DATA.name,DATA.exptno);        for j = 1:length(ispk)            if length(DataClusters) >= ispk(j)            C = DataClusters{ispk(j)};            needc = 0;                        if DataClusters{ispk(j)}.quick || DataClusters{ispk(j)}.trigdt == 4 || ...                    DataClusters{ispk(j)}.manual == 2 ||  DataClusters{ispk(j)}.dropi(3) == 0                needc = 1;            end            if DataClusters{ispk(j)}.auto == 1 && length(DATA.RefClusters) >= ispk(j);                needc = 1;            end            if isfield(DataClusters{ispk(j)},'needed') && DataClusters{ispk(j)}.needed                needc = 1;            end            for k = 1:length(DataClusters{ispk(j)}.next)                if ~isfield(DataClusters{ispk(j)}.next{k},'space')                    ; %do nothing                elseif (isfield(DataClusters{ispk(j)}.next{k},'quick') && DataClusters{ispk(j)}.next{k}.quick) ...                        || (isfield(DataClusters{ispk(j)}.next{k},'manual') && DataClusters{ispk(j)}.next{k}.manual == 2)...                    || DataClusters{ispk(j)}.next{k}.dropi(3) == 0                    needc = 1;                end            end            if needc == 0                DATA.probe = ispk(j);                d = dir(AllV.SpkFileName(DATA));                if isempty(d) || d.datenum < C.savetime(1)-0.01;                    fprintf('Spike File %s is older than cluster\n',d.name);                    needc = 1;                end            end            if DataClusters{ispk(j)}.trigdt == 4                DataClusters{ispk(j)}.trigdt = 0;            end            else                needc = 1;            end            if needc                fprintf('Reclassifying E%d P%d\n',DATA.exptno,ispk(j));                try                res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify',args{:});                catch ME                    cprintf('errors','AllVPCs ERROR!!! %s\n',ME.message);                    res{j}.errstate = ME;                    res{j}.err = ME.message;                    t = mygetCurrentTask();                    res{j}.workerid = t.ID;                    res{j}.errstate = ME;                end            end            res{j}.needed = needc;            res{j}.exptno = DATA.exptno;            res{j}.probes = ispk(j);        end        return;endif reclassifyall || refineall    args = {};    if userefcluster && isfield(DATA,'RefClusters')        UseClusters = DATA.RefClusters;    end    if refineall && isempty(UseClusters)        UseClusters = LoadCluster(DATA.name,DATA.exptno);    end    for j = 1:length(ispk)        try        if refineall%in this loop, want to force p to == ispk(j) regardless of Vall%if its differente, want to force loading of new V when AllV.AllVPcs is called            if size(Vall.V,1) ==1 && ispk(j) ~= Vall.chspk                p = ispk(j);            else                p = ispk(j);            end            if isfield(UseClusters{p},'space')            res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reapply',UseClusters{p},'refine', DATA.autorefine);            res{j}.refinemode = DATA.refinemode;            end        elseif reclassifyall == 2            if Clusters{ispk(j)}.quick                res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify');            end                        else            res{j} = AllV.AllVPcs(Vall, 'tchan', ispk(j), passonargs{:},'reclassify');        end        if fixerrs && res{j}.err == 1 && res{j}.auto == 1            AllV.AllVPcs(Vall,'savespikes');        end        catch ME            cprintf('errors','AllVPCs ERROR!! %s\n',ME.message);                    res{j}.err = ME.message;                    res{j}.errstate = ME;        end        res{j}.exptno = Vall.exptno;        res{j}.probes = ispk(j);%Gets existing handle from Gui now - no need to close                if 0 && isfield(res{j},'logfid') && res{j}.logfid > 2            try                fclose(res{j}.logfid);            catch                fprintf('Couldnt close handle %d\n',res{j}.logfid);            end        end        drawnow;    end    if savedistancematrix        clname = AllV.ClusterFile(DATA.name, DATA.Expt, 'DistanceMatrix');        for j = 1:length(res)            if isfield(res{j},'DistanceMatrix')                DistanceMatrix{j} = rmfields(res{j}.DistanceMatrix,'cid');            else                DistanceMatrix{j} = {};                fprintf('E%dP%d Missing Distance Matrix\n',DATA.exptno,j);            end        end        fprintf('Saving Distance Matrices to %s\n',clname);        try        save(clname,'DistanceMatrix');        catch ME            cprintf('errors','Error writing %s\n',clname);            res{1}.errstate = ME;        end    end    return;endif ~isempty(vt) && ispk(1) == 0 %Called with current figure, just to set a variable    set(DATA.toplevel,'UserData',DATA);    return;endif DATA.showerrs        warning('on','stats:gmdistribution:FailedToConverge');        warning('on','stats:gmdistribution:MaxIterations');else        warning('off','stats:gmdistribution:FailedToConverge');        warning('off','stats:gmdistribution:MaxIterations');endif isfield(Vall,'Spikes')    if isempty(DataClusters)        [DataClusters, DATA.FullVData] = AllV.LoadDataClusters(DATA);    end    DATA.duration = DataClusters{1}.duration;    DATA.probelist = 1:DATA.allnprobes;    if strncmp(DATA.DataType,'Grid',4)        DATA.probelist = DATA.probe(1);        DATA.probe = 1;        ispk = 1;    endelse    if (isempty(Vall) && isempty(DATA.fullvname)) || reloadfullv;        DATA.fullvname = regexprep(DATA.name,'(Expt[0-9]*).*','$1FullV.mat');        if DATA.interactive < 0            Vall = LoadFullV(DATA.fullvname,convertarg{:});        else            h = waitbar(0.5,sprintf('Loading %s',DATA.fullvname));            Vall = LoadFullV(DATA.fullvname,convertarg{:});            delete(h);        end        fprintf('Load took %.2f sec\n',Vall.loadtime);    end    [DATA, Vall, ispk, newdata] = AllV.SetupVall(DATA, Vall, ispk, newdata);    vt = Vall.t;endif length(ispk) > 4 && ~ autocutall    AllV.SetFigure(DATA.tag.top,DATA);    args = {};    clname = AllV.ClusterFile(DATA.name,DATA.Expt,'subdir',DATA.clustersubdir);    if exist(clname,'file')        load(clname);        if calcclscores            args = {args{:},'Clusterscores',Clusters};        end    end    [nr,nc] = Nsubplots(length(ispk));    for j = 1:length(ispk)        res{j} = AllV.AllVPcs(Vall, varargin{:},'tchan',ispk(j),'noplot',args{:});        if thsign == 2            res{j}.pres = AllV.AllVPcs(Vall, varargin{:},'tchan',ispk(j),'th+','noplot',args{:});        end        AllV.SetFigure(DATA.tag.top,DATA);        subplot(nr,nc,j);        id = [];        if DATA.interactive > 0 && isfield(res{j},'id')        AllV.PlotPCs(res{j}.pcs,1,2,DATA.clplot,res{j}.id,DATA.colors);        if DATA.showdipvals        title(sprintf('%.1f dp%.1f,%.1f',max(res{j}.dipvals)*100,res{j}.dp,res{j}.edp));        end        drawnow;        end    end    if calcclscores        hold off;        for k =1:size(res{1}.Clusterscores,1)            for j = 1:length(res)                scores(k,j,1:size(res{j}.Clusterscores,2)) = smooth(res{j}.Clusterscores(k,:),50);            end        subplot(nr,nc,k);        imagesc(squeeze(scores(k,:,:)));        end    end    if isfield(res,'dp') && DATA.interactive > 0    x = cat(1,res{:});    AllV.SetFigure('Dprimes');    hold off;    plot([x.dp]);    hold on;    plot([x.edp],'r');    if isfield(x,'pres')        p = cat(1,x.pres);        plot([x.dp],'o-');        plot([x.edp],'ro-');    end    end    return;end%Here is where the figure is created in a new call[F, isnew] = AllV.SetFigure(DATA.tag.top,DATA);DATA.toplevel = F;if ~isempty(Expts)    DATA = AllV.mysetappdata(DATA,'Expts',Expts);endif isnewif isempty(DATA.configfile)    DATA = ReadConfig(DATA,DATA.defaultconfig,'print','nochoose');endif isempty(DATA.layoutfile)    DATA.layoutfile = DATA.defaultlayout;    AllV.ApplyLayout(DATA,'print');endendres.toplevel = F;tt = AllV.TimeMark(tt, 'Laid Out ', DATA.profiling);p = AllV.ProbeNumber(DATA);if newdata %things to reset if its a new file, OR just a new probe    DATA.usegmcid = 0;         DATA.probe = ispk;        AllV.SetTrialList(DATA);        if isfield(DATA,'toplevel')        for f = {'AllCSD' 'AllVoltages'} %can clog up memory        if isappdata(DATA.toplevel,f{1})            rmappdata(DATA.toplevel,f{1});        end        end        end        if newdata == 1            DATA = AllV.LoadCellFile(DATA);            AllV.AddCellMenu(DATA);            DATA = AllV.LoadComments(DATA);        end        if DATA.auto.uselastcluster && length(DATA.LastClusters) >= DATA.probe(1)            DATA.cluster = DATA.LastClusters{DATA.probe(1)};            forcecluster = 1;        endendDATA.idstr = AllV.IDStr(DATA);cname = AllV.ClusterFile(DATA.name,'clusterlog','subdir',DATA.clustersubdir);cname = strrep(cname,'ClusterLog',sprintf('ClusterLogExpt%d',DATA.exptno));if isfield(DATA,'logname') && ~strcmp(DATA.logname,cname) && DATA.logfid > 0  try      fclose(DATA.logfid);  catch      fprintf('ERROR closing logfid\n');  end    DATA.logfid = -1;endif DATA.logfid < 0 && DATA.nolog == 0    DATA.logfid = fopen(cname,'a');    DATA.logname = cname;    if verbose    disp(sprintf('Opened Log %s id=%d\n',cname,DATA.logfid));    endelseif verbose    disp(sprintf('No Log set (%s). logfid is %d',AllV.IDStr(DATA),DATA.logfid));endres.logfid = DATA.logfid;if DATA.logfid > 0    try        fprintf(DATA.logfid,'Ex%d (fid%d) Args %s\r\n',Vall.exptno,DATA.logfid,callstring);    catch        fprintf('Invalid handle %d. Opening %s again\n',DATA.logfid,cname);        DATA.logfid = fopen(cname,'a');    endendif newdata > 0  && isfield(DATA,'name');    DATA.msg = {};    DATA.plotspk.subtrigger = 0;    DATA.plotspk.submean = 0;    DATA.plotspk.submax = 0;    DATA.plotspk.submin = 0;    DATA.plotspk.oneprobe = 0;    DATA.plotspk.includeprepost = 0;    DATA.currenttrial = 1;    DATA.plotspk.muscale = muscale;    if newdata == 1 %%Keep DataClusters if newdata == 2 - new probe        DataClusters = {};        DATA.clst = [];        tt = AllV.TimeMark(tt, 'Loading Clusters ', DATA.profiling);        DataClusters = AllV.LoadDataClusters(DATA);    endelseif newdata == 2 else    DataClusters = {};endtt = AllV.TimeMark(tt, 'Loaded Clusters ', DATA.profiling);if newdata || autocutone;    if spkrate && setnspk == 0       setnspk = round(DATA.duration .* spkrate);    else        spkrate = setnspk./DATA.duration;    endendif recluster && (length(DataClusters) < p || ~isfield(DataClusters{p},'space')) && forcecluster == 0    if length(DATA.RefClusters) >= DATA.probe(1)        userefcluster = 1;        fprintf('DataClusters is empty using refcluster\n', DATA.probelist(DATA.probe(1)));    else            DATA = AllV.AddErr(DATA,'Cant Apply  Cluster for %d - DataClusters only %d elements\n', DATA.probelist(DATA.probe(1)),length(DataClusters));    recluster = 0; %just do simple cut if no cluster defined    savespikes = 0;    if DATA.auto.quickcut        autocutone = 2;    end    endendif ~exist('DataClusters','var')    DataClusters = {};endif forcecluster && isempty(DataClusters)endDATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);if recluster%    DATA.currentcluster = 1;    p = AllV.ProbeNumber(DATA);    DATA.recluster = recluster;        if isfield(DATA,'cluster') && isfield(DATA.cluster,'auto') && DATA.cluster.auto ==1        wasauto = 1;    elseif length(DataClusters) < DATA.probelist(DATA.probe(1))        wasauto = 2;    elseif isfield(DataClusters{p},'auto') &&  DataClusters{p}.auto == 1        wasauto = 1;    else        wasauto = 0;    end    if recluster == 4 %load event times, dont calc trigger        cfile = AllV.ClusterFile(DATA.name,DATA.Expt,'details','subdir',DATA.clustersubdir);    end    if forcecluster == 0 %%used saved cluster                if (userefcluster || wasauto) && length(DATA.RefClusters) >= DATA.probelist(DATA.probe(1))            DATA.cluster = DATA.RefClusters{DATA.probelist(DATA.probe(1))};            DATA.cluster.manual = 4;            fprintf('Using RefClusters for probe %d\n',p)        else            DATA.cluster = DataClusters{DATA.probelist(DATA.probe(1))};        end        if recluster == 2 && isfield(DATA.cluster,'chspk') %force PC chans            chspk = DATA.cluster.chspk;            DATA.chspk = chspk;        end        if ~isfield(DATA.cluster,'minvar')            DATA.cluster.minvar = 0;        end        if (recluster == 2 ||newdata == 2) && isfield(DATA.cluster,'Trigger');            th = DATA.cluster.Trigger;        end    end    DATA.cluster = FixCluster(DATA.cluster);    if ~isfield(DATA.cluster,'space')        fprintf('Cant recluster  - old cluster is empty\n');        return;    end%if applying an old boundary to new data, use the old trigger only if none%was set   if recluster ==1 && th == 0       th = DATA.cluster.Trigger;   end   if isnan(th)       th = 0;   end    tryall = 0;    if isempty(spts)        spts = DATA.cluster.spts;    end%only set CSd/DVDY for PC calculation if the cluster is in that space%otherwise this just wastes time%check - could go wrong if cluster 2 is cut in PC space    if isfield(DATA.cluster,'csd') && ismember(DATA.cluster.space(1), [1 6])        DATA.csd = DATA.cluster.csd;        DATA.dvdt = DATA.cluster.dvdt;    end%if there is smoothing on the command line, it supercedes the save cluster    if isfield(DATA.cluster,'tsmooth') && smoothsd == 0        smoothsd = DATA.cluster.tsmooth;    end    if isfield(DATA.cluster,'trigdt') && DATA.trigdt == 0        DATA.trigdt = DATA.cluster.trigdt;    end    if isfield(DATA.cluster,'triggerchan') && length(DATA.cluster.triggerchan) > 1        ispk = DATA.cluster.triggerchan;        if isfield(DATA.cluster,'triggertype')            id = strmatch(DATA.cluster.triggertype,{'sum' 'or' 'sumandreplace'});            if ismember(id,[1 3])                addch = 1;            elseif isempty(id) && length(ispk) > 1                addch = 1;            end        else            addch = 1;        end    end    if ismember(recluster, [1 2])         if DATA.cluster.minenergy > 0        th = DATA.cluster.Trigger;        minenergy = DATA.cluster.minenergy;        minvar = DATA.cluster.minvar;        end        if isfield(DATA.cluster,'vsmps')            DATA.vsmps = DATA.cluster.vsmps;        end    end    if recluster == 2        DATA.clst = [];    end    if ~isfield(DATA.cluster,'excludetrialids')        DATA.cluster.excludetrialids = [];    endelse    DATA.recluster = 0;    if setnspk == 0        setnspk = round(spkrate .* DATA.duration);    endendif ~isfield(DATA,'cluster') || ~ClusterIsSet(DATA.cluster, DATA.currentcluster)    DATA.currentcluster = 1;endif ~isfield(DATA.Expt,'Header')    DATA.cluster.exptreadmethod = -1;elseif isfield(DATA.Expt.Header,'ReadMethod')    DATA.cluster.exptreadmethod = DATA.Expt.Header.ReadMethod;else    DATA.cluster.exptreadmethod = 0;endtt = AllV.TimeMark(tt,'Start Trig', DATA.profiling);DATA.triggertype = 'one';if length(ispk) > 1 && addch    DATA.triggertype = 'sum';endp = AllV.ProbeNumber(DATA);DATA.currentprobe = p;if forcetrigger    ispk = forcetrigger;endif ~isfield(Vall,'Spikes')    if verbose >1        fprintf('Making Trig reference for E%dP%d %s\n',DATA.exptno,AllV.ProbeNumber(DATA),datestr(now,'HHMM:ss'));    end    if length(ispk)  > 1 && addch        rV = mean(double(Vall.V(ispk,:)));        if isinteger(Vall.V)            rV = rV .* Vall.intscale(1)./Vall.intscale(2);        end        DATA.triggertype = 'sum';        if addch == 2            DATA.triggertype = 'sumandreplace';            Vall.V(ispk(1),:) = rV;        end    else        if length(ispk) > 1            DATA.triggertype = 'or';        end        if isinteger(Vall.V)            rV = double(Vall.V(ispk,:))  .* double(Vall.intscale(1))./Vall.intscale(2);        else            rV = Vall.V(ispk,:);        end    endif length(smoothsd) > 1 %% explose effect of smoothing on theif verbose >1    fprintf('Smoothing  %s\n',datestr(now));end    colors = mycolors;    AllV.SetFigure(DATA.tag.vhist, DATA);    hold off;    for j = 1:length(smoothsd)        smv = smooth(Vall.V(ispk,:),smoothsd(j),'gauss');        sgn = diff(sign(diff(smv,1,2)),1,2);        id = find(sgn > 0 & V(ispk,2:end-1) < 0);        [a,b] = smhist(Vall.V(ispk,id+1));        plot(b,a,'color',colors{j});        res.skew(j) = moment(Vall.V(ispk,id+1),3);        hold on;    end    return;elseif smoothsd > 0.1        smv = smooth(rV,smoothsd,'gauss');else    smoothsd = 0;    smv = rV;endclear rV; if isinteger(smv)  smv = double(smv) .* Vall.intscale(1)./Vall.intscale(2);endif subtractadj && ispk > 1 && ispk <= DATA.nprobes    cp = [ispk-1 ispk+1];    subv = mean(Vall.V(cp,:)) .* Vall.intscale(1)./Vall.intscale(2);    smv = smv - subv;    Vall.V = double(Vall.V) .* Vall.intscale(1)./Vall.intscale(2);;    Vall.V(ispk,:) = Vall.V(ispk,:) - subv;endif DATA.trigdt    if DATA.trigdt == 3 %10pt moving average of dvdt = energy        smv = smooth(diff(smv).^2,3,'gauss');    elseif ismember(DATA.trigdt,[4 5]) %convolve with template        if recluster && isfield(DATA.cluster,'TriggerTemplate')            DATA.TriggerTemplate = DATA.cluster.TriggerTemplate;        end        if size(DATA.TriggerTemplate,1) > length(ispk)            for j = 1:length(ispk)            x(j,:) = conv(double(Vall.V(ispk(1),:)),fliplr(DATA.TriggerTemplate(ispk(j),:)));            end            x = mean(x,1);            DATA.TriggerTemplate = DATA.TriggerTemplate(ispk,:);        elseif length(ispk)  > 1            for j = 1:length(ispk)            x(j,:) = conv(Vall.V(ispk(j),:),fliplr(DATA.TriggerTemplate(j,:)));            end            x = mean(x,1);        else            if DATA.trigdt == 4                x = conv(smv,fliplr(DATA.TriggerTemplate));            elseif DATA.trigdt == 5                x = conv(diff(smv),diff(fliplr(DATA.TriggerTemplate)));            end        end        np = round(length(DATA.TriggerTemplate)/2);        if mod(length(DATA.TriggerTemplate),2) == 1            smv = x(np-1:end-np);        else            smv = x(np:end-np);        end    elseif DATA.trigdt == 2 %% acceleration        smv = diff(smv,2);    else        smv = diff(smv);    endendDATA.triggersmooth = smoothsd;DATA.triggerchan = ispk;DATA.cluster.trigparams.preperiod = DATA.preperiod;DATA.cluster.trigparams.postperiod = DATA.postperiod;if smoothv && newdata    for j = 1:size(Vall.V,1)        Vall.V(j,:) = smooth(double(Vall.V(j,:)),smoothv,'gauss');    endendtt = AllV.TimeMark(tt,'Start Trig',DATA.profiling);if verbose > 1    fprintf('%s %s %s\n',AllV.IDStr(DATA),tt(end).str,datestr(now,'HHMM:ss'));endDATA.nprobes = size(Vall.V,1);if ~isfield(DATA,'cluster') || ~isfield(DATA.cluster,'version')    DATA.cluster.version = DATA.version;endF = AllV.SetFigure(DATA.tag.top,DATA);DATA.toplevel = F;res.toplevel = F;if DATA.interactive >= 0    set(F,'UserData',DATA);    DATA = AllV.mysetappdata(DATA,'Vall',Vall);    if newdata        if exist('AutoClusters','var')            setappdata(DATA.toplevel,'AutoClusters',AutoClusters);        end    endelse    DATA = AllV.mysetappdata(DATA,'Vall',Vall);end%load trig times before thresholding current channel. Then set trig times%for current channel to match new values after thresholdif gettrigtimes     if gettrigtimes == 2        [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,1:DATA.nprobes,'savexy');    else        [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,1:DATA.nprobes);    end    if recluster == 2        DATA.lastxy = DATA.xy{1};        DATA.oldtrigtimes = Vall.t(DATA.trigtimes{DATA.probe(1)});        DATA.oldclst = DATA.clst;        AllV.PlotXY(DATA.xy{1},DATA.clst);        th = DATA.cluster.Trigger;    endelseif recluster == 2    if userefcluster == 0    [DATA, DataClusters, oldxyloaded] = AllV.LoadTrigTimes(DATA,[]);    if forcecluster == 0 && isfield(DataClusters{p},'Evec')        DATA.cluster.Evec = DataClusters{p}.Evec;    end    DATA = AllV.mysetappdata(DATA,'Custers',DataClusters);    end    if oldxyloaded && length(DATA.trigtimes) >= DATA.probe(1)        AllV.SetFigure(DATA.tag.oldxy, DATA);        DATA.lastxy = DATA.xy{1};        if DATA.trigtimes{DATA.probe(1)}(end) > Vall.t(end)            DATA.oldtrigtimes = DATA.trigtimes{DATA.probe(1)};% can't use followig line,since trigtimes is not int. What problem% is this meant to solve?%            DATA.oldtrigtimes = Vall.t(DATA.trigtimes{DATA.probe(1)});        else            DATA.oldtrigtimes = DATA.trigtimes{DATA.probe(1)};        end        DATA.oldclst = DATA.clst;        if DATA.interactive > 0            AllV.PlotXY(DATA.xy{1},DATA.clst);        end    elseif DATA.interactive > 0 %faster to just use recluster 1. Good if the was called from GUI% But need 2 if doing batch reclassify and want quantification          recluster = 1;    end        th = DATA.cluster.Trigger;endif isempty(spts)    spts = [-12:27];endif recluster == 4  %use trig times from saved cluster    DATA.xy = {[]}; %in case its not set in AllV.LoadTrigTimes    p = AllV.ProbeNumber(DATA);    DATA.trigcheck(p) = 1;    [DATA, DataClusters] = AllV.LoadTrigTimes(DATA,p);    DATA.Trigger = DATA.cluster.Trigger;    DATA.autoth = 1;    DATA.spts = DATA.cluster.spts;    DATA.setnspk = DATA.cluster.nspks;    DATA.gmcid = [];    if ~isempty(forceeventlist)%        id = find(ismember(Vall.t,forceeventlist)); %if list is times        if isfield(forceeventlist,'tid')            id = forceeventlist.tid; %if list is index # in Vall.V        elseif isfield(forceeventlist,'spk_inds')            id = forceeventlist.spk_inds; %if list is index # in Vall.V        elseif isnumeric(forceeventlist)            id = forceeventlist; %if list is index # in Vall.V        end        if isfield(forceeventlist,'clst')            DATA.clst = 1+forceeventlist.clst;        elseif isfield(forceeventlist,'spike_clusts')            DATA.clst = forceeventlist.spike_clusts;        else        DATA.clst = ones(1,length(id));        end    else        id = DATA.trigtimes{p};    endelse%in ver 1.1 and before, some triggers (trigdt) were save to clsueter without%converting to double    if (th > max(smv) || th < min(smv)) && DATA.cluster.version <= 1.1        a = th;        th = th .* Vall.intscale(1)./Vall.intscale(2);        DATA = AllV.AddErr(DATA,'Converting Trigger to double %.0f -> %.3f',a, th);    end    DATA.Trigger = th;    DATA.autoth = 1;    DATA.spts = spts;    DATA.thsign = thsign;    if setnspk > 0        DATA.setnspk = setnspk;    elseif DATA.spkrate > 0        DATA.setnspk = 0;    end    if recluster == 1 && matcheventcounts        DATA.Trigger = 0;        DATA.thsign = (1+sign(th))/2;        if isfield(DATA.cluster,'eventrate')            DATA.setnspk = round(DATA.cluster.eventrate .* length(smv));        else            DATA.setnspk = DATA.cluster.nspks;        end    end    [id,  DATA.Trigger, D] = AllV.TriggerV(DATA, smv);    if length(id) > 1e6        if DATA.interactive  < 0             if ~isfield(DATA,'chspk')                DATA.chspk = 0;            end            fprintf('E%dP%d> 1 million events. (Trigger %f) Exiting AllVPcs\n',DATA.exptno,DATA.chspk(1),DATA.Trigger);            return;        end        yn =  questdlg('>1Million events. Proceed?','trigger','Yes','No','No');        if strcmpi(yn,'no')            return;        end    end    DATA.cluster.eventrate = D.nevents./length(smv);    DATA.cluster.trigparams = CopyFields(DATA.cluster.trigparams,D,{'skew' 'roc' 'qq'});endtt = AllV.TimeMark(tt,'End Trig', DATA.profiling);if spkrate > 0    DATA.spkrate = spkrate;else    DATA.spkrate = DATA.cluster.eventrate./Vall.samper;endclear sgn;%remove any spikes at very beginning or end where there isn't enough%data to include the whole spikeif size(id,1) > 1    id = id';endif verbose > 0 fprintf('E%dP%d %dEvents (%.1fHz)\n',DATA.exptno,AllV.ProbeNumber(DATA),length(id),length(id)./DATA.duration); endignoreid = [];missedtrials = [];if isfield(DATA, 'Expt') && isfield(DATA.Expt,'Trials') && DATA.usetrials    if isfield(DATA.Expt.Header,'expname')        res.expname = DATA.Expt.Header.expname;    end    iid = [];    piid = [];     if isfield(DATA.cluster,'excludetrialids')         xct = DATA.cluster.excludetrialids;     else         xct = [];     end     missedtrials = [];     blkend = (Vall.blkstart + Vall.blklen.*Vall.samper).*10000;     blkstart = Vall.blkstart .* 10000;    for j = 1:length(DATA.Expt.Trials)        tid = find(blkstart < DATA.Expt.Trials(j).Start(1) & blkend > DATA.Expt.Trials(j).End(end));        if isempty(tid)                missedtrials = [missedtrials DATA.Expt.Trials(j).id];        end        oid = find(vt(id) > DATA.Expt.Trials(j).Start(1)./10000 - DATA.preperiod & ...            vt(id) < DATA.Expt.Trials(j).End(end)/10000 + DATA.postperiod);        pid = find(vt(id(oid)) > DATA.Expt.Trials(j).End(end)/10000); %in postperiod        iid = [iid oid];        piid = [piid oid(pid)];    end    ntrials = j;    uid = unique(iid);    if length(DATA.clst) == length(id)        DATA.clst = DATA.clst(uid);        if recluster == 4 && length(DATA.xy{1}) >= max(uid)            DATA.xy{1} = DATA.xy{1}(uid,:);        end    end    ignoreid = setdiff(id,id(uid));    id = id(uid);    [a, pid] = ismember(piid,uid);DATA.postevents = pid; %index to event index, not FullV timesif isfield(DATA.Expt.Header,'trialdur')DATA.duration = (DATA.Expt.Header.trialdur+ntrials*(DATA.preperiod+DATA.postperiod))./10000;else    disp(sprintf('Header Missing trialdur E%dP%d\n',DATA.exptno,DATA.probe(1)));    DATA.duration = ntrials * (2+DATA.preperiod+DATA.postperiod);endsetnspk = DATA.duration * spkrate;elseDATA.postevents = [];endDATA.missedtrials = missedtrials;if length(missedtrials)    DATA = AllV.AddErr(DATA,'Missing Trials%s\n',sprintf(' %d',missedtrials));endif maxrate > 0    maxspikeset = DATA.duration .* maxrate;endif isempty(id)    DATA = AllV.AddErr(DATA,'No Spikes in Expt\n');    res.t = [];    res.Trigger = DATA.Trigger;    return;endDATA.rV = smv(:,id);DATA.trigtimes{DATA.probe(1)} = id;DATA.trigcheck(DATA.probe(1)) = 1;res.t = vt(id);if DATA.plotrv    allid = repmat(id,length(spts),1) + repmat(spts',1,length(id));    AllrV = smv(allid);endif checklast == 2 || keeptrigger    DATA = AllV.mysetappdata(DATA,'TriggerV',smv);endclear smv;endDATA.nvpts = length(spts);res.toplevel = DATA.toplevel;res.th = th;allid = [];res.maxspksused = 0;if isfield(Vall,'Spikes')    tt = AllV.TimeMark(tt,'Convert Spikes',DATA.profiling);    S = Vall.Spikes;    if isfield(S,'xchans')        AllVoltages = zeros([DATA.allnprobes size(S.values,2) size(S.values,1)]);        AllVoltages(DATA.probe(1),:,:) = double(S.values') .* S.maxv./S.maxint;        chspk = DataClusters{DATA.probe(1)}.chspk;        AllVoltages(S.xchans,:,:)= double(S.xvalues) .* S.maxv./S.maxint;        newchspk = sort([p S.xchans]);        DATA.nprobes = length(newchspk);        if sum(~ismember(chspk,newchspk)) %don't have channels            chspk = newchspk;            fprintf('Dont have all spike channels for%s\n',sprintf(' %d',chspk));        end    else        AllVoltages(DATA.probe(1),:,:) = double(S.values') .* S.maxv./S.maxint;        chspk = DATA.probe(1); %1 for single Fullv files    end    res.t = S.times(:)'./10000; %column vector        spts = DataClusters{p}.spts;    tpt = find(spts ==0);    DATA.spts = spts;    [DATA, Cd] = AllV.LoadClusterDetails(DATA);    tt = AllV.TimeMark(tt,'Convert Trigger',DATA.profiling);    if isfield(S,'TriggerV') %trigger stored with spikes takes precednce        DATA.rV = S.TriggerV;    elseif isfield(Cd{p},'triggerV')        DATA.rV = Cd{p}.triggerV;    else        DATA.rV = squeeze(mean(AllVoltages(DataClusters{p}.triggerchan,tpt,:),1));    end    DATA = CopyFields(DATA, DataClusters{p},{'Trigger'});%    DATA.Trigger = DataClusters{p}.Trigger;    DATA.triggersmooth = DataClusters{p}.tsmooth;    DATA.triggerchan = DataClusters{p}.triggerchan;    DATA.missedtrials = DataClusters{p}.missingtrials;    DATA.chspk = 1:DATA.nprobes;    if recluster == 2 %can;'t do reclassify with just spikes        recluster = 1;    end    tt = AllV.TimeMark(tt,'End Trigger',DATA.profiling);elseif minenergy    if verbose        fprintf('Applying min energy at %s\n',datestr(now,'HHMM:ss'));    end    allid = repmat(id,length(spts),1) + repmat(spts',1,length(id));    AllVoltages = reshape(Vall.V(ispk(1),allid),[size(allid)]);    clear allid;    energy = sqrt(squeeze(sum(diff(AllVoltages,1,1).^2)));    spkvar = std(AllVoltages);    clear AllVoltages;    ie = [];    adjustenergy = 0;   %if the user has set minenergy, don't mess with it. With autocutting seems like sometimes   %want to adjust minenergy, but not sure when. When it comes up, set   %adjustenergy    if length(energy) <= setnspk        ie = [1:length(energy)];    elseif adjustenergy        while length(ie) < setnspk            ie = find(energy > minenergy & spkvar > minvar);            minenergy = minenergy * 0.8;            minvar = minvar * 0.8;        end    else            ie = find(energy > minenergy & spkvar > minvar);    end       if  length(ie)  > maxspikeset        if th(1) < 0            prc = 100 * maxspikeset./length(ie);        else            prc = 100-(100 * maxspikeset./length(ie));        end        th = prctile(DATA.rV,prc);    end    while length(ie) > maxspksallowed         minenergy = minenergy * 1.1;        minvar = minvar * 1.1;        ie = find(energy > minenergy & spkvar > minvar);        res.maxspksused = length(ie);    end            DATA.rV = DATA.rV(ie);    clear energy;    clear spkvar;    clear AllVoltages;    [AllVoltages, DATA] = AllV.BuildAllV(DATA, id, spts);    res.t = vt(id(ie));    [a,b] = ismember(DATA.postevents,ie);    DATA.postevents = b;    id = id(ie);    DATA.trigtimes{DATA.probe(1)} = id;else    [AllVoltages, DATA] = AllV.BuildAllV(DATA, id, spts);endDATA.nevents = size(AllVoltages,3);if DATA.Trigger(1) <0    res.xsd = std(DATA.rV(1,:));elseendtt = AllV.TimeMark(tt,'Created AllVoltages',DATA.profiling);res.spkrate = DATA.nevents./DATA.duration;if verbose > 0 fprintf('E%dP%d Built AllVoltages %d events (%.2f)\n',DATA.exptno,AllV.ProbeNumber(DATA),DATA.nevents,mytoc(tt(1).time)); endif ~isempty(addmean)    DATA.addmean = addmean;elseif isfield(DATA.cluster,'addmean')    DATA.addmean = DATA.cluster.addmean;elseif isfield(DATA.cluster,'version')    if DATA.cluster.version <= 1.10        DATA.addmean = 0; %default in ver 1.10    endendif isfield(Vall,'meanV')    if isfield(Vall,'meanV') && DATA.addmean%  slightly faster, but might cause memory swapping%        mV = shiftdim(repmat(Vall.meanV(allid),[1 1 24]),2);%        AllVoltages = AllVoltages+mV;        for j = 1:size(AllVoltages,1)            AllVoltages(j,:,:) = squeeze(AllVoltages(j,:,:)) + Vall.meanV(allid);        end    endelse    DATA.meanV = squeeze(mean(AllVoltages,1));    DATA.addmean = 1;enda = whos('Vall');DATA.fullvsize = AllV.memsize(Vall);y = max(max(abs(AllVoltages(DATA.probe(1),:,:))));DATA.voffset = [1:DATA.nprobes].*y;clear Vall;if rejectbydiff    a = max(abs(diff(DATA.meanV)));    bid = find(a > rejectbydiff);elseif DATA.addmean && DATA.loadfromspikes == 0    allbid = [];    gid = 1:size(AllVoltages,3);    avar = sum(DATA.meanV(:,gid).^2);    bid = find(avar > prctile(avar,99) * 2);    while length(bid)        allbid = [allbid bid];        gid = setdiff(1:size(AllVoltages,3),allbid);        avar = std(DATA.meanV(:,gid));        avar = sum(DATA.meanV(:,gid).^2);        bid = find(avar > prctile(avar,99) * 2);        bid = gid(bid);    end    avar = sum(abs(diff(DATA.meanV(:,gid))));    bvar = smooth(avar,10);    bid = find(avar > prctile(avar,99) * 1.5);    while length(bid)        allbid = [allbid bid];        gid = setdiff(1:size(AllVoltages,3),allbid);        avar = sum(abs(diff(DATA.meanV(:,gid))));        bid = find(avar > prctile(avar,99) * 1.5);        bid = gid(bid);    end    bid = allbid;elseif size(AllVoltages,1) == 24%avar = squeeze(std(mean(AllVoltages(1:16,:,:))));%bvar = squeeze(std(mean(AllVoltages(17:24,:,:))));%[da, aid] = sort(avar);%[db, bid] = sort(avar);%avar and bvar are really completely correlated because the channels sum to 0%bid = find(avar > prctile(avar,99) * 2 & bvar > prctile(bvar,99) * 2);bid = [];else    bid = [];endclear avar;clear bvar;res.t = res.t(:)';  %force to a row vectorif length(bid)    DATA.artifacttimes = res.t(bid);    fprintf('%s Made AllVoltages  %d spikes. Removed %d suspicous events at %s,\n',AllV.IDStr(DATA),size(AllVoltages,3),length(bid),datestr(now,'HHMM:ss'));    if DATA.interactive >= 0    AllV.SetFigure(DATA.tag.vare,DATA, DATA.watcharg{:});    if DATA.nprobes == 24    hold off;    plot(squeeze(mean(AllVoltages(17:24,:,bid))));    hold on;    plot(squeeze(mean(AllVoltages(1:16,:,bid))));    else        plot(DATA.meanV(:,bid));    end    drawnow;    end    gid = setdiff(1:size(AllVoltages,3),bid);    [a,b] = ismember(DATA.postevents,gid);    DATA.postevents = b;    if length(DATA.clst) == size(AllVoltages,3)        DATA.clst = DATA.clst(gid);    end            AllVoltages = AllVoltages(:,:,gid);    DATA.meanV = DATA.meanV(:,gid);       res.t = res.t(gid);    if DATA.plotrv    AllrV = AllrV(:,gid);    end    DATA.rV = DATA.rV(gid);    nerr = nerr+1;    errs{nerr} = sprintf('Removed %d suspicous events, ',length(bid));    DATA.trigtimes{DATA.probe(1)} = DATA.trigtimes{DATA.probe(1)}(gid);    ignoreid = [ignoreid id(bid)];elseif verbose    fprintf('E%dP%d Made AllVoltages  %d spikes at %s (%.2f)\n',DATA.exptno,AllV.ProbeNumber(DATA),size(AllVoltages,3),datestr(now,'HHMM:ss'),mytoc(tt(1).time));endtt = AllV.TimeMark(tt,'Built AllVoltages',DATA.profiling);res.trigartifacts = length(bid);if DATA.plotrv && DATA.interactive >= 0    setappdata(DATA.toplevel,'AllrV',AllrV);    clear AllrV ;endclear allid;fullcov = 1;DATA.nevents = size(AllVoltages,3);res.spkrate = DATA.nevents./DATA.duration;DATA = AllV.mysetappdata(DATA,'MeanV', DATA.meanV);if isfield(DATA.cluster,'addmean')    DATA.addmean = DATA.cluster.addmean;endif recluster == 2  % 'reclassify' = compare with last also    if checklast && isfield(DATA,'oldtrigtimes')    [t, ida] = setdiff(DATA.oldtrigtimes,res.t);    if checklast == 2        spkfile = AllV.SpkFileName(DATA);        try          a = load(spkfile);          if isfield(a.Spikes,'maxv')              a.Spikes.values = double(a.Spikes.values) * a.Spikes.maxv./a.Spikes.maxint;          end          DATA.oldSpikes = a.Spikes;        catch            DATA = AllV.AddErr(DATA,'Error loading %s\n',spkfile);        end        goodid = [];        for j = 1:length(ida)            d = min(abs(res.t-DATA.oldtrigtimes(ida(j))));            if d < 0.0005                goodid = [ida(j) goodid];                baddiff(j) = 0;            else                baddiff(j) = 1;            end            tdiff(j) = d;        end        ida = setdiff(ida, goodid);        t = DATA.oldtrigtimes(ida);    end                n = length(ida); %number of old times not here    [a, ida] = ismember(t,vt);    ida = ida(ida > 0);    bid = find(~ismember(ida,ignoreid)); %missing and not actively removed    if isempty(ignoreid)        ignoreid = 0;    end    for j = 1:length(bid)        xid(1,j) = min(abs(id-ida(bid(j))));        xid(2,j) = min(abs(ignoreid-ida(bid(j))));    end    if length(bid)        nid = find(xid(1,:) >5 & xid(2,:) > 5);    else        nid = [];    end% reclustern(1) = #of old trig times not in new list% reclustern(2) = #of those that are not on the ignore list (ignoreid)% reclustern(4) = # of events in old trig times    DATA.reclustern = [n length(bid) length(nid) length(DATA.oldtrigtimes)];    fprintf('Triggers %d/%d old ones gone. (%d not ignored, %d >0.5ms from closest)\n',n,length(DATA.oldtrigtimes),length(bid),length(nid));    else        DATA.reclustern = [0 0 0 0];    end    try            res.VCdatediff = DATA.cluster.savetime(end)-FullVData.builddate;    catch    endelse    if ~isempty(addmean) %let command line override        DATA.addmean = addmean;    endendpcplots = [1 2; ...           1 3; ...           1 4; ...           1 5; ...           2 3; ...           2 4; ...           2 5; ...           3 5];%need to reset vpts for new probes, because probe # is added   vsmps = DATA.vsmps;DATA.dvpts = [0 9 0 13; ...           0 9 0 16; ...           0 9 -1 9; ...           0 13 1 13; ...           0 20 -1 14; ...           0 10 -1 5; ...           0 10 0 30; ...           0 9 0 12];if length(ispk) == 1    DATA.dvpts = [0 9 0 13; ...           0 9 0 16; ...           0 9 0 13; ...           0 9 0 5; ...           0 9 0 20; ...           0 5 0 13; ...           0 5 0 20; ...           0 5 0 16; ...           0 12 0 20];end if newdata == 1 || ~isfield(DATA,'vspace')    DATA.tmplots(1,:) = [1 3];    DATA.tmplots(2,:) = [1 4];    DATA.tmplots(3,:) = [1 2];    DATA.tmplots(4,:) = [2 10];    DATA.tmplots(5,:) = [1 8];    DATA.tmplots(6,:) = [2 11];    DATA.tmplots(7,:) = [2 12];    DATA.tmplots(8,:) = [1 5];    DATA.tmplots(9,:) = [2 13];    DATA.tmplots(10,:) = [2 14];    DATA.tmplots(11,:) = [2 15];    DATA.tmplots(12,:) = [1 6];    DATA.tmplots(13,:) = [6 11];    DATA.tmplots(14,:) = [2 16];    DATA.tmplots(15,:) = [2 17];    DATA.tmplots(16,:) = [2 18];    DATA.tmplots(17,:) = [1 2];    DATA.tmplots(18,:) = [3 4];    DATA.tmplots(19,:) = [1 3];    DATA.tmplots(20,:) = [2 4];    DATA.tmplots(21,:) = [1 4];    DATA.tmplots(22,:) = [2 3];    DATA.tmplots(23,:) = [1 2];    DATA.tmplots(24,:) = [3 4];    if DATA.nprobes == 1        DATA.tmplots(4,:) = [1 10];        DATA.tmplots(6,:) = [1 11];        DATA.tmplots(7,:) = [1 12];    end        DATA.gmtypes = [1 0 2 3];    DATA.gmtypelabels = {'PCs', 'Var-E', 'ADC', 'Template' 'Template2' 'Reserved' 'StdTemplate'};    DATA.pcspace = [1:4];  %N-D fits use first four PCs    DATA.tmplspace  = [1 2 8 10 5 12];    DATA.tmplspace(2,:)  = [1 2 3 4 0 0]; %for Template group 2    DATA.tmplspace(3,:)  = [1 2 3 4 0 0]; %for fixed std templates    DATA.tmplspace(4,:)  = [1 2 3 4 0 0]; %for fixed std templates    DATA.vspace = [6 11 15 20];    DATA.restricttimerange = [];    DATA.excludetrialids = [];    DATA.selectprobe = zeros(1,DATA.nprobes); end DATA.minenergy = minenergy;DATA.minvar = minvar;DATA.energy = [];DATA.energy(1,:) = sqrt(squeeze(sum(diff(AllVoltages(ispk(1),:,:),1,2).^2,2)));DATA.uid = 1:size(AllVoltages,3);DATA.probe = ispk;if nprobepc < 0    DATA.chspk = chspk;elseif loadfromspikes    DATA.chspk = DataClusters{DATA.probe(1)}.chspk;elseif ismember(recluster,[1 2]) && isfield(DATA.cluster,'chspk')    if ~strncmp(DATA.DataType,'Grid',4)        dp = ispk(1) - DATA.cluster.probe(1); %happens if apply cluster from another probe    else        dp = 0;    end    DATA.chspk = DATA.cluster.chspk+dp;    else    if size(AllVoltages,1) ==1        nprobepc = 0;    end    DATA.chspk = SetProbesToUse(DATA, ispk, nprobepc);    if ~isfield(DATA.cluster,'chspk')        DATA.cluster.chspk = DATA.chspk;    endendnp = size(AllVoltages,1);nv = size(AllVoltages,2);DATA.nvpts = nv;DATA.vpts = AllV.SetVsamples(DATA,ispk(1),np,nv);DATA.npallv = np;DATA.dvpts(:,1) = DATA.dvpts(:,1) + DATA.probe(1);DATA.dvpts(:,3) = DATA.dvpts(:,3) + DATA.probe(1);id = find(DATA.dvpts(:,1) < 1);DATA.dvpts(id,1) = 1;id = find(DATA.dvpts(:,1) > np);DATA.dvpts(id,1) = np;id = find(DATA.dvpts(:,3) < 1);DATA.dvpts(id,3) = 1;id = find(DATA.dvpts(:,3) > np);DATA.dvpts(id,3) = np;id = find(DATA.dvpts(:,2) > nv);DATA.dvpts(id,2) = nv;id = find(DATA.dvpts(:,4) > nv);DATA.dvpts(id,4) = nv; DATA.pcplots = pcplots;DATA.t = res.t;DATA.spksperview = 100;DATA.spklst = 1:100;DATA.pcprobes = DATA.chspk; %? noew redundant?id = find(DATA.vspace > length(DATA.spts));DATA.vspace(id) = length(DATA.spts);if recluster == 0    DATA.cluster.spts = DATA.spts;endDATA.TemplateLabels = AllV.TemplateLabels(DATA,0);DATA.forcecluster = forcecluster;if isempty(DATA.plotspk.probes)DATA.plotspk.probes = DATA.chspk;endtt = AllV.TimeMark(tt,'Before Energy',DATA.profiling);%if only loaded one probe, can't do chspkif size(AllVoltages,1) == 1    DATA.chspk = ispk(1);    chspk = ispk(1);    nprobepc = 0;endxspk = DATA.chspk(DATA.chspk ~= ispk(1));for j = 1:length(xspk)    DATA.energy(j+1,:) = sqrt(squeeze(sum(diff(AllVoltages(xspk(j),:,:),1,2).^2,2)));endtt = AllV.TimeMark(tt,'Calc Energy',DATA.profiling);F = AllV.SetFigure(DATA.tag.top,DATA);if DATA.interactive >= 0    setappdata(F,'plotcsd',0);endDATA.toplevel = F;set(F,'UserData',DATA);%xsd is the SD of all local minima. Closer that 1sd to zero doesnt'%get explored automatically - roo much risk of running out ouf memory%clear AllVoltages;F = AllV.SetFigure(DATA.tag.top,DATA);AllV.SetGUI(DATA);if verbose >1    fprintf('Cacluating PCs %s %s\n',AllV.IDStr(DATA),datestr(now,'HHMM:ss'));endDATA.errs = {DATA.errs{:} errs{:}};if length(tryall) > 1 % when reapplying, just use CSD/Dvdt as before    np = size(DATA.pcplots,1);    for j = 1:length(tryall)        if tryall(j)        DATA.dvdt = dvdts(j);         DATA.csd = csds(j);        [Cs{j}, Evec{j}, pcs{j}, dips{j}, chsppks{j}, errs, fits{j}] = AllV.CalcPCs(DATA,AllVoltages,nprobepc);        DATA.errs = {DATA.errs{:} errs{:}};        else            dips{j} = 0;        end    end    res.alldips = cell2mat(dips');    if DATA.usebmi    [a,b] = max(max(res.alldips(:,1:np)'));    [c,d] = max(res.alldips(:,9)); %mahal distance for first 4     else        [c,d] = max(res.alldips);        b = d;    end    if d ~= b  %different answer        cb = max(res.alldips(d,1:8));        am = res.alldips(b,9);        DATA.msg = {DATA.msg{:} sprintf('Best PC type %d (bm%.2f,mahal%.1f) or %d(%.2f,%.1f)',b,a,am,d,cb,c)};        if verbose > 1        fprintf('%s\n',DATA.msg{end});        end        if b > 2 && a < 0.25            b = d;        end    end    res.pcs = pcs{b};    res.dipvals = dips{b};    DATA.dvdt = dvdts(b);    DATA.csd = csds(b);    DATA.Evec = Evec{b};    DATA.pcfit = fits{b};    res.Evec = Evec{b};%    DATA.chspk = chspk;    C = Cs{b};    DATA.alldips = res.alldips;else    if recluster %no need to calcuate GMfits etc        [C, res.Evec, res.pcs, dip, chspk, errs] = AllV.CalcPCs(DATA,AllVoltages,nprobepc,'nofit');        DATA.errs = {DATA.errs{:} errs{:}};        if isfield(DATA.cluster,'Evec') && size(res.Evec.Evec,2) == size(DATA.cluster.Evec.Evec,2)            sgn = sign(sum(res.Evec.Evec .* DATA.cluster.Evec.Evec,1));            nid = find(sgn < 0);            res.Evec.Evec(:,nid) = -res.Evec.Evec(:,nid);            res.pcs(:,nid) = -res.pcs(:,nid);        end        DATA.pcfit.took = 0;        res.dipvals = 0;    else        [C, res.Evec, res.pcs, dip, chspk, errs, DATA.pcfit] = AllV.CalcPCs(DATA,AllVoltages,nprobepc);        res.dipvals = dip;    endDATA.pcs = res.pcs;DATA.Evec = res.Evec;DATA.errs = {DATA.errs{:} errs{:}};endtt = AllV.TimeMark(tt,'PCs done',DATA.profiling);if isfield(res,'alldips')DATA.dipvals = res.alldips;else    DATA.dipvals = res.dipvals;endDATA.pcs = res.pcs;DATA.spkvar = [];for j = DATA.chspkDATA.spkvar(j,:) = squeeze(std(AllVoltages(j,:,:),[],2));endif DATA.profligateres.edip = HartigansDipTest(sort(DATA.energy(1,:)));endtt = AllV.TimeMark(tt,'SpkVar done',DATA.profiling);DATA.nprobepc = nprobepc;DATA.cluster.trigparams.preperiod = DATA.preperiod;DATA.cluster.trigparams.postperiod = DATA.postperiod;DATA.clid = [];DATA.nid = [];y = max(max(abs(AllVoltages(DATA.probe(1),:,:))));DATA.voffset = CalcVoffset(AllVoltages, DATA.chspk,DATA.gui.spikeVoverlap);%DATA.voffset = [1:size(AllVoltages,1)].*y;DATA.plotcsd = 0;xres = rmfield(res,'pcs');res.chspk = DATA.chspk;res.memsz = [0 DATA.fullvsize];str = 'manual';if saveautocut || autocutone    str = 'auto';    endDATA.cutmode = str;if verbose    fprintf('Making Cut %s %s (%.1f) (%s)\n',AllV.IDStr(DATA),datestr(now,'HHMM:ss'),mytoc(tt(1).time),AllV.ClusterFile(DATA.name,DATA.Expt,str,'subdir',DATA.clustersubdir));endF = AllV.SetFigure(DATA.tag.top,DATA);DATA.toplevel = F;DATA =  AllV.mysetappdata(DATA,'AllVoltages',AllVoltages);if saveautocut == 1    [E, res.cluster] = AllV.CutAndSave(DATA,'refine');    DATA = get(DATA.toplevel,'UserData');    DATA.MeanSpike = res.cluster.MeanSpike;    res.chspk = DATA.chspk;    if max(DATA.clid) < size(DATA.energy,2)        res.cluster.minspke = prctile(DATA.energy(1,DATA.clid),1) .* 0.95;        res.cluster.minspkvar = prctile(DATA.spkvar(DATA.probe(1),DATA.clid),1) .* 0.95;    end    set(DATA.toplevel,'UserData',DATA);    if DATA.savespikes         AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));    end    tt = AllV.TimeMark(tt,'Finish', DATA.profiling);    res.times = tt;    res.cluster = AllV.SmallCluster(res.cluster);    res.memsz = [AllV.memsize(DATA) DATA.fullvsize];    return;endif autocutone && recluster == 2    autocutone = 2;  %call autocut after reclassifyendif autocutone ==1    DATA.cluster = FixCluster(DATA.cluster);    if strcmp(DATA.autocutmode,'quick')        DATA.cluster.probe = AllV.ProbeNumber(DATA);        DATA = AllV.QuickAutoCut(DATA);        res.cluster = DATA.cluster;        E = AllV.BoundaryFromCluster([],DATA.cluster,1);    else        [E, res.cluster] = AllV.CutAndSave(DATA,'nosave','refine');    end    DATA = get(DATA.toplevel,'UserData');elseif autocutone == 2        DATA.cluster.probe = AllV.ProbeNumber(DATA);        DATA.cluster = FixCluster(DATA.cluster);        DATA = AllV.QuickAutoCut(DATA);        res.cluster = DATA.cluster;        E = AllV.BoundaryFromCluster([],DATA.cluster,1); elseif recluster    plottype = 0;  %don't do other things after classify    DATA.cluster = FixCluster(DATA.cluster,DATA);    if isfield(DATA.cluster,'excludetrialids') && ~isempty(DATA.cluster.excludetrialids)        DATA.excludetrialids = DATA.cluster.excludetrialids;        AllV.SetTrialList(DATA);        if length(DATA.clst) < size(DATA.pcs,1);            DATA.clst = ones(size(DATA.pcs,1),1);        end        DATA = AllV.ExcludeTrials(DATA,DATA.cluster.excludetrialids,0);        DATA = AllV.SetPCs(DATA, 0);    elseif isfield(DATA.cluster,'restricttimerange') && ~isempty(DATA.cluster.restricttimerange)        DATA = AllV.RestrictTimeRange(DATA,DATA.cluster.restricttimerange);        DATA = AllV.SetPCs(DATA,0);    end    if recluster == 3  %just use template        if length(DATA.forceclusters) > 1            for j = 1:length(DATA.forceclusters)                DATA.clid = [];                DATA.cluster = DATA.forceclusters{j};                DATA = AllV.ReClassify(DATA,'template');                res.cluster{j} = rmfield(DATA.cluster,{'r' 'bestcl'});            end        else            DATA = AllV.ReClassify(DATA,'template');            res.cluster = DATA.cluster;        end    elseif recluster == 4 %use previous ids        DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],DATA.cluster, DATA.currentcluster));        needtemplate = AllV.NeedTemplateForCluster(DATA.cluster,1);        DATA.plottype = AllV.WhichPlotType(DATA.cluster, DATA.currentcluster);        if needtemplate & (~isfield(DATA,'TemplateScores') ||newdata)            DATA = AllV.CalcTemplateScores(DATA);        elseif isfield(DATA,'TemplateScores')            DATA = rmfields(DATA, {'TemplateScores' 'TemplateUsed'});        end        if DATA.cluster.space(1) == 6            DATA.cluster.shape = 2;            [DATA.ndxy, a, b] = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            if b.err & ~isfield(DATA,'TemplateScores')                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);                DATA.plottype = 3;                res.err = 1;            end        end        res.cluster = AllV.SmallCluster(DATA.cluster);        if 0 %% old way. Why need to recalc Mean?? Quicker switching without        DATA.cluster.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',1);        id = unique(DATA.clst);        for j = 3:length(id)            DATA.cluster.next{j-2}.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc','cluster',j-1);        end        else        id = unique(DATA.clst);        for j = 2:length(id)            AllV.PlotMeanSpike(DATA,'cluster',j-1);        end        end        DATA.clid = find(DATA.clst == 2);        DATA.nid = find(DATA.clst == 1);        AllV.ReplotPCs(DATA,[]);        AllV.PlotTriggerHist(DATA,DATA.cluster,'quick');        if DATA.plotspk.showmean            AllV.PlotSpikes(DATA,1);        end    elseif recluster == 2  || recluster == 1 %space, but new data        res.err = 0;        DATA.cluster.exptno = DATA.exptno;        DATA.cluster.clst = ones(DATA.nevents,1);        [iscll, cellid] =  AllV.isacell(DATA, DATA.exptno, AllV.ProbeNumber(DATA));        if iscll            a = find(cellid > 0);            res.cell = cellid(a(1));            res.cellid = cellid;        else            res.cell = 0;        end        if ~isfield(DATA.cluster,'clusterprog')            DATA.cluster.progversion = 0;            DATA.cluster.clusterprog = 'AllVPvs';        elseif ~isfield(DATA.cluster,'progversion')            id = strfind(DATA.cluster.clusterprog,' ');            if isempty(id)                DATA.cluster.progversion = 0;            else                DATA.cluster.progversion = sscanf(DATA.cluster.clusterprog(id(end):end),'%f');            end        end        if readclusterfromlog            DATA = AllV.ReadFromLog(DATA);        end        if recluster == 2 && oldxyloaded            oldid = find(DATA.oldclst == 2);            xcl = [];            goodxcl = ones(size(DATA.excludetrialids));            for j = 1:length(DATA.cluster.excludetrialids)                t = find([DATA.Expt.Trials.id] == DATA.cluster.excludetrialids(j));                if length(t) == 1                    id = find(DATA.oldtrigtimes > DATA.Expt.Trials(t).Start(1)./10000 - DATA.preperiod & ...                        DATA.oldtrigtimes < DATA.postperiod+DATA.Expt.Trials(t).End(end)./10000);                    xcl = [xcl id];                else                    fprintf('Id %d no longer in Expt!\n',DATA.cluster.excludetrialids(j));                    goodxcl(j) = 0;                end            end            DATA.cluster.excludetrialids = DATA.cluster.excludetrialids(find(goodxcl));            DATA.excludetrialids = DATA.cluster.excludetrialids;            oldid = setdiff(oldid,xcl);        end        if DATA.cluster.space(1) ~= 6 && DATA.cluster.shape == 2            DATA = AllV.AddErr(DATA,'Error Shape 2 but space %s\n',sprintf('%d ',DATA.cluster.space));            DATA.cluster.shape = 1;        end                if DATA.cluster.auto == 2 %was set in plotcluster            DATA.cluster.auto = 0;        end        E = AllV.BoundaryFromCluster([],DATA.cluster, DATA.currentcluster);        if DATA.profiling            fprintf('Return from BoundaryCluster %.4f at %.4f\n',mytoc(E.endtime),mytoc(tt(1).time));        end        DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(E);        [needtemplate, plottypes] = AllV.NeedTemplateForCluster(DATA.cluster,1);        DATA.plottype = AllV.WhichPlotType(DATA.cluster, DATA.currentcluster);        if needtemplate & (~isfield(DATA,'TemplateScores') ||newdata)            if isfield(DATA.cluster,'TemplateUsed')                if size(DATA.cluster.TemplateUsed,1) == 2 && DATA.plottype ~= 7 && 0                    DATA.plottype = 7;                    DATA.cluster.space = [6 7];                    DATA.cluster.shape = 2;                end                DATA = AllV.SetTemplateData(DATA,DATA.currentcluster);            elseif sum(isnan(DATA.cluster.MeanSpike.ms(DATA.probe(1),:)))                DATA.clst = ones(length(DATA.t(DATA.uid)),1);                [a, id] = find(ismember(DATA.t,DATA.oldtrigtimes(oldid)));                if length(id)                    DATA.clst(id) = 2;                    AllV.TemplatePlot(DATA,'nodip');                    DATA = get(DATA.toplevel,'UserData');                else                    DATA = AllV.AddErr(DATA,'NAN Meanspike\n');                    DATA.cluster.space = [1 1 2];                end            else                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);%used to call this lager and remove filesd form dta here.  WHy?   can cause%ProjectND to fail%            elseif isfield(DATA,'TemplateScores')%                DATA = rmfields(DATA, {'TemplateScores' 'TemplateUsed'});            end            if ~isfield(DATA.cluster,'TemplateUsed')                DATA.cluster.TemplateUsed = DATA.TemplateUsed;            end        end        %if this clsuter previously used predefined eigenvectors, use those again        %if the cluster does not require this, but forceevec in on the command%line, set it in the cluster         if isfield(DATA.cluster,'forceevec')            if forceevec > 0                DATA.cluster.forceevec = forceevec;            elseif recluster == 2                forceevec = DATA.cluster.forceevec;            end        end        if DATA.cluster.space(1) == 6            clusterspace = DATA.cluster.space(2);        else            clusterspace = DATA.cluster.space(1);        end                if (ismember(recluster,[1 2]) || forceevec) && clusterspace == 1                        if isfield(DATA.cluster,'Evec') && (recluster == 2 || forceevec) %recalssify used old PCs.                 if ~isfield(DATA.cluster.Evec,'chspk')                    DATA.cluster.Evec.chspk = DATA.cluster.chspk;                end                [a,DATA.Evec, DATA.pcs] = AllV.CalcPCs(DATA, AllVoltages, DATA.nprobepc, DATA.cluster.Evec);                DATA.cluster.forceevec = 1;            elseif loadfromspikes == 0%When do we need to do this?  SHould have been done above?  ?? for rclassify                            [a,DATA.Evec, DATA.pcs(DATA.uid,:)] = AllV.CalcPCs(DATA, AllVoltages, DATA.nprobepc);            DATA.cluster.forceevec = 0;            else            DATA.cluster.forceevec = 0;            end            tt = AllV.TimeMark(tt,'PCs Redone',DATA.profiling);        end                if DATA.cluster.space(1) == 6            if strncmp(DATA.cluster.clusterprog,'AllVpcs',7) && DATA.cluster.progversion <= 1.2                DATA.cluster.shape = 2;            end            [DATA.ndxy, a, b] = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            DATA.xy{1} = xyrotate(DATA.ndxy(:,1),DATA.ndxy(:,2),DATA.cluster.angle);            res.err = b.err;            if b.err & ~isfield(DATA,'TemplateScores')                DATA = AllV.CalcTemplatesFromMean(DATA,DATA.cluster.MeanSpike);                DATA.plottype = 3;            end            if b.err ==1 && DATA.cluster.auto == 1 %redo autocut                PrintMsg(DATA.logfid,'Redoing AllV.AutoCut to fix dimension error');                autocutone = 1;            end        elseif DATA.cluster.space(1) == 2 && DATA.cluster.shape ==2 && DATA.cluster.space(2) == 4 %earlier bug            DATA.ndxy = AllV.ProjectND(DATA,DATA.cluster.space(2),DATA.cluster.gmfit);            DATA.xy{1} = xyrotate(DATA.ndxy(:,1),DATA.ndxy(:,2),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 1            DATA.xy{1} = xyrotate(DATA.pcs(:,DATA.cluster.space(2)),DATA.pcs(:,DATA.cluster.space(3)),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 3            DATA.xy{1} = xyrotate(DATA.TemplateScores(:,DATA.cluster.space(2)),DATA.TemplateScores(:,DATA.cluster.space(3)),DATA.cluster.angle);        elseif DATA.cluster.space(1) == 2 && length(DATA.cluster.space) > 4 %adc values            p = DATA.cluster.space(2:end);            xy(DATA.uid,1) = AllVoltages(p(1),p(2),DATA.uid);            xy(DATA.uid,2) = AllVoltages(p(3),p(4),DATA.uid);            %            x =  squeeze(AllVoltages(a(1),a(2),:));            DATA.xy{1} = xyrotate(squeeze(AllVoltages(p(1),p(2),:)),squeeze(AllVoltages(p(3),p(4),:)),DATA.cluster.angle);        end    flipstr = [];    flip = 1;    DATA.cluster = AllV.CheckScoreScaling(DATA, DATA.cluster);    if DATA.cluster.auto && strcmp(DATA.cluster.automode,'james')        DATA.autocutmode = 'james';    elseif DATA.cluster.shape > 0 %not an ellipse - check sign        if DATA.cluster.crit < 0            ncut = sum(DATA.xy{1}(DATA.uid,1) < DATA.cluster.crit);            nalt =  sum(DATA.xy{1}(DATA.uid,1) > -DATA.cluster.crit);        else            ncut = sum(DATA.xy{1}(DATA.uid,1) > DATA.cluster.crit);            nalt =  sum(DATA.xy{1}(DATA.uid,1) < -DATA.cluster.crit);        end        if recluster == 2 && exist('oldid','var')             nspk = length(oldid);            if ncut < nspk/10 && nalt > nspk/5                DATA.cluster.crit = DATA.cluster.crit .* -1;                DATA.cluster.sign = DATA.cluster.sign .* -1;                flipstr = 'flip';                flip = -1;            end        end    end    if autocutone        [E, scores, dips, xy, details] = AllV.AutoCut(DATA);        DATA = get(DATA.toplevel,'UserData');        DATA.ndxy = xy;        DATA.cluster = AllV.ClusterFromBoundary(E, DATA.cluster);        AllV.CheckClusters(DATA.cluster,'CheckFitSpace')        %            DATA.ndxy = AllV.ProjectND(DATA, E.space(2), E.gmfit);    end    if length(DATA.uid) == 0 && isfield(DATA.cluster,'restricttimerange')        DATA = AllV.UseAllEvents(DATA);    end    ctimes(1) = DATA.cluster.ctime;    for j = 1:length(DATA.cluster.next)        if isfield(DATA.cluster.next{j},'ctime')            ctimes(j+1) = DATA.cluster.next{j}.ctime;        else            if isempty(DATA.cluster.next{j})                ctimes(j+1) = 0;            else                errordlg(sprintf('Missing ctime Cluster %d',j+1),'Cluster Cut Time','modal');                ctimes(j+1) = j+1;            end        end    end    ctimes = ctimes(ctimes > 0);    [a, tlist] = sort(ctimes);    tt = AllV.TimeMark(tt, 'Pre Cluster', DATA.profiling);    %check to see if there are missing "next" clusters    wasempty = 0;    p = AllV.ProbeNumber(DATA);    if recluster == 2 && DATA.reclustern(1) == 0 && oldxyloaded %trigger times match - can use old clst        DATA.clst = DATA.oldclst;        cc = DATA.currentcluster;        for j = 1:length(DATA.cluster.next)            if isempty(DATA.cluster.next{j})                wasempty = 1;                if sum(DATA.clst ==  j+2) > 1                    DATA.currentcluster = j+1;                    DATA.cluster.next{j}.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');                end            elseif wasempty                wasempty = 2;            end        end        DATA.currentcluster = cc;    end    if useoldlst == 0        DATA.clst = [];    end    if recluster == 1 && DATA.watchplots < 2        DATA = AllV.ClassifyAll(DATA,1,'quick','recluster');    else        DATA = AllV.ClassifyAll(DATA,1,'recluster');    end    tt = AllV.TimeMark(tt,'Classified',DATA.profiling);    %if an error messed up the classification, don't copy meanspike    res.cluster = AllV.SmallCluster(DATA.cluster);    AllV.ReplotPCs(DATA,[],'tofront');    if recluster ~= 1 %will have been called in AllV.ClassifySpikes        AllV.PlotTriggerHist(DATA,DATA.cluster);    end     tt = AllV.TimeMark(tt,'Replotted', DATA.profiling);    if recluster == 2 && isfield(DataClusters{p},'space') && exist('oldid','var')        oldC = DataClusters{p};        if length(oldC.space) == 1            oldC.space(2) = 0;        end        if max(oldid) > length(DATA.oldtrigtimes)            oldid = oldid(oldid <= length(DATA.oldtrigtimes));        end        %idxa is matching times for classified spikes        [ts, idxa, idxb] = intersect(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));        unsafetosave = 0;        [ida, iida] = setdiff(round(DATA.t(DATA.clid).*1000), round(DATA.oldtrigtimes(oldid).*1000));        [idb, iidb] = setdiff( round(DATA.oldtrigtimes(oldid).*1000),round(DATA.t(DATA.clid).*1000));        if checklast > 1            tb = DATA.oldtrigtimes(oldid(iidb));            ta = DATA.t(DATA.clid(iida));            for j = 1:length(ida)                [c,d] = min(abs(ta(j)-tb));                if c > 0.0005                    goodid(j) = 0;                else                    goodid(j) = 1;                end            end            ida = ida(goodid == 0);            iida = iida(goodid == 0);            goodid = [];            for j = 1:length(idb)                [c,d] = min(abs(tb(j)-ta));                if c > 0.0005                    goodid(j) = 0;                else                    goodid(j) = 1;                end            end            idb = idb(goodid == 0);        end                        if DATA.interactive >= 0 && ~isempty(DATA.clid) && ~isempty(oldid)            AllV.SetFigure(DATA.tag.oldxy, DATA);            subplot(2,1,2);            AllV.PlotXY(flip .*DATA.lastxy,DATA.oldclst);            title(sprintf('Mahal 1D %.2f, 2D %.2f Space%s',oldC.mahal(4),oldC.mahal(1),...                sprintf(' %d',oldC.space)));            subplot(2,1,1);            hold off;            h(1) = plot(DATA.oldtrigtimes,flip.*DATA.lastxy(:,1),'k.','buttondownfcn',{@AllV.ShowFullV, 1}); %old events            labels{1} = 'old triggers';            hold on;            h(2) = plot(DATA.t(DATA.uid),DATA.xy{1}(:,1),'c.','buttondownfcn',{@AllV.ShowFullV, 2});            labels{2} = 'New Triggers';            h(3) = plot(DATA.oldtrigtimes(oldid),flip.*DATA.lastxy(oldid,1),'.','buttondownfcn',{@AllV.ShowFullV, 1}); %old cell            labels{3} = 'old cell';            h(4) = plot(DATA.t(DATA.clid),DATA.xy{1}(DATA.clid,1),'r.','buttondownfcn',{@AllV.ShowFullV, 2});            labels{4} = 'New Cell';            yl = get(gca,'ylim');            yl(2) = yl(1) + diff(yl)/8;            if isfield(DATA.Expt,'Trials')                for j = 1:length(DATA.Expt.Trials)                    t = DATA.Expt.Trials(j).Start(1)./10000;                    plot([t t],yl,'k-');                end            end            if ~isempty(idxa)            h(5) = plot(DATA.t(DATA.clid(idxa)),DATA.xy{1}(DATA.clid(idxa),1),'g.');            end            labels{5} = '?';            if ishandle(h)                legend(h,labels);            end                                    AllV.SetFigure(DATA.tag.hist, DATA);            subplot(2,1,2);            h = ishold;            hold on;            if ~isempty(iida)                plot(DATA.xy{1}(DATA.clid(iida),1),DATA.xy{1}(DATA.clid(iida),2),'x');            end            if h == 0                hold off;            end        end        str = sprintf('P%d last cut at %s: %d/%d or %d/%d spikes are different (%s)',...            AllV.ProbeNumber(DATA),datestr(oldC.ctime),length(ida),...            length(DATA.clid),length(idb),length(oldid),flipstr);        res.matchcounts = [length(ida) length(DATA.clid) length(idb) length(oldid) NaN];        if DATA.reclustern(1) == 0 %trigger times match - can compare lsts            if length(DATA.uid) == length(DATA.oldclst)                res.matchcounts(5) = sum(DATA.clst(DATA.uid) ~= DATA.oldclst);            elseif length(DATA.clst) == length(DATA.oldclst)                res.matchcounts(5) = sum(DATA.clst ~= DATA.oldclst);            end        end        if abs(length(DATA.clid)-length(oldid))/length(oldid)  > 0.2            unsafetosave = 1;            unsafelabels{1} = 'classified id length mismatch';        end        PrintMsg(DATA.logfid,str);        ida = setdiff( DATA.oldtrigtimes,DATA.t);        fprintf('Triggers %d/%d old ones gone\n',length(ida),length(DATA.oldtrigtimes))                id = find(DATA.cluster.clst ==2);        missid = setdiff(oldC.times,DATA.t(id));        res.matchcounts(6) = length(missid);        nx = min([length(DATA.cluster.next) length(oldC.next)]);        for k = 1:nx            if isfield(DATA.cluster.next{k},'times') && isfield(oldC.next{k},'times')                id = find(DATA.cluster.clst ==2+k);                missid = setdiff(oldC.next{k}.times,DATA.t(id));                res.matchcounts(6+k) = length(missid);            end        end        if DATA.interactive >= 0        AllV.SetFigure(DATA.tag.oldxy, DATA);        title(str);        AllV.SetFigure(DATA.tag.comparexy, DATA);        hold off;        plot(DATA.xy{1}(DATA.clid(idxa),1),DATA.lastxy(oldid(idxb),1),'.');        hold on;        plot(DATA.xy{1}(DATA.clid(idxa),2),DATA.lastxy(oldid(idxb),2),'r.');        refline(1);        end        if length(idxa) > 1            xc = corrcoef(DATA.xy{1}(DATA.clid(idxa),1),DATA.lastxy(oldid(idxb),1));            yc = corrcoef(DATA.xy{1}(DATA.clid(idxa),2),DATA.lastxy(oldid(idxb),2));            if abs(xc(1,2)) < 0.5                unsafetosave = unsafetosave+2;            end        else            xc = [];            if length(oldid) > 5 % if there are no spikes in the older file, there is no problem                unsafetosave = unsafetosave+2;            end        end                if autocutone %'autocut' on command line            unsafetosave = 0;        end        PrintMsg(DATA.logfid,'%s Trigger match %d %d %d %d',AllV.IDStr(DATA),DATA.reclustern(1),DATA.reclustern(2),DATA.reclustern(3),DATA.reclustern(4)); %reclustern(3) is missing triggers that dont have a match at +-0.5ms        if DATA.reclustern(3)./DATA.reclustern(4) > 0.1            unsafetosave = unsafetosave+4;        end        %manual == 4 means using reflcuster, don't worry about matching old        %space        if DATA.cluster.manual ~= 4            DATA.cluster.auto = DataClusters{p}.auto;        end        if DATA.cluster.manual ==2 %done in plotcluster but not ye quantified. = Can't check            unsafetosave = -1000;        elseif unsafetosave & DATA.cluster.auto == 1  && ~isacell(DATA, DATA.exptno, p);            if DATA.savespikes                fprintf('Mismatched, so redoing autocut and saving\n');                [E, res.cluster] = AllV.CutAndSave(DATA);            else                fprintf('Mismatched, so redoing autocut\n');                [E, res.cluster] = AllV.CutAndSave(DATA,'nosave');            end            DATA = get(DATA.toplevel,'UserData');            AllV.CheckClusters(DATA.cluster,'CheckFitSpace')            unsafetosave  = -unsafetosave;        end        if wasempty == 2  %empty clusters were saved            unsafetosave = unsafetosave + 128;        end % sometimes triggerchan has 2 probes but trigger clearly was really just % one.  Mark this so can check if necessary        if unsafetosave > 0 && length(DATA.cluster.triggerchan) > 1            unsafetosave = unsafetosave + 64;        end%if saved cluster is quick, then can't use saved xy,clst%so just look at times of classified events        if oldC.quick             if sum(res.matchcounts(6:end)) == 0                fprintf('List of clustered spike times matches\n');                unsafetosave = 0;            end            res.wasquick = 1;        else            res.wasquick = 0;        end        res.overlapn = length(ts);        res.cutfraction(1) = length(oldid)./length(DATA.oldclst);        res.cutfraction(2) = length(DATA.clid)./length(DATA.clst);        res.trigmatch = DATA.reclustern;        res.stds  = cat(1,std(DATA.xy{1}),std(DATA.lastxy));        if length(xc) > 1            res.xcorr = [xc(1,2) yc(1,2)];        else            res.xcorr = [0 0 ];        end        DATA.cluster.reclassify.matchcounts = res.matchcounts;        DATA.cluster.reclassify.trigmatch = res.trigmatch;        DATA.cluster.reclassify.xcorr = res.xcorr;        DATA.cluster.reclassify.unsafetosave = unsafetosave;        DATA.cluster.reclassify.probe = p;        DATA.cluster.reclassify.expt = DATA.exptno;    elseif recluster == 1 && refinecluster% Would like to fit old ellipse, then use this starting point to fit GM% model in this space, and adjust ellipse to catpure those points.  But GM% model may go off and fit something else entirelys, esp whern there are% two clusters.%lemM211 Expt 35 P6 is  a good example          if length(DataClusters)< p || ~isfield(DataClusters{p},'mahal')                  unsafetosave = 0;          elseif DataClusters{p}.mahal(1) > DATA.cluster.mahal(1)             if forcecluster == 0                 unsafetosave = 1;             end         elseif DataClusters{p}.auto == 0 && DATA.cluster.exptno ~= forceclusterexpt             %for now only replace auto cuts with refined manual cuts             %if auto == 0 but manual ==3, means this is a previous             %"refinement", so overwrite.              if isfield(DataClusters{p},'manual') && ...                     DataClusters{p}.manual == 1             unsafetosave = 2;             end         end    end        res.auto = DATA.cluster.auto;        res.unsafetosave = unsafetosave;        if DATA.interactive > 0            drawnow;        end    elseif recluster == 10  %old 2, diabled for now        DATA = AllV.ReClassify(DATA);        res.cluster = AllV.SmallCluster(DATA.cluster);    else        DATA = AllV.ReClassify(DATA);        res.cluster = AllV.SmallCluster(DATA.cluster);    end    E = DATA.clusterboundary{DATA.currentcluster};    if DATA.profiling        fprintf('Return from BoundaryCluster %.4f at %.4f\n',mytoc(E.endtime),mytoc(tt(1).time));    end    if isfield(E,'space')    DATA.plottype = AllV.WhichPlotType(E,1);    end    AllV.PlotHistogram(DATA,E, DATA.quickcutmode);    if DATA.profiling        fprintf('Return from PlotHistoGram at %.4f\n',mytoc(tt(1).time));    end    if recluster == 2 && unsafetosave >= 0 && DATA.interactive > 0 %<0 = redone autocut, so may not match        subplot(2,1,2);        hold on;        plot(DATA.xy{1}(DATA.clid(iida),1),DATA.xy{1}(DATA.clid(iida),2),'gx');        hold off;    end    if DATA.autorefine        res.refinemode = DATA.refinemode;    end    if calcdistancematrix        res.DistanceMatrix = AllV.CalcDistanceMatrices(DATA, calcdistancematrix);        DATA.errs = {DATA.errs{:} res.DistanceMatrix.errs{:}};        DATA.errstates = {DATA.errstates{:} res.DistanceMatrix.errstates{:}};        if DATA.interactive >= 0            b = res.DistanceMatrix;            DATA.gmcid = res.DistanceMatrix.cid;            DATA.usegmcid = 1;            GetFigure('DistanceMatrix');            [E,V] = eig(squeeze(b.D(:,:,1)));            [c,d] = sort(E(:,1));            D = MatrixPermute(b.D(:,:,1),d);            imagesc(D);            caxis([0 5]);            AllV.ReplotPCs(DATA,[]);%            set(DATA.toplevel,'UserData',DATA);        end    endelseif DATA.interactive >= 0  %this is inteactive for sure    DATA.cluster = FixCluster(DATA.cluster,DATA);    DATA.watchplots = 1;    DATA.watcharg = {'front'};    DATA.interactive = 1;    plotdprimemax = 1;%    [d, details] = FindDip(DATA.pcs(:,1),DATA.energy(1,:));    [d, details] = GMDip(DATA.pcs(:,1:2),DATA.energy(1,:),'label',DATA.idstr);    dcrit = d(1);    E = AllV.BoundaryFromCluster([],DATA.cluster,DATA.currentcluster);    E.pos(1) = dcrit;    E.pos(3) = dcrit;    E.pos(2)= min(DATA.pcs(:,2));    E.pos(4)= max(DATA.pcs(:,2));    p = E.pos;    E.xyr = [mean(p([1 3])) mean(p([2 4])) abs(diff(p([1 3]))/2) abs(diff(p([2 4]))/2)];    E.shape = 1;    E.space = [1 1 2];    E.h = [];    E.pcplot = [1 2];    if dcrit < 0        DATA.clid = find(DATA.pcs(:,1) < dcrit);        DATA.nid = find(DATA.pcs(:,1) >= dcrit);        cid = find(DATA.pcs(:,1) < d(2));        nid = find(DATA.pcs(:,1) >= dcrit);    else        DATA.clid = find(DATA.pcs(:,1) > dcrit);        DATA.nid = find(DATA.pcs(:,1) <= dcrit);    end    res.id = DATA.clid;%    res.dprime = abs(details.dprime);    res.dvdt = DATA.dvdt;    res.csd = DATA.csd;endres.errs = DATA.errs;if isfield(DATA.cluster,'errs')    res.errs = {res.errs{:} DATA.cluster.errs{:}};endif DATA.profiling    fprintf('recluster done at  %.4f\n',mytoc(tt(1).time));endif ~isfield(DATA.cluster,'auto')    DATA.cluster.auto = 0;endif calcclscores    k = 0;    for j = 1:length(Clusters)        if ~isempty(Clusters{j});            k = k+1;          res.Clusterscores(k,:) = Clusters{j}.MeanSpike.ms * squeeze(AllVoltages(ispk(1),:,:));         end    endend    if plotsummary        AllV.SetFigure(DATA.tag.allspikes, DATA);        AllV.PlotQuickSpikes(DATA,500);        AllV.PlotAllProbes(DATA,'xy')    endif saveclusters == 1 || saveclusters == 3 || (saveclusters == 2 && unsafetosave <= 0)%Calls from teh command line mean that this is automatic clustering. %Unless its a recluster    if saveautocut == 2        DATA.cluster.auto=1;        DATA.savespikes = 2;    end    if (recluster == 0 && DATA.cluster.auto ~= 1) || recluster >  0 || saveautocut == 2    outname = AllV.ClusterFile(DATA.name,DATA.Expt,'subdir',DATA.clustersubdir);    else    outname = AllV.ClusterFile(DATA.name,DATA.Expt,'auto','subdir',DATA.clustersubdir);    end    DATA =  AllV.SaveClusters(DATA, outname);    set(DATA.toplevel,'UserData',DATA);    Cluster = DATA.cluster;% Can't do this any more - DATA.MeanSpike might be for cl 2%    cluster.MeanSpike = DATA.MeanSpike;    if DATA.savespikes        AllV.SaveSpikes(DATA, DATA.savespkid,AllV.SpkFileName(DATA));    endendres.memsz = [AllV.memsize(DATA) DATA.fullvsize];if DATA.csd && DATA.interactive >= 0    AllCSD = diff(AllVoltages,DATA.csd,1);    setappdata(DATA.toplevel,'AllCSD',AllCSD);endif DATA.interactive >= 0 && DATA.plot.covarAllV.SetFigure(DATA.tag.covar, DATA);imagesc(C);endDATA.nid = 1:size(AllVoltages,3);if DATA.readlayout == 2    AllV.ApplyLayout(DATA);endif recluster    if DATA.profiling        fprintf('QuickSpks at %.4f\n',mytoc(tt(1).time));    end    if DATA.quickcutmode.plotspikes && DATA.interactive >=0        AllV.QuickSpks(DATA, 1000);    end    fprintf('recluster %s took %.2f (at %s)\n',AllV.IDStr(DATA),mytoc(tt(1).time),datestr(now));    if DATA.profiling        t = timediff([tt.time]);        for j = 1:length(tt)            fprintf('  %s took %.2f \n',tt(j).str,t(j));        end    endendif DATA.profiling > 1    profile viewer    X = profile('info');    ProfileSummary(X);endif DATA.plot.exptfit > 0 || DATA.plot.expt    DATA.Expt = AllV.PlotExptCounts(DATA);endif DATA.elmousept.shape < 0 && DATA.interactive > 0    DATA = AllV.SetEllipseDrawing(DATA, 1, 'cluster', DATA.currentcluster);endif plottype == 0%may not get logfid from GUI if not interactive %which means each call will open a new handle. So close here    DATA = AllV.CloseLog(DATA);    res.errs = {res.errs{:} DATA.errs{:}};    res.logfid = DATA.logfid;    res.errstates = DATA.errstates;    res.times = tt;    DATA.profiletimes = tt;    if DATA.interactive >= 0        drawnow; % force draing of any other figurs to be sure this sets active figure        set(0,'currentfigure',DATA.toplevel);        AllV.SetGUI(DATA);        set(DATA.toplevel,'UserData',DATA);    end    return;endDATA.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');if DATA.interactive >= 0    AllV.SetFigure(DATA.tag.vare, DATA);    hold off;    c = DATA.probe(1);    plot(DATA.energy(1,:),DATA.spkvar(c,:)./DATA.energy(1,:),'.');    set(DATA.toplevel,'UserData',DATA);    AllV.ShowTaggedProbes(DATA);    AllV.SetFigure(DATA.tag.spikes, DATA);    DATA.plotdvdt = 0;    AllV.PlotSpikes(DATA,1:100);endif oldscores & ~isempty(DataClusters{DATA.probe(1)})    DATA = AllV.CalcTemplatesFromMean(DATA, DataClusters{DATA.probe(1)}.MeanSpike);    DATA.plottype = AllV.WhichPlotType(DataClusters{DATA.probe(1)},1);    E = AllV.BoundaryFromCluster(E,DataClusters{DATA.probe(1)}, DATA.currentcluster);    E.pcplot = DataClusters{DATA.probe(1)}.space(2:end);    DATA.cluster = DataClusters{DATA.probe(1)};endif ~isfield(DATA,'TemplateUsed')    DATA.TemplateUsed = [];endif recluster == 0 && DATA.interactive >= 0 if autocutone == 0    %if recluster i s0, templates may not have been calcualted.  Don't use    %existing "TemplateScores" field - might belong to earlier probe    if ismember(DATA.plottype,[3 4])        DATA.plottype = 1;    end    DATA.cluster.space = [1 1 2];    [cl, Cluster] = AllV.ClassifySpikes(DATA,E,'quick');    cl.MeanSpike = AllV.PlotMeanSpike(DATA);    if oldscores == 0        DATA.cluster = rmfield(Cluster,'r');    else    end    DATA.clid = cl.id;    DATA.nid = cl.nid;    DATA.clst = cl.clst;    Cluster.MeanSpike = cl.MeanSpike;    Cluster.chspk = DATA.chspk;    Cluster.minspke = min(DATA.energy(1,DATA.clid));    E = Cluster;endAllV.PlotHistogram(DATA,E,'quick');DATA = AllV.ReplotPCs(DATA,E);tt = AllV.TimeMark(tt,'Finish',DATA.profiling);res.times = tt;endif spoolspikes    AllV.SpoolSpikes(DATA,DATA.watcharg{:});endif DATA.checkclustersAllV.CheckClusters(DataClusters,'Start');AllV.CheckClusters(DataClusters,'CheckNexts','Start');AllV.CheckClusters(DataClusters,'CheckFitSpace');endres.toplevel = DATA.toplevel;if ~isfield(DATA.cluster,'next')    DATA.cluster.next = {};endDATA = AllV.CloseLog(DATA);if F > 0    set(F,'UserData',DATA);endif nargout > 2    Clusters = AllV.mygetappdata(DATA,'Clusters');    ClusterDetails = AllV.mygetappdata(DATA,'ClusterDetails');    varargout{1} = Clusters{AllV.ProbeNumber(DATA)};    varargout{2} = ClusterDetails{AllV.ProbeNumber(DATA)};endAllV.SetGUI(DATA);