function DATA = ClassifyAll(DATA, force,varargin)        quickcutmode.quick = 0;    cargs = {};    j = 1;    while j <= length(varargin)        if strncmpi(varargin{j},'quick',5)            quickcutmode = DATA.quickcutmode;            quickcutmode.quick = 1;            cargs = {cargs{:} 'quick'};        elseif strncmpi(varargin{j},'recluster',5)            cargs = {cargs{:} varargin{j}};        end        j = j+1;    end    DataClusters = AllV.mygetappdata(DATA,'Clusters');    if DATA.interactive >= 0    oldname = get(DATA.toplevel,'Name');    set(DATA.toplevel,'Name','Classifying...');    drawnow;    end    if isfield(DATA.cluster,'ctime')        ctimes(1) = DATA.cluster.ctime;    else        ctimes(1) = now;    end    iscluster(1) = 1;    e = DATA.cluster.exptno;    for j = 1:length(DATA.cluster.next)        if isfield(DATA.cluster.next{j},'ctime')            ctimes(j+1) = DATA.cluster.next{j}.ctime;        else            if isempty(DATA.cluster.next{j})                ctimes(j+1) = 0;            else                errordlg(sprintf('Missing ctime Cluster %d E%.1f',j+1,e),'Cluster Cut Time','modal');                ctimes(j+1) = j+1;            end        end        if isfield(DATA.cluster.next{j},'space')            iscluster(j+1) = 1;        else            iscluster(j+1) = 0;        end    end    cls = 1:(1+length(DATA.cluster.next));    cls = cls(ctimes>0 & iscluster > 0);    ctimes = ctimes(ctimes > 0 & iscluster > 0);    [a, tlist] = sort(ctimes);    tlist = cls(tlist);    cc = DATA.currentcluster;    if ~isfield(DATA.cluster,'chspk')        DATA.cluster.chspk = DATA.chspk;    end    autorefine = 0;    for j = 1:length(tlist)        needcl = AllV.NeedClusterData(DATA.cluster,tlist(j));        DATA.currentcluster = tlist(j);        if force            DATA = AllV.SetTemplateData(DATA,tlist(j));        end        DATA.cluster = AllV.CheckScoreScaling(DATA, DATA.cluster);        if tlist(j) == 1            DATA.currentcluster = 1;%needcl == 2 means that already classified, but fits not done. If force is%on, the cut is going to be redone anyway            if needcl == 2  && force == 0                if DATA.interactive > 0                    set(DATA.toplevel,'Name',sprintf('Quantifying Cluster %d...',tlist(j)));                    drawnow;                end                DATA.cluster = AllV.ClassifyFit(DATA, DATA.cluster,1);            elseif force || needcl                if DATA.interactive > 0                    set(DATA.toplevel,'Name','Classifying Cluster 1...');                    drawnow;                end%if autorefine, then will have to claissfy twice if ther are > 1clusters.%So on first pass, only do the quck classif. But set quick to zero so that%the second time it treated as new.                if DATA.autorefine > 0 && isfield(DATA.cluster,'fitdprime') && DATA.cluster.fitdprime(1) < DATA.autorefine                    [cl, cluster, DATA.xy{1}] = AllV.ClassifySpikes(DATA,DATA.cluster,'quick','noplot');                    cluster.quick = 0;                    DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],cluster, DATA.currentcluster));                    DATA.cluster.clst = cl.clst;                    DATA = AllV.OptimizeBoundary(DATA);                    autorefine = autorefine+1;                elseif strcmp(DATA.autocutmode,'james');                    DATA = AllV.JamesAutoCut(DATA,'reapply', DATA.cluster);                    cl.id = find(DATA.clst == DATA.cluster.cluster+1);                    cl.nid = find(DATA.clst ~= DATA.cluster.cluster+1);                    cl.clst = DATA.clst;                    cl.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');                    cluster = DATA.cluster;                    DATA.plottype = 13;                else                    [cl, cluster, DATA.xy{1}] = AllV.ClassifySpikes(DATA,DATA.cluster,cargs{:},'noplot','notrig');                    DataClusters{DATA.probe(1)}.mahal = cluster.mahal;                    DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],cluster, DATA.currentcluster));                end                DATA.clid = cl.id;                DATA.nid = cl.nid;                DATA.clst = cl.clst;                if length(cl.id) > 1 && DATA.autorefine == 0                    if quickcutmode.quick == 1                         cl.MeanSpike = DATA.cluster.MeanSpike;                    end                    DATA.MeanSpike = cl.MeanSpike;                    DATA.cluster = cluster;                    DATA.cluster.MeanSpike = cl.MeanSpike;                    if size(DATA.energy,2) >= max(DATA.clid)                        DATA.cluster.minspke = prctile(DATA.energy(1,DATA.clid),1) .* 0.95;                        DATA.cluster.minspkvar = prctile(DATA.spkvar(DATA.probe(1),DATA.clid),1) .* 0.95;                    end                    DATA.cluster.ctime = now;                elseif length(cl.id) <= 1                    DATA.cluster = cluster;                end                if DATA.cluster.mahal(4) < 0.001 && quickcutmode.quick == 0                    c = AllV.PlotHistogram(DATA, []);                    DATA.cluster.mahal(4) = c.gmdprime;                end            end        elseif isfield(DATA.cluster.next{tlist(j)-1},'space')            if needcl == 2 && force == 0                if DATA.interactive > 0                set(DATA.toplevel,'Name',sprintf('Quantifying Cluster %d...',tlist(j)));                drawnow;                end                DATA.cluster.next{tlist(j)-1} = AllV.ClassifyFit(DATA, DATA.cluster.next{tlist(j)-1},tlist(j));            elseif force || needcl                if DATA.interactive > 0                set(DATA.toplevel,'Name',sprintf('Classifying Cluster %d...',tlist(j)));                drawnow;                end            DATA.currentcluster = tlist(j);            if DATA.autorefine > 0 && abs(DATA.cluster.next{tlist(j)-1}.fitdprime(1)) > DATA.autorefine                [xcl, DATA.cluster, DATA.xy{tlist(j)}] = AllV.ClassifySpikes(DATA,DATA.cluster,'quick','noplot','notrig');                DATA = AllV.OptimizeBoundary(DATA);                autorefine = autorefine+1;            else                [xcl, DATA.cluster, DATA.xy{tlist(j)}] = AllV.ClassifySpikes(DATA,DATA.cluster,'noplot', 'notrig',cargs{:});            end            if ~isempty(xcl)                DATA.clst = xcl.clst;            end            if DATA.cluster.next{tlist(j)-1}.mahal(4) < 0.001 && quickcutmode.quick == 0                c = AllV.PlotHistogram(DATA, [], quickcutmode);                DATA.cluster.next{tlist(j)-1}.mahal(4) = c.gmdprime;            end            %            DATA.cluster.next{tlist(j)-1}.ctime = now;            if isfield(xcl,'MeanSpike') %%may not be true on first "quick" pass            DATA.cluster.next{tlist(j)-1}.MeanSpike = xcl.MeanSpike;            end            DATA.clusterboundary{tlist(j)} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],DATA.cluster, tlist(j)));            end        end%if only calculating metrics, don't call this               if DATA.iteratefit && DATA.autorefine > 0 && (needcl == 1 || force)              AllV.IterateFit(DATA, DATA.iteratefit);              DATA = get(DATA.toplevel,'UserData');        end        if DATA.watchplots && (needcl || force) && quickcutmode.quick == 0            AllV.PlotHistogram(DATA, []);            AllV.ReplotPCs(DATA,[]);        end    end%Unrefined Cluster N can steal events from refined cluster N-1, so need to appl one more time %and need to call Classify again anyway to apply refined bounday.%Also set cluster.times in each Cluster now for the same reason    DATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);    if autorefine         DATA.autorefine = 0;        DATA = AllV.ClassifyAll(DATA,1);        DATA.autorefine = 1;    end    %    quantify dropi for other clusters    if quickcutmode.quick == 0 || quickcutmode.dropi        for j = 1:length(DATA.cluster.next)            if ~isempty(DATA.cluster.next{j})                cluster = AllV.PlotTriggerHist(DATA,DATA.cluster.next{j},quickcutmode);                DATA.cluster.next{j}.vhist = cluster.vhist;                DATA.cluster.next{j}.dropi = cluster.dropi;                DATA.cluster.next{j}.times = DATA.t(DATA.clst == j+2);            end        end    end    DATA.cluster = AllV.PlotTriggerHist(DATA,DATA.cluster,'showall',quickcutmode);    if DATA.watchplots > 1        drawnow;    end    DATA.cluster.times = DATA.t(DATA.clst == 2);    DATA.currentcluster = cc;    DATA.clid = find(DATA.clst == cc+1);    if DATA.checkclusters        AllV.CheckClusters(DataClusters, 'CheckNexts','Classify');        AllV.CheckClusters(DataClusters,'CheckFitSpace');    end    if DATA.interactive >= 0    set(DATA.toplevel,'UserData',DATA);    set(DATA.toplevel,'Name',oldname);    end    DATA.endtime = now;