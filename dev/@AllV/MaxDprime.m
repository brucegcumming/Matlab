function [dp, res] = MaxDprime(x, varargin)    y = [];    step = 10;ndim = 1;if length(varargin) && isnumeric(varargin{1}) && length(varargin{1}) == length(x)    y = varargin{1};    j = 2;endif length(y)    theta = 0:pi/36:pi * 35/36;        for j = 1:length(theta)        xy = xyrotate(x,y,theta(j));        rdip(j) = HartigansDipTest(xy(:,1));        [dp, a] = AllV.MaxDprime(xy(:,1));        dps(j) = a.dp;        alldp(j,:) = a.dps;        res.prcs(j) = a.dprc;    end    dp = max(dps);    res.dps = dps;    res.dips = rdip;    res.pelse    pa = sort(x);    k = 1;    for j = step:step:length(pa)-step        dps(k) = (mean(pa(1:j))-mean(pa(j+1:end)))./sqrt(mean([var(pa(1:j)) var(pa(j+1:end))]));        crit(k) = mean(pa(j:j+1));        k=k+1;    end    id = find(diff(sign(diff(abs(dps)))) < 0); %local maxima=    res.dps = dps;    res.crit = crit;    if isempty(id)        dp = 0;        res.dprc = 0;        res.dp = 0;        res.maxid =1;    else    [res.dp,b] = max(abs(dps(id)));    res.dprc = (id(b)*step)./length(x);%may add a check that mean diff(abs(dp)) around here is positive, so that noise on a %negative crossing doesn't qualify    dp = res.dp;    res.maxid = id(b);    if res.dprc < 0.01        dp = 0;    end    endend