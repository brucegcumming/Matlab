function [SSD, details ] = MinimiseLine(params, DATA, state)C = DATA.cluster;xy = DATA.xy{state.cluster};if length(params) == 2a = params(2);xys = xyrotate(xy(:,1),xy(:,2),a-C.angle);else    xys = xy;endC.crit = params(1);crit = C.crit;r = xys(:,1);details.r = r;C.clst(r < C.crit) = 2;C.clst(r>=C.crit) = 1;details.counts = [sum(r < C.crit) sum(r >= C.crit)];[dp, fits, fdetails] = AllV.Fit2Gauss(C, r, DATA);%don't just fit on traditional dprime.  If noise is far away, can%pay to find samll sd for cluster, even by putting boundary in the%middle of the clusterdetails.x = fdetails.x;if isempty(fits{1}) || isempty(fits{2})    SSD = 1e10;elsedpa = (crit - fits{1}.mean)./fits{1}.sd;dpb = (fits{2}.mean-crit)./fits{2}.sd;%dpa and dpb are both positive if fit means are the%correct side of boundary. If this is not true, the value is%uninterpretabledetails.fits = fits;details.y = xys(:,2);details.dpa = dpa;details.dpb = dpb;%don't just sum. Favor the smaller number, If one dp is large, don' t let improvements%in that swampt th esmaller one. Weight accrding to Gaussian, so v large%sdss become irrelevantif state.mintype == 1    if dpa > 0 &&  dpb > 0        w =  4-[dpa dpb];        w(w < 0.1) = 0.1;        dp = -([dpa dpb] * w')./sum(w);        if dp < fdetails.dprime           dp = fdetails.dprime;        end    elseif dpa > 0        dp = -dpa/10;    else        dp = -dpb/10;    endelse    if dpa > 0 &&  dpb > 0        dp = -(dpa+dpb);    elseif dpa > 0        dp = -dpa/10;    else        dp = -dpb/10;    endendSSD = dp;endfitparams = getappdata(DATA.toplevel,'fitparams');fitparams = [fitparams; [params dpa dpb dp]];setappdata(DATA.toplevel,'fitparams',fitparams);