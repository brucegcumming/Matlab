function res = AutoCutAll(ispk, toplevel, Vall,DATA, args)    quickfollow = 0;    maxthriter = 1;    nolog = 0;    parallel = 0;    savearg = 0;    j = 1;    while j <= length(args)        if strncmpi(args{j},'quickfollow',8)            quickfollow = 1;        elseif strncmpi(args{j},'parallel',5)            parallel = 1;        elseif strncmpi(args{j},'savespikes',5)            savearg = j;        elseif strncmpi(args{j},'nolog',5)            nolog = 1;        end        j = j+1;    end    ts = now;    DataClusters = AllV.mygetappdata(DATA,'Clusters');    dname = AllV.ClusterFile(DATA.name, DATA.Expt, 'auto');    if exist(dname)        load(dname);    else        FullVData = MakeFullVInfo(Vall);    end    dname = AllV.ClusterFile(DATA.name, DATA.Expt, 'auto','details');    if exist(dname)        load(dname);    end    autofit = DATA.autofit;    if length(ispk) < 3 && 0 %what was this for        ispk = 1:size(Vall.V,1);    end    tstart = now;    allcuts = {};    if nolog == 0    logfile = AllV.ClusterFile(Vall.name,'log','subdir',DATA.clustersubdir,DATA.Expt);    logfid = fopen(logfile,'a');    else        logfid = -1;    end    if isfield(Vall,'exptno')        name = sprintf('%s Expt %d',Vall.name,Vall.exptno);    else        name = Vall.name;    end    PrintMsg(logfid,'Start on %s at %s\r\n',name,datestr(now));    if size(Vall.V,1) == 1 && strncmp(DATA.DataType,'Grid',4)        exname = Vall.loadname;        if parallel            DATA.logfid = -1;            DATA.savespikes = 3;        else            DATA.logfid = logfid;        end        if parallel            fprintf('Running AutoCutAll in parallel\n');            if savearg %don'w write clustertimes file in parallel                args{savearg} = 'savespikesonly';            end            args{end+1} = 'nolog';            args{end+1} = 'noninteractive';            parfor j = 1:length(ispk)                [res, X{j}, Y{j}] =  AllV.AutoCutOne(DATA, exname, ispk(j), args);            end            for j = 1:length(ispk)                Clusters{ispk(j)} = X{j};                ClusterDetails{ispk(j)} = Y{j};            end            name = AllV.ClusterFile(DATA.name,DATA.Expt,'auto');            fprintf('Took %.2f. Saving Clusters to %s\n',mytoc(ts),name)            save(name,'Clusters','FullVData');            save(AllV.ClusterFile(DATA.name,DATA.Expt,'auto','details'),'ClusterDetails','FullVData');            res.Clusters = Clusters;            return;        else        for j = 1:length(ispk)           res =  AllV.AutoCutOne(DATA, exname, ispk(j), args);        end        end        DATA = get(toplevel,'UserData');        DATA.logfid = -1;        res.Clusters = DataClusters;         return;    end    if size(Vall.V,1) < max(ispk)        PrintMsg(logfid,'Only %d/%d probes',size(Vall.V,1),max(ispk));    end    ispk = ispk(find(ispk <= size(Vall.V,1)));    for j = ispk        istart = now;        a =  AllV.AllVPcs(Vall ,'nowatch',args{:},'tchan',j,'logfid',logfid,'saveautocut');        t = a.cluster.Trigger;        spksd = std(a.cluster.MeanSpike.ms,0,2);        musd = std(a.cluster.MeanSpike.mu,0,2);        [sv, svid] = max(spksd(a.chspk));           a.cluster.good = AllV.GoodCluster(a.cluster);           a.maxmean = a.chspk(svid);           allcuts = {allcuts{:} a};        otherps = setdiff(a.chspk, j);%%  Explore lowering the trigger level if necessary. This can be for two%  reasons:%            1)  Dropping spikes. Produces a clipped distribution of%            trigger point voltages, measured with dropi%            2) cluster not dtopping too many spikes, but there are very%            few non-cluster events, so the real cell is divided into tw%            similar groups. AllV.NeedMore() Checks for this%only explore lower triggers if the spike is biggest on this channel. Otherwise%it will go to very low triggers to get all spikes that are really on another%channel, and run out of memory           evi = a.Evec.Eval(1)./sum(a.Evec.Eval);           nloop = 0;           while AllV.NeedMore(a.cluster, a.Evec) && a.chspk(svid) == j && a.cluster.nspks < 500000 && nloop < autofit.maxthriter               nloop = nloop+1;;               a.cluster.needmore = AllV.NeedMore(a.cluster,a.Evec);               PrintMsg(logfid, 'P%d: NeedMore%d %.2f(%.2f), bmi %.3f mahal%.2f, increasing events to %d\n',...                   j,a.cluster.needmore,a.cluster.dropi(3),a.cluster.trigsd,a.cluster.bmc,a.cluster.mahal(1),a.cluster.nspks*2);                 a = AllV.AllVPcs(Vall, 'nowatch',args{:},'tchan',j, 'spkrate',a.spkrate * 2,'logfid', logfid, 'previous',AllV.PrevCluster(a.cluster),'saveautocut');                 evi = a.Evec.Eval(1)./sum(a.Evec.Eval);           end%if big spike is on another probe, can get spike/MU reversed, makeing it look liek the spike is biggest on %this probe. So, check that size of spike on this probe is bigger that mu%on other probes          if length(a.cluster.chspk) > 1              peakhere = spksd(j) > max(spksd)/1.1 && spksd(j) > max(musd(otherps))/2;          else              peakhere = 1;          end          if AllV.GoodCluster(a.cluster)  && peakhere  && ~strcmp(DATA.autocutmode,'james')              dropi = a.cluster.dropi(3);              nloop = 0;              while ((a.cluster.dropi(3) < 2 && t < -a.xsd && AllV.GoodCluster(a.cluster) > 1 ...                      && a.cluster.dropi(3) >= dropi)) && ...                      a.maxspksused == 0 && nloop < autofit.maxthriter                  nloop = nloop +1;                  dropi = a.cluster.dropi(3); %if dropi gets worse, not following a real cell.                  if a.cluster.dropi < 1 % just lower by 1SD. Estimate too bad to do more                      t = a.cluster.Trigger + a.cluster.trigsd;                  else                      t = a.cluster.Trigger + (2 - a.cluster.dropi(3)).*a.cluster.trigsd;                  end                  if t >= -a.xsd                      t = -a.xsd; %effectively zero                  end                  PrintMsg(logfid,'P%d: DropSD %.2f(%.2f), bmi %.3f mahal%.2f, lowering threshold to %.3f, mine %.2f, took %.1f size %.1f,%.1f\n',...                      j,a.cluster.dropi(3),a.cluster.trigsd,a.cluster.bmc,a.cluster.mahal(1),t,a.cluster.minspke,mytoc(tstart),a.memsz(1),a.memsz(2));                  a.cluster.needmore = 4;                  %put last cluster in a.cluster.first, so if pass a.cluster to AllV.AllVPcs, it is stored                  a.cluster.first = AllV.PrevCluster(a.cluster);                  if isnan(a.cluster.minspke)                      a.cluster.minspke = 0;                  end                  %If following up on previous cut, its quicekst to use the last as a                  %template and just use template space                  %Its quicker, stops it chasing different clusters each time                  if (a.cluster.space(1) == 6 && a.cluster.space(2) == 4) || quickfollow || autofit.maxthriter == 1                      a = AllV.AllVPcs(Vall, 'nowatch',args{:},'tchan',j, 'thr',t,'maxrate',a.spkrate * 2, 'mine',a.cluster.minspke,'minvar',a.cluster.minspkvar,'reapply',a.cluster,'logfid',logfid,'saveclusters');                  else                      a = AllV.AllVPcs(Vall, 'nowatch',args{:},'tchan',j, 'thr',t,'mine',a.cluster.minspke,'minvar',a.cluster.minspkvar,'logfid',logfid,'previous',a.cluster.first,'saveautocut');                  end                  spksd = std(a.cluster.MeanSpike.ms,0,2);                  [sv, svid] = max(spksd(a.chspk));                  a.cluster.good = AllV.GoodCluster(a.cluster);                  a.maxmean = a.chspk(svid);                  allcuts = {allcuts{:} a};              end              if nloop == 0                  fprintf('Good');              end          else              fprintf('NoGood:');          end          a.cluster.good = AllV.GoodCluster(a.cluster);          a.maxmean = a.chspk(svid);          c = a.cluster;          PrintMsg(logfid,'P%d(%d): %d/%d Spikes, dropi %.2f (%.2f) bmc %.3f, mahal %.1f,%.1f,%.1f G%d took %.2f size %.1f, %.1f at %s',...              j,a.maxmean,c.ncut,c.nspks,c.dropi(3),c.dropi(4),c.bmc,c.mahal(1),c.mahal(2),c.mahal(4),AllV.GoodCluster(a.cluster),...              mytoc(istart),a.memsz(1),a.memsz(2),datestr(now));          DataClusters{j}.totaltime = mytoc(istart);          if DATA.interactive >= 0              drawnow;          end    end        if logfid > 2            fclose(logfid);        end        DATA = get(toplevel,'UserData');        if DATA.plot.xcorr        a = PlotSpikeTimes(DataClusters,'xcorr');        for j = 1:length(DataClusters)%            DataClusters{j}.synci = a.synci(j,:);        end        end        DATA.logfid = -1;%        AllV.SaveClusters(DATA,AllV.ClusterFile(DATA.name,DATA.Expt,'auto'));        res.Clusters = DataClusters;        res.cuts = allcuts;        