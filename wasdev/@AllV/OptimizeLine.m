function [C, fits] = OptimizeLine(DATA)    c = DATA.currentcluster;    state.cluster = c;    if DATA.currentcluster > 1        guess(1:4) = DATA.cluster.next{c-1}.xyr;        guess(5) = DATA.cluster.next{c-1}.angle;        %         guess(5) = 0;  %DATA.xy{} is rotated by ellipse angle already        if isfield(DATA.cluster.next{c-1},'aspectratio')            state.aspectratio = DATA.cluster.next{c-1}.aspectratio;        else            state.aspectratio = 1;        end        C = DATA.cluster.next{c-1};    else        C = DATA.cluster;        guess(1) = DATA.cluster.crit;        guess(2) = DATA.cluster.angle;        state.aspectratio = 1;    end    setappdata(DATA.toplevel,'fitparams',[]);    setappdata(DATA.toplevel,'fithists',[]);    %First find best starting point - fitting routine likes local minima    state.mintype = 1; %eucliean sum to weight smaller    [a,b] = GMDip(DATA.xy{state.cluster},[]);    crits = [a(1) a(2) DATA.cluster.crit];    setappdata(DATA.toplevel,'fitparams',[]);    if strcmp(DATA.refinemode,'test')        B = MyDip(DATA.xy{state.cluster}(:,1),'idlist',DATA.cluster.clst);        if B.dip(2)./min(B.dip(3:4)) < 0.97 && B.d > 0.1 & B.d < 0.9            C.crit =  B.x(B.dip(1));        end        fittedparams(1) = C.crit;        fittedparams(2) = C.angle;        [dp, fits] = AllV.MinimiseLine(fittedparams, DATA,state);        return;    end    if strcmp(DATA.refinemode,'full')        for j = 1:length(crits)            guess(1) = crits(j);            [dps(j), afits] = AllV.MinimiseLine(guess, DATA,state);        end    else        j = 0;    end    dip = MyDip(DATA.xy{state.cluster}(:,1));    j = j+1;    guess(1) = dip.dip(2);    [dps(j), afits] = AllV.MinimiseLine(guess, DATA,state);    crit(j) = guess(1);        [a,besti] = min(dps);    guess(1) = crits(besti);    if min(afits.counts) ==0        [d, details] = GMDip(afits.r,[]);        guess(1) = d(1);    end    maxiter = 100;    options = optimset('MaxFunEvals',100000,'maxiter',maxiter,'display','off');    nloop = 0;    %first optimize line position in1D    %setappdata(DATA.toplevel,'fitparams',[]);    %[fittedparams,fval,exitflag, output] = fminsearch(@AllV.MinimiseLine,guess(1),options,DATA,state);    %guess(1) = fittedparams(1);    setappdata(DATA.toplevel,'fitparams',[]);    [fittedparams,fval,exitflag, output] = fminsearch(@AllV.MinimiseLine,guess,options,DATA,state);    [dp, fits] = AllV.MinimiseLine(fittedparams, DATA,state);    dx = mean(diff(fits.x));    if fits.counts(2) < C.ncut/5  %Check counts(2) is alwasy the classified group        s = PrintMsg(DATA.logfid,sprintf('Optimization Failed nspkds %d -> %d',C.ncut,fits.counts(2)));        C = AllV.AddErr(C,s);        return;    end                C.crit = fittedparams(1);        x = fits.fits{1}.mean:dx:fits.fits{2}.mean;        if length(x) > 2            a = FitGauss(x,fits.fits{1}.params,fits.fits{1},'eval');            b = FitGauss(x,fits.fits{2}.params,fits.fits{2},'eval');            % Best value for fit can be with silly criterion that is far enough            %into one group that the fit is odd. So if there is a miniumum, put            %ciriterion there            [c,d] = min(a+b);            b = a+b;            if d > 1 && d < length(x) && c < 0.95 * min(b([1 end]))                C.crit = x(d);                fittedparams(1) = x(d);                [dp, fits] = AllV.MinimiseLine(fittedparams, DATA,state);            end        end        C.angle = fittedparams(2);        C.fitdprime = fits.dpa+fits.dpb;        C.y = minmax(fits.y);        