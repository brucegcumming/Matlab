function [id,  th, details] = TriggerV(DATA, rV)% Find edtrema and Threhold FullV%[id,  th, details] = TriggerV(DATA, rV)th = DATA.Trigger;for j = 1:size(rV,1)    sgn(j,:) = diff(sign(diff(rV(j,:),1,2)),1,2);endif DATA.auto.trigstats    id = find(sgn ~= 0)+1; %extrema    details.skew = skewness(rV(id));    steps = [50 40 10 1 0.1 0.01 0];    x = prctile(rV(id),steps);    y = prctile(rV(id),100 - steps);    details.roc = trapz(abs(x),abs(y))./max(abs([x y])).^2;    details.qq = cat(1,x,y);endid = [];if th(1) < 0%    id = find(sgn(1,:) > 0)+1;    id = find(sgn(1,:) > 0 & rV(2:end-1) < th(1))+1;elseif th(1) > 0    id = find(sgn(1,:) < 0 & rV(2:end-1) > th(1))+1;else    autoth = 1;    if DATA.setnspk <= 0        DATA.setnspk = DATA.spkrate .* DATA.duration;    endendnv = length(id);if isempty(id)    if DATA.trigdt == 4        GetFigure(DATA.tag.vhist);        hold off;        id = find(abs(sgn) > 1);        nv = length(id);        hist(rV(id),500);    end    if DATA.thsign == 1 || DATA.trigdt == 3        id = find(sgn(1,:) < 0)+1;        nv = length(id);        prc = DATA.setnspk .* 100./length(id); % get 1000 spikes        th(1) = prctile(rV(id),100-prc);        id = id(rV(1,id) > th(1));    else        id = find(sgn(1,:) > 0)+1;        nv = length(id);        prc = DATA.setnspk .* 100./length(id); % get 1000 spikes        if prc > 100 %can happen if nspk > # minima            th(1) = max(rV(1,id));        else            th(1) = prctile(rV(1,id),prc);        end        id = id(rV(1,id) < th(1));        if size(rV,1) > 1            xid = find(sgn(2,:) > 0)+1;            prc = DATA.setnspk .* 100./length(xid); % get 1000 spikes            th(1) = prctile(rV(2,xid),prc);            xid = xid(rV(2,xid) < th(1));            id = union(xid,id);        end    endend%if the ISI is very  short, and the trigger channel does not go back to%near zero (th/3) between two trigger points, then throw away the one%witht the smaller trigggerdetails.nevents = length(id);sid = find(diff(id) < DATA.isicheck(1));if length(sid) < length(rV) .* 0.01 %must be a low trigger    okid = [];    for j = 1:length(sid)        if min(rV(id(sid(j)):id(sid(j)+1)) .*sign(th(1))) < abs(th(1))/DATA.isicheck(2)            okid = [okid sid(j)];        end    end    sid = setdiff(sid,okid);    v = cat(1,rV(id(sid)),rV(id(sid+1)));    if th(1) > 0        [a,b] = min(v);    else        [a,b] = max(v);    end    if ~isempty(sid)        xid = id(sid+b-1);        fprintf('%s Removing %d double Triggers (from %d/%d maxima)\n',AllV.IDStr(DATA),length(xid),length(id),nv);        yid = id(sid+2-b);        id = setdiff(id,xid);    endelse    DATA = AllV.AddErr(DATA,'Too many double Triggers (%d/%d)\n',length(sid),length(rV));endid = id(id > -DATA.spts(1) & id < size(rV,2)-DATA.spts(end));if DATA.trigdt == 3  && DATA.thsign < 2 %spk energy trigger. Not alighn to peak voltage near enrgy max%'thboth' (thsign = 2) argument turns this off        FullV = AllV.mygetappdata(DATA,'Vall');    for j =1:length(id)        if DATA.thsign == 1        [a,b] = max(FullV.V(DATA.probe(1),id(j)-5:id(j)+5));        else        [a,b] = min(FullV.V(DATA.probe(1),id(j)-5:id(j)+5));        end        id(j) = id(j)+b-7;    endend